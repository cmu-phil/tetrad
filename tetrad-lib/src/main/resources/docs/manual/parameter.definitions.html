Tetrad Search Parameter Definitions (alphabetized)
Source: <div id="parameters"> in index.html

=== acceptanceProportion ===
<h3 class="parameter_description" id="acceptanceProportion">acceptanceProportion</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="acceptanceProportion_short_desc">Acceptance Proportion</span>
</li>
<li>Long Description: <span id="acceptanceProportion_long_desc"> An edge occurring in this
        proportion of individual FASK graphs will appear in the final
        graph.</span></li>
<li>Default Value: <span id="acceptanceProportion_default_value">0.5</span></li>
            ,.
            <li>Lower
                Bound: <span id="acceptanceProportion_lower_bound">0.0</span></li>
<li>Upper Bound: <span id="acceptanceProportion_upper_bound">1.0</span></li>
<li>Value Type:
                <span id="acceptanceProportion_value_type">Double</span></li>
</ul>


=== addOriginalDataset ===
<h3 class="parameter_description" id="addOriginalDataset">addOriginalDataset</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="addOriginalDataset_short_desc">Yes, if adding the original dataset
        as another bootstrapping</span></li>
<li>Long Description: <span id="addOriginalDataset_long_desc"> Select “Yes” here to include an
        extra run using the original dataset for improved accuracy.</span>
</li>
<li>Default Value: <span id="addOriginalDataset_default_value">false</span></li>
<li>Lower
                Bound: <span id="addOriginalDataset_lower_bound"></span></li>
<li>Upper Bound: <span id="addOriginalDataset_upper_bound"></span></li>
<li>Value Type:
                <span id="addOriginalDataset_value_type">Boolean</span></li>
</ul>


=== adjustOrientations ===
<h3 class="parameter_description" id="adjustOrientations">adjustOrientations</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="adjustOrientations_short_desc">Yes, if the orientation adjustment
        step should be included</span></li>
<li>Long Description: <span id="adjustOrientations_long_desc"> Yes, if the orientation adjustment
        step should be included</span></li>
<li>Default Value: <span id="adjustOrientations_default_value">false</span></li>
<li>Lower
                Bound: <span id="adjustOrientations_lower_bound"></span></li>
            g
            <li>Upper Bound: <span id="adjustOrientations_upper_bound"></span></li>
<li>Value Type:
                <span id="adjustOrientations_value_type">Boolean</span></li>
</ul>


=== allowBidirected ===
<h3 class="parameter_description" id="allowBidirected">allowBidirected</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="allowBidirected_short_desc">
                 Allow bidirected edges to show collider conflicts
        </span></li>
<li>Long Description: <span id="allowBidirected_long_desc">
             Allow bidirected edges to show collider conflicts
        </span></li>
<li>Default Value: <span id="allowBidirected_default_value">false</span></li>
<li>Lower Bound: <span id="allowBidirected_lower_bound"></span></li>
<li>Upper Bound: <span id="allowBidirected_upper_bound"></span></li>
<li>Value Type: <span id="allowBidirected_value_type">Boolean</span></li>
</ul>


=== allowInternalRandomness ===
<h3 class="parameter_description" id="allowInternalRandomness">
            allowInternalRandomness</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="allowInternalRandomness_short_desc">Allow randomness
        inside algorithm</span></li>
<li>Long Description: <span id="allowInternalRandomness_long_desc">This allows
        variables orders to be shuffled in certain sports to avoid local optima</span></li>
<li>Default Value: <span id="allowInternalRandomness_default_value">true</span>
</li>
<li>Lower Bound: <span id="allowInternalRandomness_lower_bound"></span></li>
<li>Upper Bound: <span id="allowInternalRandomness_upper_bound"></span></li>
<li>Value Type: <span id="allowInternalRandomness_value_type">Boolean</span>
</li>
</ul>


=== alpha ===
<h3 class="parameter_description" id="alpha">alpha</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="alpha_short_desc">Cutoff for p values (alpha) (min =
        0.0)</span></li>
<li>Long Description: <span id="alpha_long_desc">
        The cutoff, beyond which test results are judged as dependent, for a
        statistical test of independence. Default 0.05. Higher alpha yields a
        sparser graph.</span></li>
<li>Default Value: <span id="alpha_default_value">0.01</span></li>
<li>Lower Bound: <span id="alpha_lower_bound">0.0</span></li>
<li>Upper Bound: <span id="alpha_upper_bound">1.0</span></li>
<li>Value Type: <span id="alpha_value_type">Double</span></li>
</ul>


=== amBetaAlpha ===
<h3 class="parameter_description" id="amBetaAlpha">amBetaAlpha</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="amBetaAlpha_short_desc">
                The 'alpha' shape parameter for the Beta noise terms.
            </span></li>
<li>Long Description: <span id="amBetaAlpha_long_desc">
                The 'alpha' shape parameter for the Beta noise terms.
        </span></li>
<li>Default
                Value: <span id="amBetaAlpha_default_value">2</span></li>
<li>Lower Bound: <span id="amBetaAlpha_lower_bound">0</span></li>
<li>Upper
                Bound: <span id="amBetaAlpha_upper_bound">Infinity</span></li>
<li>Value Type: <span id="amBetaAlpha_value_type">Double</span></li>
</ul>


=== amBetaBeta ===
<h3 class="parameter_description" id="amBetaBeta">amBetaBeta</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="amBetaBeta_short_desc">
                The 'beta' shape parameter for the Beta noise terms.
            </span></li>
<li>Long Description: <span id="amBetaBeta_long_desc">
                The 'beta' shape parameter for the Beta noise terms.
        </span></li>
<li>Default
                Value: <span id="amBetaBeta_default_value">5</span></li>
<li>Lower Bound: <span id="amBetaBeta_lower_bound">0</span></li>
<li>Upper
                Bound: <span id="amBetaBeta_upper_bound">Infinity</span></li>
<li>Value Type: <span id="amBetaBeta_value_type">Double</span></li>
</ul>


=== amCoefHigh ===
<h3 class="parameter_description" id="amCoefHigh">amCoefHigh</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="amCoefHigh_short_desc">High end of coefficient range (min =
        0.0)</span></li>
<li>Long Description: <span id="amCoefHigh_long_desc">
        Value m2 for coefficients drawn from U(-m2, -m1) U U(m1, m2).</span>
</li>
<li>Default Value: <span id="amCoefHigh_default_value">1.0</span></li>
<li>Lower Bound: <span id="amCoefHigh_lower_bound">0.0</span></li>
<li>Upper Bound: <span id="amCoefHigh_upper_bound">1.7976931348623157E308</span></li>
<li>Value Type: <span id="amCoefHigh_value_type">Double</span></li>
</ul>


=== amCoefLow ===
<h3 class="parameter_description" id="amCoefLow">amCoefLow</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="amCoefLow_short_desc">Low end of coefficient range (min =
        0.0)</span></li>
<li>Long Description: <span id="amCoefLow_long_desc">
        The parameter m1 for coefficients drawn from U(-m2, -m1) U U(m1,
        m2).</span></li>
<li>Default Value: <span id="amCoefLow_default_value">0.2</span></li>
<li>Lower Bound: <span id="amCoefLow_lower_bound">0.0</span></li>
<li>Upper Bound: <span id="amCoefLow_upper_bound">Infinity</span></li>
<li>Value
                Type: <span id="amCoefLow_value_type">Double</span></li>
</ul>


=== amCoefSymmetric ===
<h3 class="parameter_description" id="amCoefSymmetric">amCoefSymmetric</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="amCoefSymmetric_short_desc">Yes if negative coefficient values
        should be considered</span></li>
<li>Long Description: <span id="amCoefSymmetric_long_desc">Yes if coefficients should be drawn
        from +/-(a, b); No if from +(a, b).</span></li>
<li>Default Value:
                <span id="amCoefSymmetric_default_value">true</span></li>
<li>Lower
                Bound: <span id="amCoefSymmetric_lower_bound"></span></li>
<li>Upper
                Bound: <span id="amCoefSymmetric_upper_bound"></span></li>
<li>Value
                Type: <span id="amCoefSymmetric_value_type">Boolean</span></li>
</ul>


=== amDerivativeMax ===
<h3 class="parameter_description" id="amDerivativeMax">amDerivativeMax</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="amDerivativeMax_short_desc">
                'Max' for the U(min, max) range for random derivative values (with f(0) = 0)
            </span></li>
<li>Long Description: <span id="amDerivativeMax_long_desc">
                'Max' for the U(min, max) range for random derivative values (with f(0) = 0)
        </span></li>
<li>Default
                Value: <span id="amDerivativeMax_default_value">1</span></li>
<li>Lower Bound: <span id="amDerivativeMax_lower_bound">-Infinity</span></li>
<li>Upper
                Bound: <span id="amDerivativeMax_upper_bound">Infinity</span></li>
<li>Value Type: <span id="amDerivativeMax_value_type">Double</span></li>
</ul>


=== amDerivativeMin ===
<h3 class="parameter_description" id="amDerivativeMin">amDerivativeMin</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="amDerivativeMin_short_desc">
                'Min' for the U(min, max) range for random derivative values (with f(0) = 0)
            </span></li>
<li>Long Description: <span id="amDerivativeMin_long_desc">
                'Min' for the U(min, max) range for random derivative values (with f(0) = 0)
        </span></li>
<li>Default
                Value: <span id="amDerivativeMin_default_value">-1</span></li>
<li>Lower Bound: <span id="amDerivativeMin_lower_bound">-Infinity</span></li>
<li>Upper
                Bound: <span id="amDerivativeMin_upper_bound">Infinity</span></li>
<li>Value Type: <span id="amDerivativeMin_value_type">Double</span></li>
</ul>


=== amDistortionType ===
<h3 class="parameter_description" id="amDistortionType">amDistortionType</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="amDistortionType_short_desc">
				Add distortion: 1 = Before noise (additive) or 2 = After noise (post-nonlinear)
            </span></li>
<li>Long Description: <span id="amDistortionType_long_desc">
				Add distortion: 1 = Before noise (additive) or 2 = After noise (post-nonlinear)
        </span></li>
<li>Default
                Value: <span id="amDistortionType_default_value">1</span></li>
<li>Lower Bound: <span id="amDistortionType_lower_bound">1</span></li>
<li>Upper
                Bound: <span id="amDistortionType_upper_bound">2</span></li>
<li>Value Type: <span id="amDistortionType_value_type">Integer</span></li>
</ul>


=== amEnsureInvertibility ===
<h3 class="parameter_description" id="amEnsureInvertibility">amEnsureInvertibility</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="amEnsureInvertibility_short_desc">
                Ensure that functions are invertible
            </span></li>
<li>Long Description: <span id="amEnsureInvertibility_long_desc">
                         id="amEnsureInvertibility_short_desc"&gt;
                Ensure that functions are invertible
                </span></li>
<li>Default
                Value: <span id="amEnsureInvertibility_default_value">false</span></li>
<li>Lower Bound:
                <span id="amEnsureInvertibility_lower_bound"></span>
</li>
<li>Upper
                Bound: <span id="amEnsureInvertibility_upper_bound"></span></li>
<li>Value Type: <span id="amEnsureInvertibility_value_type">Boolean</span></li>
</ul>


=== amFirstDerivMax ===
<h3 class="parameter_description" id="amFirstDerivMax">amFirstDerivMax</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="amFirstDerivMax_short_desc">
                'Max' for the U(min, max) range for f'(0) for the causal function
            </span></li>
<li>Long Description: <span id="amFirstDerivMax_long_desc">
                'Max' for the U(min, max) range for f'(0) for the causal function
        </span></li>
<li>Default
                Value: <span id="amFirstDerivMax_default_value">1.0</span></li>
<li>Lower Bound: <span id="amFirstDerivMax_lower_bound">-Infinity</span></li>
<li>Upper
                Bound: <span id="amFirstDerivMax_upper_bound">Infinity</span></li>
<li>Value Type: <span id="amFirstDerivMax_value_type">Double</span></li>
</ul>


=== amFirstDerivMin ===
<h3 class="parameter_description" id="amFirstDerivMin">amFirstDerivMin</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="amFirstDerivMin_short_desc">
                'Min' for the U(min, max) range for f'(0) for the causal function
            </span></li>
<li>Long Description: <span id="amFirstDerivMin_long_desc">
                'Min' for the U(min, max) range for f'(0) for the causal function
        </span></li>
<li>Default
                Value: <span id="amFirstDerivMin_default_value">-1.0</span></li>
<li>Lower Bound: <span id="amFirstDerivMin_lower_bound">-Infinity</span></li>
<li>Upper
                Bound: <span id="amFirstDerivMin_upper_bound">Infinity</span></li>
<li>Value Type: <span id="amFirstDerivMin_value_type">Double</span></li>
</ul>


=== amNumPostNonlinearFunctions ===
<h3 class="parameter_description" id="amNumPostNonlinearFunctions">amNumPostNonlinearFunctions</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="amNumPostNonlinearFunctions_short_desc">
                The number of random post-nonlinear functions to choose from
            </span></li>
<li>Long Description: <span id="amNumPostNonlinearFunctions_long_desc">
                    The number of random post-nonlinear functions to choose from
        </span></li>
<li>Default
                Value: <span id="amNumPostNonlinearFunctions_default_value">3</span></li>
<li>Lower Bound: <span id="amNumPostNonlinearFunctions_lower_bound">1</span></li>
<li>Upper
                Bound: <span id="amNumPostNonlinearFunctions_upper_bound">2147483647</span></li>
<li>Value Type: <span id="amNumPostNonlinearFunctions_value_type">Integer</span></li>
</ul>


=== amRescaleMax ===
<h3 class="parameter_description" id="amRescaleMax">amRescaleMax</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="amRescaleMax_short_desc">
                Variables will be rescaled to [min, max] for this max; if min = max
                no rescaling will be done
            </span></li>
<li>Long Description: <span id="amRescaleMax_long_desc">
                Variables will be rescaled to [min, max] for this max; if min = max
                no rescaling will be done
        </span></li>
<li>Default
                Value: <span id="amRescaleMax_default_value">1</span></li>
<li>Lower Bound: <span id="amRescaleMax_lower_bound">-Infinity</span></li>
<li>Upper
                Bound: <span id="amRescaleMax_upper_bound">Infinity</span></li>
<li>Value Type: <span id="amRescaleMax_value_type">Double</span></li>
</ul>


=== amRescaleMin ===
<h3 class="parameter_description" id="amRescaleMin">amRescaleMin</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="amRescaleMin_short_desc">
                Variables will be rescaled to [min, max] for this min; if min = max
                no rescaling will be done
            </span></li>
<li>Long Description: <span id="amRescaleMin_long_desc">
                Variables will be rescaled to [min, max] for this min; if min = max
                no rescaling will be done
        </span></li>
<li>Default
                Value: <span id="amRescaleMin_default_value">-1</span></li>
<li>Lower Bound: <span id="amRescaleMin_lower_bound">-Infinity</span></li>
<li>Upper
                Bound: <span id="amRescaleMin_upper_bound">Infinity</span></li>
<li>Value Type: <span id="amRescaleMin_value_type">Double</span></li>
</ul>


=== amTaylorSeriesDegree ===
<h3 class="parameter_description" id="amTaylorSeriesDegree">amTaylorSeriesDegree</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="amTaylorSeriesDegree_short_desc">
                The maximum exponent for a Taylor series to use as a random
                post-nonlinear function
            </span></li>
<li>Long Description: <span id="amTaylorSeriesDegree_long_desc">
                    The maximum exponent for a Taylor series to use as a random
                post-nonlinear function. The f(0) term is set to 0.
        </span></li>
<li>Default
                Value: <span id="amTaylorSeriesDegree_default_value">10</span></li>
<li>Lower Bound: <span id="amTaylorSeriesDegree_lower_bound">1</span></li>
<li>Upper
                Bound: <span id="amTaylorSeriesDegree_upper_bound">2147483647</span></li>
<li>Value Type: <span id="amTaylorSeriesDegree_value_type">Integer</span></li>
</ul>


=== anmNoiseKind ===
<h3 class="parameter_description" id="anmNoiseKind">anmNoiseKind</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="anmNoiseKind_short_desc">
        Noise distribution family: 1 = Beta (skewed), 2 = Gaussian, 3 = Student-t (heavy-tailed)
    </span></li>
<li>Long Description: <span id="anmNoiseKind_long_desc">
        Selects the distribution of exogenous noise for the ANM simulator
        Options: 1 = Beta (skewed), 2 = Gaussian, 3 = Student-t (heavy-tailed).
    </span></li>
<li>Default Value: <span id="anmNoiseKind_default_value">1</span></li>
<li>Lower Bound: <span id="anmNoiseKind_lower_bound">1</span></li>
<li>Upper Bound: <span id="anmNoiseKind_upper_bound">3</span></li>
<li>Value Type: <span id="anmNoiseKind_value_type">Integer</span></li>
</ul>


=== anmNoiseStrength ===
<h3 class="parameter_description" id="anmNoiseStrength">anmNoiseStrength</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="anmNoiseStrength_short_desc">
        Controls variance/strength of noise in ANM simulator
    </span></li>
<li>Long Description: <span id="anmNoiseStrength_long_desc">
        A slider in [0,1] that scales the standard deviation of the chosen noise distribution.
        Low values yield weak noise, high values yield stronger noise. For Student-t, this also
        interacts with degrees of freedom (heavier tails at higher strength).
    </span></li>
<li>Default Value: <span id="anmNoiseStrength_default_value">0.4</span></li>
<li>Lower Bound: <span id="anmNoiseStrength_lower_bound">0.0</span></li>
<li>Upper Bound: <span id="anmNoiseStrength_upper_bound">10.0</span></li>
<li>Value Type: <span id="anmNoiseStrength_value_type">Double</span></li>
</ul>


=== anmNonlinearity ===
<h3 class="parameter_description" id="anmNonlinearity">anmNonlinearity</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="anmNonlinearity_short_desc">
        Controls strength of nonlinearity in ANM simulator
    </span></li>
<li>Long Description: <span id="anmNonlinearity_long_desc">
        A slider in [0,1] that simultaneously controls the number of basis units
        per edge and their amplitude. Low values produce nearly linear functions,
        high values produce strongly nonlinear functions.
    </span></li>
<li>Default Value: <span id="anmNonlinearity_default_value">0.6</span></li>
<li>Lower Bound: <span id="anmNonlinearity_lower_bound">0.0</span></li>
<li>Upper Bound: <span id="anmNonlinearity_upper_bound">10.0</span></li>
<li>Value Type: <span id="anmNonlinearity_value_type">Double</span></li>
</ul>


=== anmPreset ===
<h3 class="parameter_description" id="anmPreset">anmPreset</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="anmPreset_short_desc">
        Preset function family: 1 = Smooth RBF, 2 = Wavy RBF, 3 = Tanh, 4 = Polynomial
    </span></li>
<li>Long Description: <span id="anmPreset_long_desc">
        Selects the base family of nonlinear functions used on each edge for the ANM simulator.
        Options: 1 = Smooth RBF (gentle), 2 = Wavy RBF (richer),
        3 = Tanh (sigmoidal), 4 = Polynomial (low-degree).
    </span></li>
<li>Default Value: <span id="anmPreset_default_value">2</span></li>
<li>Lower Bound: <span id="anmPreset_lower_bound">1</span></li>
<li>Upper Bound: <span id="anmPreset_upper_bound">4</span></li>
<li>Value Type: <span id="anmPreset_value_type">Integer</span></li>
</ul>


=== applyR1 ===
<h3 class="parameter_description" id="applyR1">applyR1</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="applyR1_short_desc"> Yes if the orient away from arrow rule
        should be applied</span></li>
<li>Long Description: <span id="applyR1_long_desc"> Set this parameter to “No” if a chain of
        directed edges pointing in the same direction when only the first few
        such orientations are justified based on the data.</span></li>
<li>Default Value: <span id="applyR1_default_value">true</span></li>
<li>Lower Bound: <span id="applyR1_lower_bound"></span></li>
<li>Upper Bound: <span id="applyR1_upper_bound"></span></li>
<li>Value Type: <span id="applyR1_value_type">Boolean</span></li>
</ul>


=== avgDegree ===
<h3 class="parameter_description" id="avgDegree">avgDegree</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="avgDegree_short_desc">Average degree of graph (min =
        0)</span></li>
<li>Long Description: <span id="avgDegree_long_desc">
        The average degree of a graph is equal to 2E / V, where E is the
        number of edges in the graph and V the number of variables (vertices)
        in the graph, since each edge has two endpoints.</span></li>
<li>Default Value: <span id="avgDegree_default_value">2</span></li>
<li>Lower Bound: <span id="avgDegree_lower_bound">0</span></li>
<li>Upper Bound: <span id="avgDegree_upper_bound">2147483647</span></li>
<li>Value Type:
                <span id="avgDegree_value_type">Double</span></li>
</ul>


=== basisScale ===
<h3 class="parameter_description" id="basisScale">basisScale</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="basisScale_short_desc">
                    Variables are scaled to [-b, b] for this b (0 = standardized)
        </span></li>
<li>Long Description: <span id="basisScale_long_desc">
                    id="basisScale_short_desc"&gt;
                    Variables are scaled to [-b, b] for this b (0 = standardized)
                    </span></li>
<li>Default
                Value: <span id="basisScale_default_value">1</span></li>
<li>
<lower></lower>
                Bound: <span id="basisScale_lower_bound">0</span></li>
<li>Upper
                Bound: <span id="basisScale_upper_bound">500000</span></li>
<li>Value Type:
                <span id="basisScale_value_type">Double</span></li>
</ul>


=== basisType ===
<h3 class="parameter_description" id="basisType">basisType</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="basisType_short_desc">
                    Basis type (0 = Polynomial, 1 = Legendre, 2 = Hermite, 3=Chebyshev)
        </span></li>
<li>Long Description: <span id="basisType_long_desc">
                    id="basisType_short_desc"&gt;
                    Basis type (0 = Polynomial, 1 = Legendre, 2 = Hermite, 3=Chebyshev)
                    </span></li>
<li>Default
                Value: <span id="basisType_default_value">1</span></li>
<li>Lower
                Bound: <span id="basisType_lower_bound">0</span></li>
<li>Upper
                Bound: <span id="basisType_upper_bound">3</span></li>
<li>Value Type:
                <span id="basisType_value_type">Integer</span></li>
</ul>


=== bootstrappingNumThreads ===
<h3 class="parameter_description" id="bootstrappingNumThreads">bootstrappingNumThreads</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="bootstrappingNumThreads_short_desc">The number of threads (&gt;= 1) to use for the bootstrapping</span>
</li>
<li>Long Description: <span id="bootstrappingNumThreads_long_desc">
                    This is the number of threads for the bootstrapping itself. The number
                    of threads that each algorithm uses is set by the individual algorithm.
                    </span>
</li>
<li>Default Value: <span id="bootstrappingNumThreads_default_value">1</span></li>
<li>Lower
                Bound: <span id="bootstrappingNumThreads_lower_bound">1</span></li>
<li>Upper Bound: <span id="bootstrappingNumThreads_upper_bound">1000000</span></li>
<li>Value Type:
                <span id="bootstrappingNumThreads_value_type">Integer</span></li>
</ul>
<p>Note: You must specify the "Value Type" of each parameter, and
            the value type must be one of the following: Integer, Long, Double, String,
            Boolean.</p>


=== bossAlg ===
<h3 class="parameter_description" id="bossAlg">bossAlg</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="bossAlg_short_desc">Picks the BOSS algorithm type, BOSS1 or BOSS2</span></li>
<li>Long
                Description: <span id="bossAlg_long_desc">1 = BOSS1, 2 = BOSS2, 3 = BOSS3
        </span></li>
<li>Default Value: <span id="bossAlg_default_value">1</span></li>
<li>Lower Bound:
                <span id="bossAlg_lower_bound">1</span></li>
<li>Upper Bound:
                <span id="bossAlg_upper_bound">3</span></li>
<li>Value Type:
                <span id="bossAlg_value_type">Integer</span></li>
</ul>


=== cacheScores ===
<h3 class="parameter_description" id="cacheScores">cacheScores</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="cacheScores_short_desc">Yes score results should be cached, no if
        not</span></li>
<li>Long Description: <span id="cacheScores_long_desc">Caching scores can use a lot of
        memory.</span></li>
<li>Default Value: <span id="cacheScores_default_value">true</span></li>
<li>Lower Bound:
                <span id="cacheScores_lower_bound"></span></li>
<li>Upper Bound:
                <span id="cacheScores_upper_bound"></span></li>
<li>Value Type: <span id="cacheScores_value_type">Boolean</span></li>
</ul>


=== calculateEuclidean ===
<h3 class="parameter_description" id="calculateEuclidean">calculateEuclidean</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="calculateEuclidean_short_desc">Yes if the Euclidean norm squared
        should be calculated (slow), No if not</span></li>
<li>Long
                Description: <span id="calculateEuclidean_long_desc"> The generalized
        information criterion is defined with an information term that take a
        Euclidean norm squares; there can be calculated directly. </span></li>
<li>Default Value: <span id="calculateEuclidean_default_value">false</span></li>
<li>Lower
                Bound: <span id="calculateEuclidean_lower_bound"></span></li>
<li>Upper Bound: <span id="calculateEuclidean_upper_bound"></span></li>
<li>Value Type:
                <span id="calculateEuclidean_value_type">Boolean</span></li>
</ul>


=== cciScoreAlpha ===
<h3 class="parameter_description" id="cciScoreAlpha">cciScoreAlpha</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="cciScoreAlpha_short_desc">Cutoff for p values (alpha) (min =
        0.0)</span></li>
<li>Long Description: <span id="cciScoreAlpha_long_desc">Alpha level (0 to 1)</span></li>
<li>Default Value: <span id="cciScoreAlpha_default_value">0.01</span></li>
<li>Lower Bound:
                <span id="cciScoreAlpha_lower_bound">0.0</span></li>
<li>Upper Bound:
                <span id="cciScoreAlpha_upper_bound">1.0</span></li>
<li>Value Type:
                <span id="cciScoreAlpha_value_type">Double</span></li>
</ul>


=== cellTableType ===
<h3 class="parameter_description" id="cellTableType">cellTableType</h3>
<ul class="cellTableType_list">
<li>Short Description: <span id="cellTableType_short_desc">
            		The type of cell table to use (optimization), 1 = AD Tree, 2 = Count Sample
            </span></li>
<li>Long Description: <span id="cellTableType_long_desc">
                   This is just whether table counts are to be calculated using one method
                   or another, for optimization. The AD tree option uses AD trees to do
                   the calculation; the Count Samples option simply counts the samples
                   for each independence question and builds a table that way.
                    </span></li>
<li>Default Value: <span id="cellTableType_default_value">1</span></li>
<li>Lower
                Bound: <span id="cellTableType_lower_bound">1</span></li>
<li>Upper Bound: <span id="cellTableType_upper_bound">2</span></li>
<li>Value Type:
                <span id="cellTableType_value_type">Integer</span></li>
</ul>


=== cgExact ===
<h3 class="parameter_description" id="cgExact">cgExact</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="cgExact_short_desc"> Yes if the exact algorithm should be used
        for continuous parents and discrete children</span></li>
<li>Long
                Description: <span id="cgExact_long_desc"> For the conditional
        Gaussian likelihood, if the exact algorithm is desired for discrete
        children and continuous parents, set this parameter to “Yes”.</span>
</li>
<li>Default Value: <span id="cgExact_default_value">false</span></li>
<li>Lower Bound: <span id="cgExact_lower_bound"></span></li>
<li>Upper Bound: <span id="cgExact_upper_bound"></span></li>
<li>Value Type: <span id="cgExact_value_type">Boolean</span></li>
</ul>


=== checkAdjacencySepsets ===
<h3 class="parameter_description" id="checkAdjacencySepsets">checkAdjacencySepsets</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="checkAdjacencySepsets_short_desc">Yes if adjacency sepsets
                    should be checked after all recursive sepsets check (default=No)</span></li>
<li>Long Description: <span id="checkAdjacencySepsets_long_desc"> Yes if adjacency sepsets
                    should be checked after all recursive sepsets check (default=No).
                    This is needed for FCIT to pass an Oracle test but may reduce
                    accuracy. </span>
</li>
<li>Default Value: <span id="checkAdjacencySepsets_default_value">false</span></li>
<li>Lower
                Bound: <span id="checkAdjacencySepsets_lower_bound"></span></li>
<li>Upper Bound: <span id="checkAdjacencySepsets_upper_bound"></span></li>
<li>Value Type:
                <span id="checkAdjacencySepsets_value_type">Boolean</span></li>
</ul>


=== checkType ===
<h3 class="parameter_description" id="checkType">checkType</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="checkType_short_desc">
                    Model significance check type: 1 = Significance, 2 = Clique, 3 = None
            </span></li>
<li>Long Description: <span id="checkType_long_desc">
        		Model significance check type: 1 = Significance, 2 = Clique, 3 = None
                </span></li>
<li>Default Value: <span id="checkType_default_value">1</span></li>
<li>Lower Bound: <span id="checkType_lower_bound">1</span></li>
<li>Upper Bound: <span id="checkType_upper_bound">3</span></li>
<li>Value
                Type: <span id="checkType_value_type">Integer</span></li>
</ul>


=== clusterSizes ===
<h3 class="parameter_description" id="clusterSizes">clusterSizes</h3>
<ul class="clusterSizes_list">
<li>Short Description: <span id="clusterSizes_short_desc">
				Cluster sizes to check (comma separated, each &gt;= 2, default = "2")
        </span></li>
<li>Long Description: <span id="clusterSizes_long_desc">
                    Cluster sizes to check (comma separated, each &gt;= 2, default = "2")</span>
</li>
<li>Default Value: <span id="clusterSizes_default_value"></span></li>
<li>Lower Bound: <span id="clusterSizes_lower_bound"></span></li>
<li>Upper Bound: <span id="clusterSizes_upper_bound"></span></li>
<li>Value Type: <span id="clusterSizes_value_type">String</span></li>
</ul>


=== coefHigh ===
<h3 class="parameter_description" id="coefHigh">coefHigh</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="coefHigh_short_desc"> High end of coefficient range (min =
        0.0)</span></li>
<li>Long Description: <span id="coefHigh_long_desc">
        Value m2 for coefficients drawn from U(-m2, -m1) U U(m1, m2).</span>
</li>
<li>Default Value: <span id="coefHigh_default_value">1.0</span></li>
<li>Lower Bound: <span id="coefHigh_lower_bound">0.0</span></li>
<li>Upper Bound: <span id="coefHigh_upper_bound">1.7976931348623157E308</span></li>
<li>Value Type: <span id="coefHigh_value_type">Double</span></li>
</ul>


=== coefLow ===
<h3 class="parameter_description" id="coefLow">coefLow</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="coefLow_short_desc"> Low end of coefficient range (min =
        0.0)</span></li>
<li>Long Description: <span id="coefLow_long_desc">
        The parameter m1 for coefficients drawn from U(-m2, -m1) U U(m1,
        m2).</span></li>
<li>Default Value: <span id="coefLow_default_value">0.0</span></li>
<li>Lower Bound: <span id="coefLow_lower_bound">0.0</span></li>
<li>Upper Bound: <span id="coefLow_upper_bound">1.7976931348623157E308</span></li>
<li>Value
                Type: <span id="coefLow_value_type">Double</span></li>
</ul>


=== coefSymmetric ===
<h3 class="parameter_description" id="coefSymmetric">coefSymmetric</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="coefSymmetric_short_desc">Yes if negative coefficient values
        should be considered</span></li>
<li>Long Description: <span id="coefSymmetric_long_desc"> Yes if coefficients should be drawn
        from +/-(a, b); No if from +(a, b).</span></li>
<li>Default Value:
                <span id="coefSymmetric_default_value">true</span></li>
<li>Lower
                Bound: <span id="coefSymmetric_lower_bound"></span></li>
<li>Upper
                Bound: <span id="coefSymmetric_upper_bound"></span></li>
<li>Value
                Type: <span id="coefSymmetric_value_type">Boolean</span></li>
</ul>


=== colliderDiscoveryRule ===
<h3 class="parameter_description" id="colliderDiscoveryRule">colliderDiscoveryRule</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="colliderDiscoveryRule_short_desc"> Collider discovery: 1 = Lookup
        from adjacency sepsets, 2 = Conservative (CPC), 3 = Max-P</span>
</li>
<li>Long Description: <span id="colliderDiscoveryRule_long_desc"> One may look them up from
        sepsets, as in the original PC, or estimate them conservatively, as
        from the Conservative PC algorithm, or by choosing the sepsets with
        the maximum p-value, as in PC-Max. </span></li>
<li>Default Value:
                <span id="colliderDiscoveryRule_default_value">1</span></li>
<li>Lower Bound: <span id="colliderDiscoveryRule_lower_bound">1</span></li>
<li>Upper Bound:
                <span id="colliderDiscoveryRule_upper_bound">3</span></li>
<li>Value
                Type: <span id="colliderDiscoveryRule_value_type">Integer</span></li>
</ul>


=== colliderOrientationStyle ===
<h3 class="parameter_description" id="colliderOrientationStyle">colliderOrientationStyle</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="colliderOrientationStyle_short_desc">
                Collider Orientation Style: 1 = Sepsets 2 = Conservative 3 = Max-P
            </span></li>
<li>Long Description: <span id="colliderOrientationStyle_long_desc">
                Collider Orientation Style: 1 = Sepsets 2 = Conservative 3 = Max-P
        </span></li>
<li>Default Value:
                <span id="colliderOrientationStyle_default_value">3</span></li>
<li>Lower Bound:
                <span id="colliderOrientationStyle_lower_bound">1</span></li>
<li>Upper Bound: <span id="colliderOrientationStyle_upper_bound">3</span></li>
<li>Value Type: <span id="colliderOrientationStyle_value_type">Integer</span></li>
</ul>


=== completeRuleSetUsed ===
<h3 class="parameter_description" id="completeRuleSetUsed">completeRuleSetUsed</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="completeRuleSetUsed_short_desc"> Yes if the complete FCI rule set
        should be used</span></li>
<li>Long Description: <span id="completeRuleSetUsed_long_desc"> No if the (simpler) final
        orientation rules set due to P. Spirtes, guaranteeing arrow
        completeness, should be used; yes if the (fuller) set due to J. Zhang,
        should be used guaranteeing additional tail completeness. </span>
</li>
<li>Default Value: <span id="completeRuleSetUsed_default_value">true</span></li>
<li>Lower
                Bound: <span id="completeRuleSetUsed_lower_bound"></span></li>
<li>Upper Bound: <span id="completeRuleSetUsed_upper_bound"></span></li>
<li>Value Type:
                <span id="completeRuleSetUsed_value_type">Boolean</span></li>
</ul>


=== concurrentFAS ===
<h3 class="parameter_description" id="concurrentFAS">concurrentFAS</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="concurrentFAS_short_desc">Yes if a concurrent FAS should be
        done</span></li>
<li>Long Description: <span id="concurrentFAS_long_desc"> Yes if the version of the PC adjacency
        search that uses concurrent processing should be used, no if
        not.</span></li>
<li>Default Value: <span id="concurrentFAS_default_value">false</span></li>
<li>Lower Bound:
                <span id="concurrentFAS_lower_bound"></span></li>
<li>Upper Bound:
                <span id="concurrentFAS_upper_bound"></span></li>
<li>Value Type:
                <span id="concurrentFAS_value_type">Boolean</span></li>
</ul>


=== conditioningThreshold ===
<h3 class="parameter_description" id="conditioningThreshold">conditioningThreshold</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="conditioningThreshold_short_desc">
                    Matrix conditioning values above which Eigenvalue whitening is used.
                    Default 1e-10.
        </span></li>
<li>Long Description: <span id="conditioningThreshold_long_desc">
                    Matrix conditioning values above which Eigenvalue whitening is used.
                    For smaller tresholds, the faster Cholesky whitening is used.
                    Default 1e-10, &lt; 0 forces Eigenvalue whitening.
         </span></li>
<li>Default Value: <span id="conditioningThreshold_default_value">1e-10</span></li>
<li>Lower Bound: <span id="conditioningThreshold_lower_bound">-Infinity</span></li>
<li>Upper
                Bound: <span id="conditioningThreshold_upper_bound">Infinity</span></li>
<li>Value
                Type: <span id="conditioningThreshold_value_type">Double</span></li>
</ul>


=== conflictRule ===
<h3 class="parameter_description" id="conflictRule">conflictRule</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="conflictRule_short_desc">Collider conflicts: 1 = Prioritize existing
                colliders, 2 =
        Orient bidirected, 3 = Overwrite existing colliders</span></li>
<li>Long Description: <span id="conflictRule_long_desc"> 1 if the
        “overwrite” rule as introduced in the PCALG R package, 2 if all
        collider conflicts using bidirected edges, or 3 if existing colliders
        should be prioritized, ignoring subsequent conflicting
        information.</span></li>
<li>Default Value: <span id="conflictRule_default_value">1</span></li>
<li>Lower Bound: <span id="conflictRule_lower_bound">1</span></li>
<li>Upper Bound: <span id="conflictRule_upper_bound">3</span></li>
<li>Value Type: <span id="conflictRule_value_type">Integer</span></li>
</ul>


=== connected ===
<h3 class="parameter_description" id="connected">connected</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="connected_short_desc">Yes if graph should be
        connected</span></li>
<li>Long Description: <span id="connected_long_desc"> Yes if a random graph should be generated
        in which paths exists from every node to every other, no if
        not.</span></li>
<li>Default Value: <span id="connected_default_value">false</span></li>
<li>Lower Bound: <span id="connected_lower_bound"></span></li>
<li>Upper Bound: <span id="connected_upper_bound"></span></li>
<li>Value Type: <span id="connected_value_type">Boolean</span></li>
</ul>


=== correlationThreshold ===
<h3 class="parameter_description" id="correlationThreshold">correlationThreshold</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="correlationThreshold_short_desc">Correlation
        Threshold</span></li>
<li>Long Description: <span id="correlationThreshold_long_desc"> The algorithm will complain if
        correlations are found that are greater than this in absolute
        value.</span></li>
<li>Default Value: <span id="correlationThreshold_default_value">1</span></li>
<li>Lower
                Bound: <span id="correlationThreshold_lower_bound">0</span></li>
<li>Upper Bound: <span id="correlationThreshold_upper_bound">1</span></li>
<li>Value Type:
                <span id="correlationThreshold_value_type">Double</span></li>
</ul>


=== covHigh ===
<h3 class="parameter_description" id="covHigh">covHigh</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="covHigh_short_desc">High end of covariance range (min =
        0.0)</span></li>
<li>Long Description: <span id="covHigh_long_desc">
        The parameter c2 for range +/-U(c1, c2) for covariance values, c1 &gt;=
        0.0</span></li>
<li>Default Value: <span id="covHigh_default_value">0.0</span></li>
<li>Lower Bound: <span id="covHigh_lower_bound">0.0</span></li>
<li>Upper Bound: <span id="covHigh_upper_bound">1.7976931348623157E308</span></li>
<li>Value
                Type: <span id="covHigh_value_type">Double</span></li>
</ul>


=== covLow ===
<h3 class="parameter_description" id="covLow">covLow</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="covLow_short_desc">Low end of covariance range (min =
        0.0)</span></li>
<li>Long Description: <span id="covLow_long_desc">
        The parameter c1 for range +/-U(c1, c2) for covariance values, c2 &gt;=
        c1</span></li>
<li>Default Value: <span id="covLow_default_value">0.0</span></li>
<li>Lower Bound: <span id="covLow_lower_bound">0.0</span></li>
<li>Upper Bound: <span id="covLow_upper_bound">1.7976931348623157E308</span></li>
<li>Value
                Type: <span id="covLow_value_type">Double</span></li>
</ul>


=== covSymmetric ===
<h3 class="parameter_description" id="covSymmetric">covSymmetric</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="covSymmetric_short_desc">Yes if negative covariance values should
        be considered</span></li>
<li>Long Description: <span id="covSymmetric_long_desc"> Usually covariance values are chosen
        from +/-U(a, b) for some a, b, no if from +U(a, b). </span></li>
<li>Default Value: <span id="covSymmetric_default_value">true</span></li>
<li>Lower Bound:
                <span id="covSymmetric_lower_bound"></span></li>
<li>Upper Bound:
                <span id="covSymmetric_upper_bound"></span></li>
<li>Value Type:
                <span id="covSymmetric_value_type">Boolean</span></li>
</ul>


=== cpdag ===
<h3 class="parameter_description" id="cpdag">cpdag</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="cpdag_short_desc">True if a CPDAG should be returned, false if a DAG</span></li>
<li>Long Description: <span id="cpdag_long_desc">The algorithm returns a DAG; if this is
                    set to True, this DAG is converted to a CPDAG</span>
</li>
<li>Default Value: <span id="cpdag_default_value">true</span></li>
<li>Lower
                Bound: <span id="cpdag_lower_bound"></span></li>
<li>Upper Bound: <span id="cpdag_upper_bound"></span></li>
<li>Value Type:
                <span id="cpdag_value_type">Boolean</span></li>
</ul>


=== cstarCpdagAlgorithm ===
<h3 class="parameter_description" id="cstarCpdagAlgorithm">cstarCpdagAlgorithm</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="cstarCpdagAlgorithm_short_desc">Algorithm: 1 = PC Stable, 2 = FGES, 3 = BOSS, 4 = Restricted BOSS </span>
</li>
<li>Long Description: <span id="cstarCpdagAlgorithm_long_desc">The CPDAG algorithm to use: 1 = PC Stable, 2 = FGES, 3 = BOSS, 4 = Restricted BOSS </span>
</li>
<li>Default Value: <span id="cstarCpdagAlgorithm_default_value">4</span></li>
<li>Lower
                Bound: <span id="cstarCpdagAlgorithm_lower_bound">1</span></li>
<li>Upper Bound: <span id="cstarCpdagAlgorithm_upper_bound">4</span></li>
<li>Value Type:
                <span id="cstarCpdagAlgorithm_value_type">Integer</span></li>
</ul>


=== cutoffConstrainSearch ===
<h3 class="parameter_description" id="cutoffConstrainSearch">cutoffConstrainSearch</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="cutoffConstrainSearch_short_desc">Constraint-independence cutoff
        threshold</span></li>
<li>Long Description: <span id="cutoffConstrainSearch_long_desc">null</span></li>
<li>Default
                Value: <span id="cutoffConstrainSearch_default_value">0.5</span></li>
<li>Lower Bound: <span id="cutoffConstrainSearch_lower_bound">0.0</span></li>
<li>Upper
                Bound: <span id="cutoffConstrainSearch_upper_bound">1.0</span></li>
<li>Value Type: <span id="cutoffConstrainSearch_value_type">Double</span></li>
</ul>


=== cutoffDataSearch ===
<h3 class="parameter_description" id="cutoffDataSearch">cutoffDataSearch</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="cutoffDataSearch_short_desc">Independence cutoff
        threshold</span></li>
<li>Long Description: <span id="cutoffDataSearch_long_desc">null</span></li>
<li>Default Value:
                <span id="cutoffDataSearch_default_value">0.5</span></li>
<li>Lower
                Bound: <span id="cutoffDataSearch_lower_bound">0.0</span></li>
<li>Upper Bound: <span id="cutoffDataSearch_upper_bound">1.0</span></li>
<li>Value Type:
                <span id="cutoffDataSearch_value_type">Double</span></li>
</ul>


=== cutoffIndTest ===
<h3 class="parameter_description" id="cutoffIndTest">cutoffIndTest</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="cutoffIndTest_short_desc">Independence cutoff
        threshold</span></li>
<li>Long Description: <span id="cutoffIndTest_long_desc">null</span></li>
<li>Default Value:
                <span id="cutoffIndTest_default_value">0.5</span></li>
<li>Lower
                Bound: <span id="cutoffIndTest_lower_bound">0.0</span></li>
<li>Upper
                Bound: <span id="cutoffIndTest_upper_bound">1.0</span></li>
<li>Value
                Type: <span id="cutoffIndTest_value_type">Double</span></li>
</ul>


=== cyclicCoefHigh ===
<h3 class="parameter_description" id="cyclicCoefHigh">cyclicCoefHigh</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="cyclicCoefHigh_short_desc">
                    Cyclic: High end of coefficient range for coefficients in cycles
        </span></li>
<li>Long Description: <span id="cyclicCoefHigh_long_desc">
        			Cyclic: Higb end of coefficient range for coefficients in cycles
        </span></li>
<li>Default Value: <span id="cyclicCoefHigh_default_value">1.0</span></li>
<li>Lower Bound: <span id="cyclicCoefHigh_lower_bound">0.0</span></li>
<li>Upper Bound: <span id="cyclicCoefHigh_upper_bound">1.7976931348623157E308</span></li>
<li>Value
                Type: <span id="cyclicCoefHigh_value_type">Double</span></li>
</ul>


=== cyclicCoefLow ===
<h3 class="parameter_description" id="cyclicCoefLow">cyclicCoefLow</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="cyclicCoefLow_short_desc">
                    Cyclic: Low end of coefficient range for coefficients in cycles
        </span></li>
<li>Long Description: <span id="cyclicCoefLow_long_desc">
        			Cyclic: Low end of coefficient range for coefficients in cycles
        </span></li>
<li>Default Value: <span id="cyclicCoefLow_default_value">0.2</span></li>
<li>Lower Bound: <span id="cyclicCoefLow_lower_bound">0.0</span></li>
<li>Upper Bound: <span id="cyclicCoefLow_upper_bound">1.7976931348623157E308</span></li>
<li>Value
                Type: <span id="cyclicCoefLow_value_type">Double</span></li>
</ul>


=== cyclicCoefStyle ===
<h3 class="parameter_description" id="cyclicCoefStyle">cyclicCoefStyle</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="cyclicCoefStyle_short_desc">
            Cyclic: 0 = Auto 1 = Fix Radius 2 = Cap Products, 3 = None,
        </span></li>
<li>Long Description: <span id="cyclicCoefStyle_long_desc">
                Cyclic: 0 = Choose for Me 1 = Scale SCCs to cyclic radius 2 = Cap cyclic products in SCCs,
                3 = Regular SEM initialization
        </span></li>
<li>Default Value: <span id="cyclicCoefStyle_default_value">0</span></li>
<li>Lower Bound: <span id="cyclicCoefStyle_lower_bound">0</span></li>
<li>Upper Bound: <span id="cyclicCoefStyle_upper_bound">3</span></li>
<li>Value
                Type: <span id="cyclicCoefStyle_value_type">Integer</span></li>
</ul>


=== cyclicMaxProd ===
<h3 class="parameter_description" id="cyclicMaxProd">cyclicMaxProd</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="cyclicMaxProd_short_desc">
                    Cyclic: Upper bound on product of coefficients around feedback loops.
        </span></li>
<li>Long Description: <span id="cyclicMaxProd_long_desc">
        			Cyclic: Upper bound on product of coefficients around feedback loops.
        </span></li>
<li>Default Value: <span id="cyclicMaxProd_default_value">0.5</span></li>
<li>Lower Bound: <span id="cyclicMaxProd_lower_bound">0.0</span></li>
<li>Upper Bound: <span id="cyclicMaxProd_upper_bound">1.7976931348623157E308</span></li>
<li>Value
                Type: <span id="cyclicMaxProd_value_type">Double</span></li>
</ul>


=== cyclicRadius ===
<h3 class="parameter_description" id="cyclicRadius">cyclicRadius</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="cyclicRadius_short_desc">
                    Cyclic: Target spectral radius used to stabilize cyclic feedback.
        </span></li>
<li>Long Description: <span id="cyclicRadius_long_desc">
        			Cyclic: Target spectral radius used to stabilize cyclic feedback.
        </span></li>
<li>Default Value: <span id="cyclicRadius_default_value">0.6</span></li>
<li>Lower Bound: <span id="cyclicRadius_lower_bound">0</span></li>
<li>Upper Bound: <span id="cyclicRadius_upper_bound">1</span></li>
<li>Value
                Type: <span id="cyclicRadius_value_type">Double</span></li>
</ul>


=== dataType ===
<h3 class="parameter_description" id="dataType">dataType</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="dataType_short_desc">"continuous" or "discrete"</span></li>
<li>Long Description: <span id="dataType_long_desc"> For a mixed data
        type simulation, if this is set to “continuous” or “discrete”, all
        variables are taken to be of that sort. This is used as a
        double-check to make sure the percent discrete is set
        appropriately.</span></li>
<li>Default Value: <span id="dataType_default_value">categorical</span></li>
<li>Lower Bound:
                <span id="dataType_lower_bound"></span></li>
<li>Upper Bound: <span id="dataType_upper_bound"></span></li>
<li>Value Type: <span id="dataType_value_type">String</span></li>
</ul>


=== depth ===
<h3 class="parameter_description" id="depth">depth</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="depth_short_desc">Maximum size of conditioning set ('depth', unlimited =-1)
            </span></li>
<li>Long Description: <span id="depth_long_desc">
        The depth of search for algorithms like the PC adjacency search,
        which is the maximum size of any conditioning set considered. In
        order to express that no limit should be imposed, use the value
        -1.</span></li>
<li>Default Value: <span id="depth_default_value">-1</span></li>
<li>Lower Bound: <span id="depth_lower_bound">-1</span></li>
<li>Upper Bound: <span id="depth_upper_bound">2147483647</span></li>
<li>Value Type: <span id="depth_value_type">Integer</span></li>
</ul>


=== determinismThreshold ===
<h3 class="parameter_description" id="determinismThreshold">determinismThreshold</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="determinismThreshold_short_desc"> Threshold for judging a
        regression of a variable onto its parents to be deterministic (min =
        0.0)</span></li>
<li>Long Description: <span id="determinismThreshold_long_desc"> When regressing a child variable
        onto a set of parent variables, one way to test for determinism is to
        test how close to singular the data is; this gives a threshold for
        this. The default value is 0.1.</span></li>
<li>Default Value: <span id="determinismThreshold_default_value">0.1</span></li>
<li>Lower
                Bound: <span id="determinismThreshold_lower_bound">0.0</span></li>
<li>Upper Bound: <span id="determinismThreshold_upper_bound">Infinity</span></li>
<li>Value
                Type: <span id="determinismThreshold_value_type">Double</span></li>
</ul>


=== differentGraphs ===
<h3 class="parameter_description" id="differentGraphs">differentGraphs</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="differentGraphs_short_desc">Yes if a different graph should be
        used for each run</span></li>
<li>Long Description: <span id="differentGraphs_long_desc"> If ‘Yes’ a new random graph is chosen
        for each run; if ‘No’, the same graph is always used.</span></li>
<li>Default Value: <span id="differentGraphs_default_value">false</span></li>
<li>Lower Bound:
                <span id="differentGraphs_lower_bound"></span></li>
<li>Upper Bound:
                <span id="differentGraphs_upper_bound"></span></li>
<li>Value Type:
                <span id="differentGraphs_value_type">Boolean</span></li>
</ul>


=== discretize ===
<h3 class="parameter_description" id="discretize">discretize</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="discretize_short_desc">Yes if continuous variables should be
        discretized when child is discrete</span></li>
<li>Long Description:
                <span id="discretize_long_desc"> Yes if for the conditional Gaussian
        likelihood, when scoring X-&gt;D where X is continuous and D discrete,
        one should to simply discretize X for just those cases. If no, the
        integration will be exact.</span></li>
<li>Default Value: <span id="discretize_default_value">true</span></li>
<li>Lower Bound: <span id="discretize_lower_bound"></span></li>
<li>Upper Bound: <span id="discretize_upper_bound"></span></li>
<li>Value Type: <span id="discretize_value_type">Boolean</span></li>
</ul>


=== doColliderOrientation ===
<h3 class="parameter_description" id="doColliderOrientation">doColliderOrientation</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="doColliderOrientation_short_desc">Yes if unshielded collider
        orientation should be done</span></li>
<li>Long Description: <span id="doColliderOrientation_long_desc"> Please see the description of
        this algorithm in Thomas Richardson and Peter Spirtes in Chapter 7 of
        Computation, Causation, &amp; Discovery by Glymour and Cooper eds.</span>
</li>
<li>Default Value: <span id="doColliderOrientation_default_value">true</span></li>
<li>Lower
                Bound: <span id="doColliderOrientation_lower_bound"></span></li>
<li>Upper Bound: <span id="doColliderOrientation_upper_bound"></span></li>
<li>Value Type:
                <span id="doColliderOrientation_value_type">Boolean</span></li>
</ul>


=== doFgesFirst ===
<h3 class="parameter_description" id="doFgesFirst">doFgesFirst</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="doFgesFirst_short_desc"> Yes if FGES should be done as an initial
        step</span></li>
<li>Long Description: <span id="doFgesFirst_long_desc"> For BOSS, for some cases, doing FGES as
        an initial step can reduce the maximum permutation size needed to
        solve a problem. </span></li>
<li>Default Value: <span id="doFgesFirst_default_value">false</span></li>
<li>Lower Bound:
                <span id="doFgesFirst_lower_bound"></span></li>
<li>Upper Bound:
                <span id="doFgesFirst_upper_bound"></span></li>
<li>Value Type: <span id="doFgesFirst_value_type">Boolean</span></li>
</ul>


=== doOneEquationOnly ===
<h3 class="parameter_description" id="doOneEquationOnly">doOneEquationOnly</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="doOneEquationOnly_short_desc">
                    True if only one equation should be used when expanding the basis
                    </span>
</li>
<li>Long Description: <span id="doOneEquationOnly_long_desc">
                    True if only one equation should be used when expanding the basis
                    </span>
</li>
<li>Default Value: <span id="doOneEquationOnly_default_value">false</span></li>
<li>Lower
                Bound: <span id="doOneEquationOnly_lower_bound"></span></li>
<li>Upper Bound: <span id="doOneEquationOnly_upper_bound"></span></li>
<li>Value Type:
                <span id="doOneEquationOnly_value_type">Boolean</span></li>
</ul>


=== doPossibleDsep ===
<h3 class="parameter_description" id="doPossibleDsep">doPossibleDsep</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="doPossibleDsep_short_desc">Yes if the possible d-sep search
        should be done</span></li>
<li>Long Description: <span id="doPossibleDsep_long_desc"> This algorithm has a possible d-sep
        path search, which can be time-consuming. See Spirtes, Glymour, and
        Scheines (2000) for details.</span></li>
<li>Default Value: <span id="doPossibleDsep_default_value">true</span></li>
<li>Lower Bound:
                <span id="doPossibleDsep_lower_bound"></span></li>
<li>Upper Bound:
                <span id="doPossibleDsep_upper_bound"></span></li>
<li>Value Type:
                <span id="doPossibleDsep_value_type">Boolean</span></li>
</ul>


=== ebicGamma ===
<h3 class="parameter_description" id="ebicGamma">ebicGamma</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="ebicGamma_short_desc">EBIC Gamma (0-1)</span></li>
<li>Long
                Description: <span id="ebicGamma_long_desc">The gamma parameter for
        Extended BIC (Chen and Chen). In [0, 1].</span></li>
<li>Default
                Value: <span id="ebicGamma_default_value">0.8</span></li>
<li>Lower
                Bound: <span id="ebicGamma_lower_bound">0.0</span></li>
<li>Upper
                Bound: <span id="ebicGamma_upper_bound">1.0</span></li>
<li>Value
                Type: <span id="ebicGamma_value_type">Double</span></li>
</ul>


=== effectiveSampleSize ===
<h3 class="parameter_description" id="effectiveSampleSize">effectiveSampleSize</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="effectiveSampleSize_short_desc">
                    The effective sample size, or -1 if the true sample size is to be used.
                    </span></li>
<li>Long Description: <span id="effectiveSampleSize_long_desc">
                    The effective sample size, or -1 is the true sample size is to be used.
        </span></li>
<li>Default Value: <span id="effectiveSampleSize_default_value">-1</span></li>
<li>Lower Bound: <span id="effectiveSampleSize_lower_bound">-1</span></li>
<li>Upper Bound: <span id="effectiveSampleSize_upper_bound">2147483647</span></li>
<li>Value Type: <span id="effectiveSampleSize_value_type">Integer</span></li>
</ul>


=== errorsNormal ===
<h3 class="parameter_description" id="errorsNormal">errorsNormal</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="errorsNormal_short_desc">Yes if errors should be Normal; No if
        they should be abs(Normal) (i.e., non-Gaussian)</span></li>
<li>Long
                Description: <span id="errorsNormal_long_desc"> A “quick and dirty”
        way to generate linear, non-Gaussian data is to set this parameter to
        “No”; then the errors will be sampled from a Beta
        distribution.</span></li>
<li>Default Value: <span id="errorsNormal_default_value">true</span></li>
<li>Lower Bound:
                <span id="errorsNormal_lower_bound"></span></li>
<li>Upper Bound:
                <span id="errorsNormal_upper_bound"></span></li>
<li>Value Type:
                <span id="errorsNormal_value_type">Boolean</span></li>
</ul>


=== errorThreshold ===
<h3 class="parameter_description" id="thresholdAlpha">errorThreshold</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="thresholdAlpha_short_desc">Error Threshold</span></li>
<li>Long
                Description: <span id="thresholdAlpha_long_desc"> Adjusts the
        threshold for judging conditional dependence.</span></li>
<li>Default Value: <span id="thresholdAlpha_default_value">0.5</span></li>
<li>Lower Bound:
                <span id="thresholdAlpha_lower_bound">0.0</span></li>
<li>Upper
                Bound: <span id="thresholdAlpha_upper_bound">1</span></li>
<li>Value
                Type: <span id="thresholdAlpha_value_type">Double</span></li>
</ul>


=== ess ===
<h3 class="parameter_description" id="ess">ess</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="ess_short_desc">Yes if the equivalent sample size should be used
        in place of N</span></li>
<li>Long Description: <span id="ess_long_desc"> We calculate the equivalent sample size by
        assuming that all record are equally correlated</span></li>
<li>Default Value: <span id="ess_default_value">false</span></li>
<li>Lower Bound: <span id="ess_lower_bound"></span></li>
<li>Upper
                Bound: <span id="ess_upper_bound"></span></li>
<li>Value Type: <span id="ess_value_type">Boolean</span></li>
</ul>


=== extraEdgeRemovalStep ===
<h3 class="parameter_description" id="extraEdgeRemovalStep">extraEdgeRemovalStep</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="extraEdgeRemovalStep_short_desc">
                    The extra edge removal step to use: 1 = LV_LITE, 2 = Greedy, 3 = Max P, 4 = Min P
        </span></li>
<li>Long Description: <span id="extraEdgeRemovalStep_long_desc">
                    The extra edge removal step to use: 1 = LV_LITE, 2 = Greedy, 3 = Max P, 4 = Min P
        </span></li>
<li>Default Value: <span id="extraEdgeRemovalStep_default_value">1</span></li>
<li>Lower Bound: <span id="extraEdgeRemovalStep_lower_bound">1</span></li>
<li>Upper
                Bound: <span id="extraEdgeRemovalStep_upper_bound">4</span></li>
<li>Value
                Type: <span id="extraEdgeRemovalStep_value_type">Integer</span></li>
</ul>


=== faithfulnessAssumed ===
<h3 class="parameter_description" id="faithfulnessAssumed">faithfulnessAssumed</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="faithfulnessAssumed_short_desc">Yes if (one edge) faithfulness
        should be assumed</span></li>
<li>Long Description: <span id="faithfulnessAssumed_long_desc"> Assumes that if X _||_ Y, by an
        independence test, then X _||_ Y | Z for nonempty Z.</span></li>
<li>Default Value: <span id="faithfulnessAssumed_default_value">false</span></li>
<li>Lower
                Bound: <span id="faithfulnessAssumed_lower_bound"></span></li>
<li>Upper Bound: <span id="faithfulnessAssumed_upper_bound"></span></li>
<li>Value Type:
                <span id="faithfulnessAssumed_value_type">Boolean</span></li>
</ul>


=== faskAdjacencyMethod ===
<h3 class="parameter_description" id="faskAdjacencyMethod">faskAdjacencyMethod</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="faskAdjacencyMethod_short_desc">Non-skewness Adjacencies: 1 = FAS
        Stable, 2 = FGES, 3 = External Graph, 4 = None</span></li>
<li>Long
                Description: <span id="faskAdjacencyMethod_long_desc"> This is  the
        method FASK will use to find non-skewness adjacencies. For External
        graph, an external graph must be supplied.</span></li>
<li>Default
                Value: <span id="faskAdjacencyMethod_default_value">1</span></li>
<li>Lower Bound: <span id="faskAdjacencyMethod_lower_bound">1</span></li>
<li>Upper Bound:
                <span id="faskAdjacencyMethod_upper_bound">4</span></li>
<li>Value
                Type: <span id="faskAdjacencyMethod_value_type">Integer</span></li>
</ul>


=== faskAssumeLinearity ===
<h3 class="parameter_description" id="faskAssumeLinearity">faskAssumeLinearity</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="faskAssumeLinearity_short_desc">Linearity assumed</span></li>
<li>Long Description: <span id="faskAssumeLinearity_long_desc"> True
        if a linear, non-Gaussian, additive model is assume; false if a
        nonlinear, non-Gaussian, additive model is assumed.</span></li>
<li>Default Value: <span id="faskAssumeLinearity_default_value">true</span></li>
<li>Lower
                Bound: <span id="faskAssumeLinearity_lower_bound"></span></li>
<li>Upper Bound: <span id="faskAssumeLinearity_upper_bound"></span></li>
<li>Value Type:
                <span id="faskAssumeLinearity_value_type">Boolean</span></li>
</ul>


=== faskDelta ===
<h3 class="parameter_description" id="faskDelta">faskDelta</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="faskDelta_short_desc"> For FASK v1, the bias for orienting
        with negative coefficients ('0' means no bias.)</span></li>
<li>Long Description: <span id="faskDelta_long_desc">The bias procedure for v1
        is given in the published description.</span></li>
<li>Default
                Value: <span id="faskDelta_default_value">0.0</span></li>
<li>Lower
                Bound: <span id="faskDelta_lower_bound">-Infinity</span></li>
<li>Upper Bound: <span id="faskDelta_upper_bound">Infinity</span></li>
<li>Value Type: <span id="faskDelta_value_type">Double</span></li>
</ul>


=== faskLeftRightRule ===
<h3 class="parameter_description" id="faskLeftRightRule">faskLeftRightRule</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="faskLeftRightRule_short_desc">The left right rule: 1 = FASK v1, 2
        = FASK v2, 3 = RSkew, 4 = Skew, 5 = Tanh</span></li>
<li>Long
                Description: <span id="faskLeftRightRule_long_desc"> The FASK left
        right rule v2 is default, but two other (related) left-right rules
        are given for relation to the literature, and the v1 FASK rule is
        included for backward compatibility.</span></li>
<li>Default Value:
                <span id="faskLeftRightRule_default_value">3</span></li>
<li>Lower
                Bound: <span id="faskLeftRightRule_lower_bound">1</span></li>
<li>Upper Bound: <span id="faskLeftRightRule_upper_bound">5</span></li>
<li>Value Type:
                <span id="faskLeftRightRule_value_type">Integer</span></li>
</ul>


=== faskNonempirical ===
<h3 class="parameter_description" id="faskNonempirical">faskNonempirical</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="faskNonempirical_short_desc">Variables should be assumed to have
        positive skewness</span></li>
<li>Long Description: <span id="faskNonempirical_long_desc"> If false (default), each variable is
        multiplied by the sign of its skewness in the left-right rule.</span>
</li>
<li>Default Value: <span id="faskNonempirical_default_value">false</span></li>
<li>Lower
                Bound: <span id="faskNonempirical_lower_bound"></span></li>
<li>Upper
                Bound: <span id="faskNonempirical_upper_bound"></span></li>
<li>Value
                Type: <span id="faskNonempirical_value_type">Boolean</span></li>
</ul>


=== fasRule ===
<h3 class="parameter_description" id="fasRule">fasRule</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="fasRule_short_desc">Adjacency search: 1 = PC, 2 = PC-Stable, 3 =f
        Concurrent PC-Stable</span></li>
<li>Long Description: <span id="fasRule_long_desc"> For variants of PC, one may select either to
        use the usual PC adjacency search, or the procedure from the
        PC-Stable algorithm (Diego and Maathuis), or the latter using a
        concurrent algorithm.</span></li>
<li>Default Value: <span id="fasRule_default_value">1</span></li>
<li>Lower Bound: <span id="fasRule_lower_bound">1</span></li>
<li>Upper Bound: <span id="fasRule_upper_bound">3</span></li>
<li>Value Type: <span id="fasRule_value_type">Integer</span></li>
</ul>


=== fastIcaA ===
<h3 class="parameter_description" id="fastIcaA">fastIcaA</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="fastIcaA_short_desc">Fast ICA 'a' parameter. </span></li>
<li>Long Description: <span id="fastIcaA_long_desc"> This is the 'a'
        parameter of Fast ICA. (See Hyvarinen, A. (2001); it ranges between 1
        and 2; we use a default of 1.1.</span></li>
<li>Default Value: <span id="fastIcaA_default_value">1.1</span></li>
<li>Lower Bound: <span id="fastIcaA_lower_bound">1.0</span></li>
<li>Upper Bound: <span id="fastIcaA_upper_bound">2.0</span></li>
<li>Value Type: <span id="fastIcaA_value_type">Double</span></li>
</ul>


=== fastIcaMaxIter ===
<h3 class="parameter_description" id="fastIcaMaxIter">fastIcaMaxIter</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="fastIcaMaxIter_short_desc">The maximum number of optimization
        iterations. </span></li>
<li>Long Description: <span id="fastIcaMaxIter_long_desc"> This is the maximum number if
        iterations of the optimization procedure of ICA. (See Hyvarinen, A.
        (2001). It's an integer greater than 0; we use a default of
        2000.</span></li>
<li>Default Value: <span id="fastIcaMaxIter_default_value">2000</span></li>
<li>Lower Bound:
                <span id="fastIcaMaxIter_lower_bound">1</span></li>
<li>Upper Bound:
                <span id="fastIcaMaxIter_upper_bound">500000</span></li>
<li>Value
                Type: <span id="fastIcaMaxIter_value_type">Double</span></li>
</ul>


=== fastIcaTolerance ===
<h3 class="parameter_description" id="fastIcaTolerance">fastIcaTolerance</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="fastIcaTolerance_short_desc">Fast ICA tolerance parameter.
        </span></li>
<li>Long Description: <span id="fastIcaTolerance_long_desc"> This is the tolerance parameter of
        Fast ICA. (See Hyvarinen, A. (2001); we use a default of 1e-6.</span>
</li>
<li>Default Value: <span id="fastIcaTolerance_default_value">1e-6</span></li>
<li>Lower Bound:
                <span id="fastIcaTolerance_lower_bound">0.0</span></li>
<li>Upper
                Bound: <span id="fastIcaTolerance_upper_bound">1000.0</span></li>
<li>Value Type: <span id="fastIcaTolerance_value_type">Double</span></li>
</ul>


=== fcitStartsWith ===
<h3 class="parameter_description" id="fcitStartsWith">fcitStartsWith</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="fcitStartsWith_short_desc">
                    The algorithm to find the initial CPDAG: 1 = BOSS, 2 = GRaSP, 3 = SP
        </span></li>
<li>Long Description: <span id="fcitStartsWith_long_desc">
                    The algorithm to find the initial CPDAG: 1 = BOSS, 2 = GRaSP, 3 = SP
        </span></li>
<li>Default Value: <span id="fcitStartsWith_default_value">1</span></li>
<li>Lower Bound: <span id="fcitStartsWith_lower_bound">1</span></li>
<li>Upper
                Bound: <span id="fcitStartsWith_upper_bound">3</span></li>
<li>Value
                Type: <span id="fcitStartsWith_value_type">Integer</span></li>
</ul>


=== fdrQ ===
<h3 class="parameter_description" id="fdrQ">fdrQ</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="fdrQ_short_desc">
                    FDR q value, often 0.01 - 0.1, or 0 if FDR should not be done.
        </span></li>
<li>Long Description: <span id="fdrQ_long_desc">
                    FDR q value, often 0.01 - 0.1, or 0 if FDR should not be done.
         </span></li>
<li>Default Value: <span id="fdrQ_default_value">0</span></li>
<li>Lower Bound: <span id="fdrQ_lower_bound">0</span></li>
<li>Upper
                Bound: <span id="fdrQ_upper_bound">1</span></li>
<li>Value
                Type: <span id="fdrQ_value_type">Double</span></li>
</ul>


=== fileOutPath ===
<h3 class="parameter_description" id="fileOutPath">fileOutPath</h3>
<ul class="fileOutPath_list">
<li>Short Description: <span id="fileOutPath_short_desc">Results output path</span></li>
<li>Long Description: <span id="fileOutPath_long_desc">Path to a directory in which results can be stored</span>
</li>
<li>Default Value: <span id="fileOutPath_default_value">cstar-out</span></li>
<li>Lower Bound: <span id="fileOutPath_lower_bound"></span></li>
<li>Upper Bound: <span id="fileOutPath_upper_bound"></span></li>
<li>Value Type: <span id="fileOutPath_value_type">String</span></li>
</ul>


=== fisherEpsilon ===
<h3 class="parameter_description" id="fisherEpsilon">fisherEpsilon</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="fisherEpsilon_short_desc">Epsilon where |xi.t - xi.t-1| &lt;
        epsilon, criterion for convergence</span></li>
<li>Long Description:
                <span id="fisherEpsilon_long_desc"> This is a parameter for the
        linear Fisher option. The idea of Fisher model (for the linear case)
        is to shock the system every so often and let it converge by applying
        the rules of transformation (that is, the linear model) repeatedly
        until convergence.</span></li>
<li>Default Value: <span id="fisherEpsilon_default_value">0.001</span></li>
<li>Lower Bound:
                <span id="fisherEpsilon_lower_bound">4.9E-324</span></li>
<li>Upper
                Bound: <span id="fisherEpsilon_upper_bound">1.7976931348623157E308</span></li>
<li>Value Type: <span id="fisherEpsilon_value_type">Double</span></li>
</ul>


=== fofcAlpha ===
<h3 class="parameter_description" id="fofcAlpha">fofcAlpha</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="fofcAlpha_short_desc">Cutoff for p values (alpha) (min =
        0.0)</span></li>
<li>Long Description: <span id="fofcAlpha_long_desc">Alpha level (0 to 1)</span></li>
<li>Default Value: <span id="fofcAlpha_default_value">0.001</span></li>
<li>Lower Bound:
                <span id="fofcAlpha_lower_bound">0.0</span></li>
<li>Upper Bound:
                <span id="fofcAlpha_upper_bound">1.0</span></li>
<li>Value Type:
                <span id="fofcAlpha_value_type">Double</span></li>
</ul>


=== generalSemErrorTemplate ===
<h3 class="parameter_description" id="generalSemErrorTemplate">generalSemErrorTemplate</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="generalSemErrorTemplate_short_desc">General function for error
        terms</span></li>
<li>Long Description: <span id="generalSemErrorTemplate_long_desc"> This template specifies how
        distributions for error terms are to be generated. For help in
        constructing such templates, see the Generalized SEM PM model.</span>
</li>
<li>Default Value: <span id="generalSemErrorTemplate_default_value">Beta(2, 5)</span></li>
<li>Lower Bound: <span id="generalSemErrorTemplate_lower_bound"></span></li>
<li>Upper
                Bound: <span id="generalSemErrorTemplate_upper_bound"></span></li>
<li>Value Type: <span id="generalSemErrorTemplate_value_type">String</span></li>
</ul>


=== generalSemFunctionTemplateLatent ===
<h3 class="parameter_description" id="generalSemFunctionTemplateLatent">
            generalSemFunctionTemplateLatent</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="generalSemFunctionTemplateLatent_short_desc">General function
        template for latent variables</span></li>
<li>Long Description:
                <span id="generalSemFunctionTemplateLatent_long_desc"> This template
        specifies how equations for latent variables are to be generated. For
        help in constructing such templates, see the Generalized SEM PM
        model.</span>
</li>
<li>Default Value:

                <span id="generalSemFunctionTemplateLatent_default_value">TSUM(NEW(B)*$)/&gt;
        </span></li>
<li>Lower Bound: <span id="generalSemFunctionTemplateLatent_lower_bound"></span></li>
<li>Upper Bound: <span id="generalSemFunctionTemplateLatent_upper_bound"></span></li>
<li>Value Type: <span id="generalSemFunctionTemplateLatent_value_type">String</span></li>
</ul>


=== generalSemFunctionTemplateMeasured ===
<h3 class="parameter_description" id="generalSemFunctionTemplateMeasured">
            generalSemFunctionTemplateMeasured</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="generalSemFunctionTemplateMeasured_short_desc">General function
        template for measured variables</span></li>
<li>Long Description:
                <span id="generalSemFunctionTemplateMeasured_long_desc"> This
        template specifies how equations for measured variables are to be
        generated. For help in constructing such templates, see the
        Generalized SEM PM model.</span></li>
<li>Default Value: <span id="generalSemFunctionTemplateMeasured_default_value">TSUM(NEW(B)*$&gt;
            </span></li>
<li>Lower Bound: <span id="generalSemFunctionTemplateMeasured_lower_bound"></span></li>
<li>Upper Bound: <span id="generalSemFunctionTemplateMeasured_upper_bound"></span></li>
<li>Value Type: <span id="generalSemFunctionTemplateMeasured_value_type">String</span></li>
</ul>


=== generalSemParameterTemplate ===
<h3 class="parameter_description" id="generalSemParameterTemplate">generalSemParameterTemplate</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="generalSemParameterTemplate_short_desc">General function for
        parameters</span></li>
<li>Long Description: <span id="generalSemParameterTemplate_long_desc"> This template specifies
        how distributions for parameter terms are to be generated. For help
        in constructing such templates, see the Generalized SEM PM
        model.</span></li>
<li>Default Value: <span id="generalSemParameterTemplate_default_value">Split(-1.0, -0.5, 0.5,
        1.0)</span></li>
<li>Lower Bound: <span id="generalSemParameterTemplate_lower_bound"></span></li>
<li>Upper
                Bound: <span id="generalSemParameterTemplate_upper_bound"></span></li>
<li>Value
                Type: <span id="generalSemParameterTemplate_value_type">String</span></li>
</ul>


=== ginBackend ===
<h3 class="parameter_description" id="ginBackend">ginBackend</h3>
<ul class="parameter_description_list">
<li>Short Description:
                <span id="ginBackend_short_desc">Backend test: 1 = dcor 2 = pearson.</span>
</li>
<li>Long Description:
                <span id="ginBackend_long_desc">
                  Choose unconditional test for residual independence: “dcor” detects
                  nonlinear relations, “pearson” is fast but linear only.
                </span>
</li>
<li>Default Value: <span id="ginBackend_default_value">1</span></li>
<li>Lower Bound: <span id="ginBackend_lower_bound">1</span></li>
<li>Upper Bound: <span id="ginBackend_upper_bound">2</span></li>
<li>Value Type: <span id="ginBackend_value_type">Integer</span></li>
</ul>


=== ginPermutations ===
<h3 class="parameter_description" id="ginPermutations">ginPermutations</h3>
<ul class="parameter_description_list">
<li>Short Description:
                <span id="ginPermutations_short_desc">Number of permutations for dCor.</span>
</li>
<li>Long Description:
                <span id="ginPermutations_long_desc">
                  Number of random shuffles used to compute p-values for dCor; higher
                  values give more reliable p-values but increase runtime; ignored if backend is pearson.
                </span>
</li>
<li>Default Value: <span id="ginPermutations_default_value">200</span></li>
<li>Lower Bound: <span id="ginPermutations_lower_bound">0</span></li>
<li>Upper Bound: <span id="ginPermutations_upper_bound">100000</span></li>
<li>Value Type: <span id="ginPermutations_value_type">Integer</span></li>
</ul>


=== ginRidge ===
<h3 class="parameter_description" id="ginRidge">ginRidge</h3>
<ul class="parameter_description_list">
<li>Short Description:
                <span id="ginRidge_short_desc">Ridge penalty for OLS regression</span>
</li>
<li>Long Description:
                <span id="ginRidge_long_desc">
                  Small positive value added to regression diagonals for numerical
                  stability when fitting residual models; larger values regularize
                  more but bias residuals.
                </span>
</li>
<li>Default Value: <span id="ginRidge_default_value">1e-8</span></li>
<li>Lower Bound: <span id="ginRidge_lower_bound">0</span></li>
<li>Upper Bound: <span id="ginRidge_upper_bound">100000</span></li>
<li>Value Type: <span id="ginRidge_value_type">Double</span></li>
</ul>


=== graspAlg ===
<h3 class="parameter_description" id="graspAlg">graspAlg</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="graspAlg_short_desc"> 1 = GRaSP1, 2 = GRaSP2, 3 = esp, 4 =
        GRaSP4, 5 = GRaSP4 </span></li>
<li>Long Description: <span id="graspAlg_long_desc"> Which version of GRaSP (temp parameter)
        </span></li>
<li>Default Value: <span id="graspAlg_default_value">1</span></li>
<li>Lower Bound: <span id="graspAlg_lower_bound">1</span></li>
<li>Upper Bound: <span id="graspAlg_upper_bound">5</span></li>
<li>Value Type: <span id="graspAlg_value_type">Integer</span></li>
</ul>


=== graspBreakAfterImprovement ===
<h3 class="parameter_description" id="graspBreakAfterImprovement">graspBreakAfterImprovement</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="graspBreakAfterImprovement_short_desc"> Yes if depth first search
        returns after first improvement, No for depth first traversal.
        </span></li>
<li>Long Description: <span id="graspBreakAfterImprovement_long_desc"> Exploring the full list in
        every DFS call is equivalent to what we've been calling the Random
        Carnival Game procedure (RCG). </span></li>
<li>Default Value: <span id="graspBreakAfterImprovement_default_value">true</span></li>
<li>Lower Bound: <span id="graspBreakAfterImprovement_lower_bound"></span></li>
<li>Upper
                Bound: <span id="graspBreakAfterImprovement_upper_bound"></span></li>
<li>Value Type: <span id="graspBreakAfterImprovement_value_type">Boolean</span></li>
</ul>


=== graspCheckCovering ===
<h3 class="parameter_description" id="graspCheckCovering">graspCheckCovering</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="graspCheckCovering_short_desc"> Yes if covering of edges should
        be checked (GASP), no if not (GRASP) </span></li>
<li>Long
                Description: <span id="graspCheckCovering_long_desc"> An edge X is
        covered if Parents(X) = Parents(Y) \ {X}. Not checking covering
        expands the search space. </span></li>
<li>Default Value: <span id="graspCheckCovering_default_value">false</span></li>
<li>Lower
                Bound: <span id="graspCheckCovering_lower_bound"></span></li>
<li>Upper Bound: <span id="graspCheckCovering_upper_bound"></span></li>
<li>Value Type:
                <span id="graspCheckCovering_value_type">Boolean</span></li>
</ul>


=== graspDepth ===
<h3 class="parameter_description" id="graspDepth">graspDepth</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="graspDepth_short_desc">Recursion depth (for GRaSP)</span></li>
<li>Long
                Description: <span id="graspDepth_long_desc"> This is the depth of
        recursion for the depth first search. </span></li>
<li>Default
                Value: <span id="graspDepth_default_value">3</span></li>
<li>Lower
                Bound: <span id="graspDepth_lower_bound">0</span></li>
<li>Upper
                Bound: <span id="graspDepth_upper_bound">2147483647</span></li>
<li>Value Type: <span id="graspDepth_value_type">Integer</span></li>
</ul>


=== graspForwardTuckOnly ===
<h3 class="parameter_description" id="graspForwardTuckOnly">graspForwardTuckOnly</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="graspForwardTuckOnly_short_desc"> Yes if only forward tucks
        should be checked, no if also reverse tucks should be checked.</span>
</li>
<li>Long Description: <span id="graspForwardTuckOnly_long_desc"> A forward tuck for X-&gt;Y moves Y
        to the before position of X in the permutation. A reverse tuck moves
        Y to after the position of X in the permutation. Including reverse
        tucks expands the search space. </span></li>
<li>Default Value:
                <span id="graspForwardTuckOnly_default_value">false</span></li>
<li>Lower Bound: <span id="graspForwardTuckOnly_lower_bound"></span></li>
<li>Upper Bound:
                <span id="graspForwardTuckOnly_upper_bound"></span></li>
<li>Value
                Type: <span id="graspForwardTuckOnly_value_type">Boolean</span></li>
</ul>


=== graspNonSingularDepth ===
<h3 class="parameter_description" id="graspNonSingularDepth">graspNonSingularDepth</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="graspNonSingularDepth_short_desc">Recursion depth for nonsingular
        tucks</span></li>
<li>Long Description: <span id="graspNonSingularDepth_long_desc"> This is the depth of recursion
        at which multiple tucks may be considered per score improvement
        </span></li>
<li>Default Value: <span id="graspNonSingularDepth_default_value">1</span></li>
<li>Lower
                Bound: <span id="graspNonSingularDepth_lower_bound">0</span></li>
<li>Upper Bound: <span id="graspNonSingularDepth_upper_bound">2147483647</span></li>
<li>Value Type: <span id="graspNonSingularDepth_value_type">Integer</span></li>
</ul>


=== graspOrderedAlg ===
<h3 class="parameter_description" id="graspOrderedAlg">graspOrderedAlg</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="graspOrderedAlg_short_desc"> Yes if earlier GRaSP stages should
        be performed before later stages </span></li>
<li>Long Description:
                <span id="graspOrderedAlg_long_desc"> GRaSP has three stages; these
        can be performed separately or in order; by default Yes. </span>
</li>
<li>Default Value: <span id="graspOrderedAlg_default_value">true</span></li>
<li>Lower Bound:
                <span id="graspOrderedAlg_lower_bound"></span></li>
<li>Upper Bound:
                <span id="graspOrderedAlg_upper_bound"></span></li>
<li>Value Type:
                <span id="graspOrderedAlg_value_type">Boolean</span></li>
</ul>


=== graspSingularDepth ===
<h3 class="parameter_description" id="graspSingularDepth">graspSingularDepth</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="graspSingularDepth_short_desc">Recursion depth for singular
        tucks</span></li>
<li>Long Description: <span id="graspSingularDepth_long_desc"> This is the depth of recursion
        for the singular tucks. </span></li>
<li>Default
                Value: <span id="graspSingularDepth_default_value">1</span></li>
<li>Lower Bound: <span id="graspSingularDepth_lower_bound">0</span></li>
<li>Upper Bound:
                <span id="graspSingularDepth_upper_bound">2147483647</span></li>
<li>Value Type: <span id="graspSingularDepth_value_type">Integer</span></li>
</ul>


=== graspToleranceDepth ===
<h3 class="parameter_description" id="graspToleranceDepth">graspToleranceDepth</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="graspToleranceDepth_short_desc">Recursion depth for tolerance
        tucks</span></li>
<li>Long Description: <span id="graspToleranceDepth_long_desc"> This is the maximum number of
        non-greedy tucks in depth first order --that is, tucks where the
        score is allowed to decrease rather than increase. </span></li>
<li>Default Value: <span id="graspToleranceDepth_default_value">0</span></li>
<li>Lower Bound:
                <span id="graspToleranceDepth_lower_bound">0</span></li>
<li>Upper
                Bound: <span id="graspToleranceDepth_upper_bound">2147483647</span></li>
<li>Value
                Type: <span id="graspToleranceDepth_value_type">Integer</span></li>
</ul>


=== graspUseRaskuttiUhler ===
<h3 class="parameter_description" id="graspUseRaskuttiUhler">graspUseRaskuttiUhler</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="graspUseRaskuttiUhler_short_desc"> Yes to use Raskutti and Uhler's
        DAG-building method (test), No to use Grow-Shrink (score).</span>
</li>
<li>Long Description: <span id="graspUseRaskuttiUhler_long_desc">
        Raskutti and Uhler's method adds and edge X-&gt;Y if Y ~_||_ X |
        Prefix(Y, pi) \ {X}. Grow-Shrink adds an edge X-&gt;Y if X is in the
        Markov blanket of Y where the variable set is restricted to Prefix(Y,
        pi). </span></li>
<li>Default Value: <span id="graspUseRaskuttiUhler_default_value">false</span></li>
<li>Lower
                Bound: <span id="graspUseRaskuttiUhler_lower_bound"></span></li>
<li>Upper Bound: <span id="graspUseRaskuttiUhler_upper_bound"></span></li>
<li>Value Type:
                <span id="graspUseRaskuttiUhler_value_type">Boolean</span></li>
</ul>


=== graspUseScore ===
<h3 class="parameter_description" id="graspUseScore">graspUseScore</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="graspUseScore_short_desc"> Yes if the score should be used for MB
        calculations, no if the test should be used instead. </span></li>
<li>Long Description: <span id="graspUseScore_long_desc"> In either
        case, compositional graphoid axioms are assumed by the Grow-Shrink
        algorithm. </span></li>
<li>Default Value: <span id="graspUseScore_default_value">true</span></li>
<li>Lower Bound:
                <span id="graspUseScore_lower_bound"></span></li>
<li>Upper Bound:
                <span id="graspUseScore_upper_bound"></span></li>
<li>Value Type:
                <span id="graspUseScore_value_type">Boolean</span></li>
</ul>


=== graspUseVpScoring ===
<h3 class="parameter_description" id="graspUseVpScoring">graspUseVpScoring</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="graspUseVpScoring_short_desc"> No sure </span></li>
<li>Long
                Description: <span id="graspUseVpScoring_long_desc"> Not sure </span>
</li>
<li>Default Value: <span id="graspUseVpScoring_default_value">false</span></li>
<li>Lower
                Bound: <span id="graspUseVpScoring_lower_bound"></span></li>
<li>Upper Bound: <span id="graspUseVpScoring_upper_bound"></span></li>
<li>Value Type: <span id="graspUseVpScoring_value_type">Boolean</span></li>
</ul>


=== guaranteeAcyclic ===
<h3 class="parameter_description" id="guaranteeAcyclic">guaranteeAcyclic</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="guaranteeAcyclic_short_desc">True if the output should be
                    guaranteed to be acyclic
        </span></li>
<li>Long Description: <span id="guaranteeAcyclic_long_desc">The estimated B matrix
                    is further thresholded by setting small coefficients to zero
                    until an acyclic model is produced.</span>
</li>
<li>Default Value: <span id="guaranteeAcyclic_default_value">true</span></li>
<li>Lower Bound:
                <span id="guaranteeAcyclic_lower_bound"></span></li>
<li>Upper
                Bound: <span id="guaranteeAcyclic_upper_bound"></span></li>
<li>Value Type: <span id="guaranteeAcyclic_value_type">Boolean</span></li>
</ul>


=== guaranteeCpdag ===
<h3 class="parameter_description" id="guaranteeCpdag">guaranteeCpdag</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="guaranteeCpdag_short_desc">
                    Guarantee that the output is a legal CPDAG</span></li>
<li>Long Description: <span id="guaranteeCpdag_long_desc">
            	It is possible due to unfaithfulness for the Meek rules to output a
            	non-CPDAG; this parameter guarantees a CPDAG if set to 'Yes'.
            	</span></li>
<li>Default Value: <span id="guaranteeCpdag_default_value">true</span></li>
<li>Lower Bound: <span id="guaranteeCpdag_lower_bound"></span></li>
<li>Upper Bound: <span id="guaranteeCpdag_upper_bound"></span></li>
<li>Value Type: <span id="guaranteeCpdag_value_type">Boolean</span></li>
</ul>


=== guaranteeIid ===
<h3 class="parameter_description" id="guaranteeIid">guaranteeIid</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="guaranteeIid_short_desc">Recursive simulation is used for acyclic models; if not should i.i.d. be assumed?</span>
</li>
<li>Long Description:
                <span id="guaranteeIid_long_desc">For cyclic models, the Fisher simulation model is used, which is a time series. Selecting 'Yes' here
        guarantees that a new data point starts from a new shock without influence from the previous time step.</span>
</li>
<li>Default Value:
                <span id="guaranteeIid_default_value">true</span></li>
<li>Lower
                Bound: <span id="guaranteeIid_lower_bound"></span></li>
<li>Upper
                Bound: <span id="guaranteeIid_upper_bound"></span></li>
<li>Value
                Type: <span id="guaranteeIid_value_type">Boolean</span></li>
</ul>


=== guaranteePag ===
<h3 class="parameter_description" id="guaranteePag">guaranteePag</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="guaranteePag_short_desc">
                    Ensure the output is a legal PAG (where feasible)
        </span></li>
<li>Long Description: <span id="guaranteePag_long_desc">
                    Repairs errors in PAGs due to almost cyclic paths or non-maximalities.
                    This comes with a certain risk; errors in PAGs indicate that the PAG
                    assumptions were not met; the user may wish to consider why before
                    selecting this <option class="" value=""></option>
</span></li>
<li>Default Value: <span id="guaranteePag_default_value">false</span></li>
<li>Lower Bound: <span id="guaranteePag_lower_bound"></span></li>
<li>Upper
                Bound: <span id="guaranteePag_upper_bound"></span></li>
<li>Value
                Type: <span id="guaranteePag_value_type">Boolean</span></li>
</ul>


=== henckelPruning ===
<h3 class="parameter_description" id="henckelPruning">henckelPruning</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="henckelPruning_short_desc">
                Whether to do Henckel et al. (2020) Algorithm 1 pruning.
        	</span></li>
<li>Long
                Description: <span id="henckelPruning_long_desc">
                Whether to do Henckel et al. (2020) Algorithm 1 pruning.
        </span></li>
<li>Default Value:
                <span id="henckelPruning_default_value">False</span></li>
<li>Lower
                Bound: <span id="henckelPruning_lower_bound"></span></li>
<li>Upper Bound: <span id="henckelPruning_upper_bound"></span></li>
<li>Value Type:
                <span id="henckelPruning_value_type">Boolean</span></li>
</ul>


=== hiddenDimension ===
<h3 class="parameter_description" id="hiddenDimension">hiddenDimension</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="hiddenDimension_short_desc">
                For Nonlinear Additive Model, the number of nodes per edge
            </span></li>
<li>Long Description: <span id="hiddenDimension_long_desc">
                For a shallow multilayer perception (MLP), the number of nodes in the hidden layer
        </span></li>
<li>Default
                Value: <span id="hiddenDimension_default_value">10</span></li>
<li>Lower Bound: <span id="hiddenDimension_lower_bound">1</span></li>
<li>Upper
                Bound: <span id="hiddenDimension_upper_bound">500000</span></li>
<li>Value Type: <span id="hiddenDimension_value_type">Integer</span></li>
</ul>


=== hiddenDimensions ===
<h3 class="parameter_description" id="hiddenDimensions">hiddenDimensions</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="hiddenDimensions_short_desc">
                For perceptrons, the number of nodes in hidden layers (comma separated)
           </span></li>
<li>Long Description: <span id="hiddenDimensions_long_desc">
                For perceptrons, the number of nodes in hidden layers (comma separated)
        </span></li>
<li>Default
                Value: <span id="hiddenDimensions_default_value">50,50,50,50,50</span></li>
<li>Lower Bound: <span id="hiddenDimensions_lower_bound"></span></li>
<li>Upper
                Bound: <span id="hiddenDimensions_upper_bound"></span></li>
<li>Value Type: <span id="hiddenDimensions_value_type">String</span></li>
</ul>


=== ia ===
<h3 class="parameter_description" id="ia">ia</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="ia_short_desc">IA parameter (GLASSO)</span></li>
<li>Long
                Description: <span id="ia_long_desc"> Sets the maximum number of
        iterations of the optimization loop.</span></li>
<li>Default Value:
                <span id="ia_default_value">true</span></li>
<li>Lower Bound: <span id="ia_lower_bound"></span></li>
<li>Upper Bound: <span id="ia_upper_bound"></span></li>
<li>Value Type: <span id="ia_value_type">Boolean</span></li>
</ul>


=== imagesMetaAlg ===
<h3 class="parameter_description" id="imagesMetaAlg">imagesMetaAlg</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="imagesMetaAlg_short_desc">IMaGES "meta" algorithm. 1 = FGES, 2 = BOSS-Tuck</span></li>
<li>Long
                Description: <span id="imagesMetaAlg_long_desc"> Sets the meta algorithm to be optimized using the IMaGES (average BIC) score.</span>
</li>
<li>Default Value:
                <span id="imagesMetaAlg_default_value">1</span></li>
<li>Lower Bound: <span id="imagesMetaAlg_lower_bound">1</span></li>
<li>Upper Bound: <span id="imagesMetaAlg_upper_bound">5</span></li>
<li>Value Type: <span id="imagesMetaAlg_value_type">Integer</span></li>
</ul>


=== includeAllNodes ===
<h3 class="parameter_description" id="includeAllNodes">includeAllNodes</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="includeAllNodes_short_desc">True if all nodes should be included in the output </span>
</li>
<li>Long Description: <span id="includeAllNodes_long_desc">True if all nodes should be included in the output. </span>
</li>
<li>Default Value: <span id="includeAllNodes_default_value">false</span></li>
<li>Lower
                Bound: <span id="includeAllNodes_lower_bound"></span></li>
<li>Upper Bound: <span id="includeAllNodes_upper_bound"></span></li>
<li>Value Type:
                <span id="includeAllNodes_value_type">Boolean</span></li>
</ul>


=== includeNegativeCoefs ===
<h3 class="parameter_description" id="includeNegativeCoefs">includeNegativeCoefs</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="includeNegativeCoefs_short_desc">Yes if negative coefficients
        should be included in the model</span></li>
<li>Long Description:
                <span id="includeNegativeCoefs_long_desc"> One may include positive
        coefficients, negative coefficients, or both, in the model. To
        include negative coefficients, set this parameter to “Yes”.</span>
</li>
<li>Default Value: <span id="includeNegativeCoefs_default_value">true</span></li>
<li>Lower
                Bound: <span id="includeNegativeCoefs_lower_bound"></span></li>
<li>Upper Bound: <span id="includeNegativeCoefs_upper_bound"></span></li>
<li>Value Type:
                <span id="includeNegativeCoefs_value_type">Boolean</span></li>
</ul>


=== includeNegativeSkewsForBeta ===
<h3 class="parameter_description" id="includeNegativeSkewsForBeta">includeNegativeSkewsForBeta</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="includeNegativeSkewsForBeta_short_desc"> Yes if negative skew
        values should be included in the model, if Beta errors are
        chosen</span></li>
<li>Long Description: <span id="includeNegativeSkewsForBeta_long_desc"> Yes if negative skew
        values should be included in the model, if Beta errors are
        chosen.</span></li>
<li>Default Value: <span id="includeNegativeSkewsForBeta_default_value">true</span></li>
<li>Lower Bound: <span id="includeNegativeSkewsForBeta_lower_bound"></span></li>
<li>Upper
                Bound: <span id="includeNegativeSkewsForBeta_upper_bound"></span></li>
<li>Value
                Type: <span id="includeNegativeSkewsForBeta_value_type">Boolean</span></li>
</ul>


=== includePositiveCoefs ===
<h3 class="parameter_description" id="includePositiveCoefs">includePositiveCoefs</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="includePositiveCoefs_short_desc"> Yes if positive coefficients
        should be included in the model</span></li>
<li>Long Description:
                <span id="includePositiveCoefs_long_desc">Yes if We may include
        positive coefficients, should be included in the model, no if
        not.</span></li>
<li>Default Value: <span id="includePositiveCoefs_default_value">true</span></li>
<li>Lower
                Bound: <span id="includePositiveCoefs_lower_bound"></span></li>
<li>Upper Bound: <span id="includePositiveCoefs_upper_bound"></span></li>
<li>Value Type:
                <span id="includePositiveCoefs_value_type">Boolean</span></li>
</ul>


=== includePositiveSkewsForBeta ===
<h3 class="parameter_description" id="includePositiveSkewsForBeta">includePositiveSkewsForBeta</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="includePositiveSkewsForBeta_short_desc"> Yes if positive skew
        values should be included in the model, if Beta errors are
        chosen</span></li>
<li>Long Description: <span id="includePositiveSkewsForBeta_long_desc"> Yes if positive skew
        values should be included in the model, if Beta errors are
        chosen.</span></li>
<li>Default Value: <span id="includePositiveSkewsForBeta_default_value">true</span></li>
<li>Lower Bound: <span id="includePositiveSkewsForBeta_lower_bound"></span></li>
<li>Upper
                Bound: <span id="includePositiveSkewsForBeta_upper_bound"></span></li>
<li>Value
                Type: <span id="includePositiveSkewsForBeta_value_type">Boolean</span></li>
</ul>


=== inputScale ===
<h3 class="parameter_description" id="inputScale">inputScale</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="inputScale_short_desc">
                For a shallow multilayer perception (MLP), the input scale (affects bumpiness)
            </span></li>
<li>Long Description: <span id="inputScale_long_desc">
                For a shallow multilayer perception (MLP), the input scale (affects bumpiness)
        </span></li>
<li>Default
                Value: <span id="inputScale_default_value">5.0</span></li>
<li>Lower Bound: <span id="inputScale_lower_bound">0.0</span></li>
<li>Upper
                Bound: <span id="inputScale_upper_bound">Infinity</span></li>
<li>Value Type: <span id="inputScale_value_type">Double</span></li>
</ul>


=== instanceRow ===
<h3 class="parameter_description" id="instanceRow">instanceRow</h3>
<ul class="parameter_description_list">
<li>Short Description:
                <span id="instanceRow_short_desc">Indicates a particular row in the
                testing dataset (one-indexed)</span>
</li>
<li>Long Description:
                <span id="instanceRow_long_desc">
                  If the algorithm uses a testing dataset, this row index points to
                  a specific row in the data to be used as input to the algorithm.
                  This is one-indexed.
                </span>
</li>
<li>Default Value: <span id="instanceRow_default_value">1</span></li>
<li>Lower Bound: <span id="instanceRow_lower_bound">1</span></li>
<li>Upper Bound: <span id="instanceRow_upper_bound">2147483647</span></li>
<li>Value Type: <span id="instanceRow_value_type">Integer</span></li>
</ul>


=== instanceSpecificAlpha ===
<h3 class="parameter_description" id="instanceSpecificAlpha">instanceSpecificAlpha</h3>
<ul class="parameter_description_list">
<li>Short Description:
                <span id="instanceSpecificAlpha_short_desc">
                Weight for instance-specific component to the score
                </span>
</li>
<li>Long Description:
                <span id="instanceSpecificAlpha_long_desc">
                  Weight for instance-specific component to the score.
                </span>
</li>
<li>Default Value: <span id="instanceSpecificAlpha_default_value">1.0</span></li>
<li>Lower Bound: <span id="instanceSpecificAlpha_lower_bound">0</span></li>
<li>Upper Bound: <span id="instanceSpecificAlpha_upper_bound">Infinity</span></li>
<li>Value Type: <span id="instanceSpecificAlpha_value_type">Double</span></li>
</ul>


=== intervalBetweenRecordings ===
<h3 class="parameter_description" id="intervalBetweenRecordings">intervalBetweenRecordings</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="intervalBetweenRecordings_short_desc"> Interval between data
        recordings for the linear Fisher model (min = 1)</span></li>
<li>Long Description: <span id="intervalBetweenRecordings_long_desc"></span></li>
<li>Default
                Value: <span id="intervalBetweenRecordings_default_value">10</span></li>
<li>Lower
                Bound: <span id="intervalBetweenRecordings_lower_bound">1</span></li>
<li>Upper Bound: <span id="intervalBetweenRecordings_upper_bound">2147483647</span></li>
<li>Value Type: <span id="intervalBetweenRecordings_value_type">Integer</span></li>
</ul>


=== intervalBetweenShocks ===
<h3 class="parameter_description" id="intervalBetweenShocks">intervalBetweenShocks</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="intervalBetweenShocks_short_desc"> Interval between shocks (R. A.
        Fisher simulation model) (min = 1)</span></li>
<li>Long Description:
                <span id="intervalBetweenShocks_long_desc"> This is a parameter for
        the linear Fisher option. This sets the number of step between
        shocks.</span></li>
<li>Default Value: <span id="intervalBetweenShocks_default_value">10</span></li>
<li>Lower
                Bound: <span id="intervalBetweenShocks_lower_bound">1</span></li>
<li>Upper Bound: <span id="intervalBetweenShocks_upper_bound">2147483647</span></li>
<li>Value Type: <span id="intervalBetweenShocks_value_type">Integer</span></li>
</ul>


=== ipen ===
<h3 class="parameter_description" id="ipen">ipen</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="ipen_short_desc">IPEN parameter (GLASSO)</span></li>
<li>Long
                Description: <span id="ipen_long_desc"> This sets the maximum number
        of iterations of the optimization loop.</span></li>
<li>Default
                Value: <span id="ipen_default_value">false</span></li>
<li>Lower
                Bound: <span id="ipen_lower_bound"></span></li>
<li>Upper Bound:
                <span id="ipen_upper_bound"></span></li>
<li>Value Type: <span id="ipen_value_type">Boolean</span></li>
</ul>


=== is ===
<h3 class="parameter_description" id="is">is</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="is_short_desc">IS parameter (GLASSO)</span></li>
<li>Long
                Description: <span id="is_long_desc"> Sets the maximum number of
        iterations of the optimization loop.</span></li>
<li>Default Value:
                <span id="is_default_value">false</span></li>
<li>Lower Bound: <span id="is_lower_bound"></span></li>
<li>Upper Bound: <span id="is_upper_bound"></span></li>
<li>Value Type: <span id="is_value_type">Boolean</span></li>
</ul>


=== itr ===
<h3 class="parameter_description" id="itr">itr</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="itr_short_desc">ITR parameter (GLASSO)</span></li>
<li>Long
                Description: <span id="itr_long_desc"> Sets the maximum number of
        iterations of the optimization loop.</span></li>
<li>Default Value:
                <span id="itr_default_value">false</span></li>
<li>Lower Bound: <span id="itr_lower_bound"></span></li>
<li>Upper Bound: <span id="itr_upper_bound"></span></li>
<li>Value Type: <span id="itr_value_type">Boolean</span></li>
</ul>


=== kciAlpha ===
<h3 class="parameter_description" id="kciAlpha">kciAlpha</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="kciAlpha_short_desc">Cutoff for p values (alpha) (min =
        0.0)</span></li>
<li>Long Description: <span id="kciAlpha_long_desc">Alpha level (0 to 1)</span></li>
<li>Default
                Value: <span id="kciAlpha_default_value">0.05</span></li>
<li>Lower
                Bound: <span id="kciAlpha_lower_bound">0.0</span></li>
<li>Upper
                Bound: <span id="kciAlpha_upper_bound">1.0</span></li>
<li>Value
                Type: <span id="kciAlpha_value_type">Double</span></li>
</ul>


=== kciCutoff ===
<h3 class="parameter_description" id="kciCutoff">kciCutoff</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="kciCutoff_short_desc">Cutoff</span></li>
<li>Long Description:
                <span id="kciCutoff_long_desc">Cutoff for p-values.</span></li>
<li>Default Value: <span id="kciCutoff_default_value">6</span></li>
<li>Lower Bound: <span id="kciCutoff_lower_bound">1</span></li>
<li>Upper Bound: <span id="kciCutoff_upper_bound">2147483647</span></li>
<li>Value Type:
                <span id="kciCutoff_value_type">Integer</span></li>
</ul>


=== kciEpsilon ===
<h3 class="parameter_description" id="kciEpsilon">kciEpsilon</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="kciEpsilon_short_desc">Epsilon, a small
        positive number</span></li>
<li>Long Description: <span id="kciEpsilon_long_desc"> See Zhang, K., Peters, J., Janzing, D., &amp;
        Schölkopf, B. (2012). Kernel-based conditional independence test and
        application in causal discovery.. This parameter is the  epsilon for
        Proposition 5, a small positive number.</span></li>
<li>Default
                Value: <span id="kciEpsilon_default_value">0.001</span></li>
<li>Lower Bound: <span id="kciEpsilon_lower_bound">0.0</span></li>
<li>Upper Bound: <span id="kciEpsilon_upper_bound">Infinity</span></li>
<li>Value Type:
                <span id="kciEpsilon_value_type">Double</span></li>
</ul>


=== kciNumBootstraps ===
<h3 class="parameter_description" id="kciNumBootstraps">kciNumBootstraps</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="kciNumBootstraps_short_desc">Number of bootstraps</span></li>
<li>Long Description: <span id="kciNumBootstraps_long_desc"> This parameter is the number of
        bootstraps for Theorems 4 from Zhang, K., Peters, J., Janzing, D., &amp;
        Schölkopf, B. (2012) and Proposition 5, a positive integer.</span>
</li>
<li>Default Value: <span id="kciNumBootstraps_default_value">1000</span></li>
<li>Lower Bound:
                <span id="kciNumBootstraps_lower_bound">1</span></li>
<li>Upper
                Bound: <span id="kciNumBootstraps_upper_bound">2147483647</span></li>
<li>Value Type: <span id="kciNumBootstraps_value_type">Integer</span></li>
</ul>


=== kciUseApproximation ===
<h3 class="parameter_description" id="kciUseApproximation">kciUseApproximation</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="kciUseApproximation_short_desc">Use the Gamma
        approximation algorithm</span></li>
<li>Long Description: <span id="kciUseApproximation_long_desc"> Referring to Zhang, K., Peters, J.,
        Janzing, D., &amp; Schölkopf, B. (2012), if this parameter is set to
        ‘Yes’, the Gamma approximation algorithm is used; if no, the exact
        procedure is used.</span></li>
<li>Default Value: <span id="kciUseApproximation_default_value">true</span></li>
<li>Lower
                Bound: <span id="kciUseApproximation_lower_bound"></span></li>
<li>Upper Bound: <span id="kciUseApproximation_upper_bound"></span></li>
<li>Value Type: <span id="kciUseApproximation_value_type">Boolean</span></li>
</ul>


=== kernelRegressionSampleSize ===
<h3 class="parameter_description" id="kernelRegressionSampleSize">kernelRegressionSampleSize</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="kernelRegressionSampleSize_short_desc">Minimum sample size to use
        per conditioning for kernel regression</span></li>
<li>Long
                Description: <span id="kernelRegressionSampleSize_long_desc"> The
        smallest set of nearest data points on which to allow a judgment to
        be based for a nonlinear regression.</span></li>
<li>Default Value:
                <span id="kernelRegressionSampleSize_default_value">100</span></li>
<li>Lower Bound: <span id="kernelRegressionSampleSize_lower_bound">-2147483648</span></li>
<li>Upper Bound: <span id="kernelRegressionSampleSize_upper_bound">2147483647</span></li>
<li>Value Type: <span id="kernelRegressionSampleSize_value_type">Integer</span></li>
</ul>


=== kernelType ===
<h3 class="parameter_description" id="kernelType">kernelType</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="kernelType_short_desc">
                Kernel type (1 = Gaussian, 2 = Linear, 3 = Polynomial)
            </span></li>
<li>Long Description: <span id="kernelType_long_desc"> Determines which kernel type
        will be used (1 = Gaussian, 2 = Linear, 3 = Polynomial).</span></li>
<li>Default Value: <span id="kernelType_default_value">1</span></li>
<li>Lower Bound: <span id="kernelType_lower_bound">1</span></li>
<li>Upper Bound: <span id="kernelType_upper_bound">3</span></li>
<li>Value Type: <span id="kernelType_value_type">Integer</span></li>
</ul>


=== kernelWidth ===
<h3 class="parameter_description" id="kernelWidth">kernelWidth</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="kernelWidth_short_desc">Kernel width</span></li>
<li>Long
                Description: <span id="kernelWidth_long_desc"> A larger kernel width
        means that more information will be taken into account but possibly
        less focused information.</span></li>
<li>Default Value: <span id="kernelWidth_default_value">1.0</span></li>
<li>Lower Bound: <span id="kernelWidth_lower_bound">4.9E-324</span></li>
<li>Upper Bound:
                <span id="kernelWidth_upper_bound">Infinity</span></li>
<li>Value
                Type: <span id="kernelWidth_value_type">Double</span></li>
</ul>


=== lambda1 ===
<h3 class="parameter_description" id="lambda1">lambda1</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="lambda1_short_desc">lambda1</span></li>
<li>Long Description: <span id="lambda1_long_desc">Tuning parameter for DAGMA</span>
</li>
<li>Default Value: <span id="lambda1_default_value">0.05</span></li>
<li>Lower
                Bound: <span id="lambda1_lower_bound">0</span></li>
<li>Upper Bound: <span id="lambda1_upper_bound">Infinity</span></li>
<li>Value Type:
                <span id="lambda1_value_type">Double</span></li>
</ul>


=== lowerBound ===
<h3 class="parameter_description" id="lowerBound">lowerBound</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="lowerBound_short_desc">Lower bound cutoff threshold</span></li>
<li>Long Description: <span id="lowerBound_long_desc">null</span></li>
<li>Default Value: <span id="lowerBound_default_value">0.3</span></li>
<li>Lower Bound: <span id="lowerBound_lower_bound">0.0</span></li>
<li>Upper Bound: <span id="lowerBound_upper_bound">1.0</span></li>
<li>Value Type: <span id="lowerBound_value_type">Double</span></li>
</ul>


=== manualLambda ===
<h3 class="parameter_description" id="manualLambda">manualLambda</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="manualLambda_short_desc">Lambda (manually set)</span></li>
<li>Long Description: <span id="manualLambda_long_desc"> The manually
        set lambda for GIC--the default is 10, though this should be set by
        the user to a good value. </span></li>
<li>Default Value: <span id="manualLambda_default_value">10.0</span></li>
<li>Lower Bound:
                <span id="manualLambda_lower_bound">0.0</span></li>
<li>Upper Bound:
                <span id="manualLambda_upper_bound">1.7976931348623157E308</span></li>
<li>Value Type: <span id="manualLambda_value_type">Double</span></li>
</ul>


=== maxBlockingPathLength ===
<h3 class="parameter_description" id="maxBlockingPathLength">maxBlockingPathLength</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="maxBlockingPathLength_short_desc">
                Maximum path length for paths for searching for path blocking sets
                (-1 = no limit)
            </span></li>
<li>Long Description: <span id="maxBlockingPathLength_long_desc">
                    The maximum length of paths to search for path blocking sets.
        </span></li>
<li>Default
                Value: <span id="maxBlockingPathLength_default_value">-1</span></li>
<li>Lower Bound: <span id="maxBlockingPathLength_lower_bound">-1</span></li>
<li>Upper
                Bound: <span id="maxBlockingPathLength_upper_bound">2147483647</span></li>
<li>Value Type: <span id="maxBlockingPathLength_value_type">Integer</span></li>
</ul>


=== maxCategories ===
<h3 class="parameter_description" id="maxCategories">maxCategories</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="maxCategories_short_desc">Maximum number of categories (min =
        2)</span></li>
<li>Long Description: <span id="maxCategories_long_desc"> The maximum number of categories to be
        used for randomly generated discrete variables. The default is 2.
        This needs to be greater or equal to than the minimum number of
        categories.</span></li>
<li>Default Value: <span id="maxCategories_default_value">3</span></li>
<li>Lower Bound: <span id="maxCategories_lower_bound">2</span></li>
<li>Upper Bound: <span id="maxCategories_upper_bound">2147483647</span></li>
<li>Value Type:
                <span id="maxCategories_value_type">Integer</span></li>
</ul>


=== maxCorrelation ===
<h3 class="parameter_description" id="maxCorrelation">maxCorrelation</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="maxCorrelation_short_desc">Maximum absolute correlation
        considered</span></li>
<li>Long Description: <span id="maxCorrelation_long_desc">For the Nandy rule, the absolute max
        correlation r. For the standard BIC or high-dimensional rule, the
        maximum absolute residual correlation.</span></li>
<li>Default Value:
                <span id="maxCorrelation_default_value">1.0</span></li>
<li>Lower
                Bound: <span id="maxCorrelation_lower_bound">0.0</span></li>
<li>Upper Bound: <span id="maxCorrelation_upper_bound">1.0</span></li>
<li>Value Type: <span id="maxCorrelation_value_type">Double</span></li>
</ul>


=== maxDegree ===
<h3 class="parameter_description" id="maxDegree">maxDegree</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="maxDegree_short_desc">The maximum degree of the graph (min =
        -1)</span></li>
<li>Long Description: <span id="maxDegree_long_desc"> An upper bound on the maximum degree of any
        node in the graph. If no limit is to be placed on the maximum degree,
        use the value -1.</span></li>
<li>Default Value: <span id="maxDegree_default_value">1000</span></li>
<li>Lower Bound: <span id="maxDegree_lower_bound">1</span></li>
<li>Upper Bound: <span id="maxDegree_upper_bound">2147483647</span></li>
<li>Value Type:
                <span id="maxDegree_value_type">Integer</span></li>
</ul>


=== maxDiscriminatingPathLength ===
<h3 class="parameter_description" id="maxDiscriminatingPathLength">maxDiscriminatingPathLength</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="maxDiscriminatingPathLength_short_desc">The maximum length for any
        discriminating path. -1 if unlimited (min = -1)</span></li>
<li>Long
                Description: <span id="maxDiscriminatingPathLength_long_desc"> See Spirtes,
        Glymour, and Scheines (2000) for the definition of discrimination
        path. Finding discriminating paths can be expensive. This sets the
        maximum length of such paths that the algorithm tries to find.</span>
</li>
<li>Default Value: <span id="maxDiscriminatingPathLength_default_value">-1</span></li>
<li>Lower Bound:
                <span id="maxDiscriminatingPathLength_lower_bound">-1</span></li>
<li>Upper Bound:
                <span id="maxDiscriminatingPathLength_upper_bound">2147483647</span></li>
<li>Value
                Type: <span id="maxDiscriminatingPathLength_value_type">Integer</span></li>
</ul>


=== maxDistinctValuesDiscrete ===
<h3 class="parameter_description" id="maxDistinctValuesDiscrete">maxDistinctValuesDiscrete</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="maxDistinctValuesDiscrete_short_desc"> The maximum number of
        distinct values in a column for discrete variables (min = 0)</span>
</li>
<li>Long Description: <span id="maxDistinctValuesDiscrete_long_desc"> Discrete variables will be
        simulated using any number of categories from 2 up to this maximum.
        If set to 0 or 1, discrete variables will not be generated.</span>
</li>
<li>Default Value: <span id="maxDistinctValuesDiscrete_default_value">0</span></li>
<li>Lower
                Bound: <span id="maxDistinctValuesDiscrete_lower_bound">0</span></li>
<li>Upper Bound: <span id="maxDistinctValuesDiscrete_upper_bound">2147483647</span></li>
<li>Value Type: <span id="maxDistinctValuesDiscrete_value_type">Integer</span></li>
</ul>


=== maxIndegree ===
<h3 class="parameter_description" id="maxIndegree">maxIndegree</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="maxIndegree_short_desc">Maximum indegree of graph (min =
        1)</span></li>
<li>Long Description: <span id="maxIndegree_long_desc"> An upper bound on the maximum indegree of
        any node in the graph. If no limit is to be placed on the maximum
        degree, use the value -1.</span></li>
<li>Default Value: <span id="maxIndegree_default_value">1000</span></li>
<li>Lower Bound: <span id="maxIndegree_lower_bound">1</span></li>
<li>Upper Bound: <span id="maxIndegree_upper_bound">2147483647</span></li>
<li>Value Type:
                <span id="maxIndegree_value_type">Integer</span></li>
</ul>


=== maxit ===
<h3 class="parameter_description" id="maxit">maxit</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="maxit_short_desc">MAXIT parameter (GLASSO) (min = 1)</span></li>
<li>Long Description: <span id="maxit_long_desc"> Sets the maximum
        number of iterations of the optimization loop.</span></li>
<li>Default Value: <span id="maxit_default_value">10000</span></li>
<li>Lower Bound: <span id="maxit_lower_bound">1</span></li>
<li>Upper
                Bound: <span id="maxit_upper_bound">2147483647</span></li>
<li>Value
                Type: <span id="maxit_value_type">Integer</span></li>
</ul>


=== maxIterations ===
<h3 class="parameter_description" id="maxIterations">maxIterations</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="maxIterations_short_desc"> The maximum number of iterations the
        algorithm should go through orienting edges</span></li>
<li>Long
                Description: <span id="maxIterations_long_desc"> In orienting, this
        algorithm may go through a number of iterations, conditioning on more
        and more variables until orientations are set. This sets that
        number.</span></li>
<li>Default Value: <span id="maxIterations_default_value">15</span></li>
<li>Lower Bound:
                <span id="maxIterations_lower_bound">0</span></li>
<li>Upper Bound:
                <span id="maxIterations_upper_bound">2147483647</span></li>
<li>Value
                Type: <span id="maxIterations_value_type">Integer</span></li>
</ul>


=== maxOutdegree ===
<h3 class="parameter_description" id="maxOutdegree">maxOutdegree</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="maxOutdegree_short_desc">Maximum outdegree of graph (min =
        1)</span></li>
<li>Long Description: <span id="maxOutdegree_long_desc"> An upper bound on the maximum outdegree
        of any node in the graph. If no limit is to be placed on the maximum
        degree, use the value -1.</span></li>
<li>Default Value: <span id="maxOutdegree_default_value">1000</span></li>
<li>Lower Bound:
                <span id="maxOutdegree_lower_bound">1</span></li>
<li>Upper Bound:
                <span id="maxOutdegree_upper_bound">2147483647</span></li>
<li>Value
                Type: <span id="maxOutdegree_value_type">Integer</span></li>
</ul>


=== maxPaxPOrientationHeuristicMaxLength ===
<h3 class="parameter_description" id="maxPaxPOrientationHeuristicMaxLength">maxPaxPOrientationHeuristicMaxLength</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="maxPaxPOrientationHeuristicMaxLength_short_desc">
                    The maximum path length to use for the max p heuristic version.
                    </span></li>
<li>Long Description: <span id="maxPaxPOrientationHeuristicMaxLength_long_desc">
                    The maximum path length to use for the max p heuristic version.

     		</span></li>
<li>Default Value: <span id="maxPaxPOrientationHeuristicMaxLength_default_value">5</span></li>
<li>Lower Bound: <span id="maxPaxPOrientationHeuristicMaxLength_lower_bound">0</span></li>
<li>Upper
                Bound: <span id="maxPaxPOrientationHeuristicMaxLength_upper_bound">100000</span></li>
<li>Value
                Type: <span id="maxPaxPOrientationHeuristicMaxLength_value_type">Integer</span></li>
</ul>


=== maxPOrientationMaxPathLength ===
<h3 class="parameter_description" id="maxPOrientationMaxPathLength">maxPOrientationMaxPathLength</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="maxPOrientationMaxPathLength_short_desc">Maximum path length for
        the unshielded collider heuristic for max P (min = 0)</span></li>
<li>Long Description: <span id="maxPOrientationMaxPathLength_long_desc"> For the Max P
        “heuristic” to work, it must be the case that X and Z are only weakly
        associated—that is, that paths between them are not too short. This
        bounds the length of paths for this purpose.</span></li>
<li>Default
                Value: <span id="maxPOrientationMaxPathLength_default_value">3</span></li>
<li>Lower Bound: <span id="maxPOrientationMaxPathLength_lower_bound">0</span></li>
<li>Upper
                Bound: <span id="maxPOrientationMaxPathLength_upper_bound">2147483647</span></li>
<li>Value Type: <span id="maxPOrientationMaxPathLength_value_type">Integer</span></li>
</ul>


=== maxRank ===
<h3 class="parameter_description" id="maxRank">maxRank</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="maxRank_short_desc">
                    The algorithm looks for clusters from rank 1 up through this rank
        </span></li>
<li>Long Description: <span id="maxRank_long_desc">
                    The algorithm looks for clusters from rank 1 up through this rank
        </span></li>
<li>Default Value: <span id="maxRank_default_value">2</span></li>
<li>Lower Bound: <span id="maxRank_lower_bound">1</span></li>
<li>Upper
                Bound: <span id="maxRank_upper_bound">1000</span></li>
<li>Value
                Type: <span id="maxRank_value_type">Integer</span></li>
</ul>


=== maxScoreDrop ===
<h3 class="parameter_description" id="maxScoreDrop">maxScoreDrop</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="maxScoreDrop_short_desc">
                    Maximum score drop for the process triples step
        </span></li>
<li>Long Description: <span id="maxScoreDrop_long_desc">
                    In orienting unshielded colliders by examining triples of nodes,
                    the score is permitted to drop by this much.
        </span></li>
<li>Default Value: <span id="maxScoreDrop_default_value">5</span></li>
<li>Lower Bound: <span id="maxScoreDrop_lower_bound">0</span></li>
<li>Upper
                Bound: <span id="maxScoreDrop_upper_bound">Infinity</span></li>
<li>Value
                Type: <span id="maxScoreDrop_value_type">Double</span></li>
</ul>


=== maxSepsetSize ===
<h3 class="parameter_description" id="maxSepsetSize">maxSepsetSize</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="maxSepsetSize_short_desc">For testing steps in FCIT, the
                    maximum conditioning set size</span></li>
<li>Long Description: <span id="maxSepsetSize_long_desc">
                    In the extra edge removal step, we build conditioning sets based on the
                    current PAG to attempt to remove adjacencies from the graph, by
                    blocking paths from x to y of up to this length. This is the maximum
                    size these sets are allowed to grow to.
        </span></li>
<li>Default
                Value: <span id="maxSepsetSize_default_value">8</span></li>
<li>Lower Bound: <span id="maxSepsetSize_lower_bound">0</span></li>
<li>Upper
                Bound: <span id="maxSepsetSize_upper_bound">2147483647</span></li>
<li>Value Type: <span id="maxSepsetSize_value_type">Integer</span></li>
</ul>


=== mb ===
<h3 class="parameter_description" id="mb">mb</h3>
<ul class="mb_list">
<li>Short Description: <span id="mb_short_desc">Find Markov blanket(s)</span></li>
<li>Long Description: <span id="mb_long_desc">Looks for the graph over the Markov blanket(s) and target(s) if true</span>
</li>
<li>Default Value: <span id="mb_default_value">false</span></li>
<li>Lower Bound: <span id="mb_lower_bound"></span></li>
<li>Upper Bound: <span id="mb_upper_bound"></span></li>
<li>Value Type: <span id="mb_value_type">Boolean</span></li>
</ul>


=== mcAlpha ===
<h3 class="parameter_description" id="mcAlpha">mcAlpha</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="mcAlpha_short_desc">Markov Checker Alpha Level (0 to 1)</span></li>
<li>Long Description: <span id="mcAlpha_long_desc">Markov Checker Alpha Level (0 to 1)</span></li>
<li>Default
                Value: <span id="mcAlpha_default_value">0.05</span></li>
<li>Lower
                Bound: <span id="mcAlpha_lower_bound">0.0</span></li>
<li>Upper
                Bound: <span id="mcAlpha_upper_bound">1.0</span></li>
<li>Value
                Type: <span id="mcAlpha_value_type">Double</span></li>
</ul>


=== meanHigh ===
<h3 class="parameter_description" id="meanHigh">meanHigh</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="meanHigh_short_desc">High end of mean range (min =
        0.0)</span></li>
<li>Long Description: <span id="meanHigh_long_desc">
        The default is for there to be no shift in mean, but shifts from a
        minimum value to a maximum value may be specified. The minimum must
        be less than or equal to this maximum.</span></li>
<li>Default
                Value: <span id="meanHigh_default_value">1.0</span></li>
<li>Lower
                Bound: <span id="meanHigh_lower_bound">0.0</span></li>
<li>Upper
                Bound: <span id="meanHigh_upper_bound">1.7976931348623157E308</span></li>
<li>Value Type: <span id="meanHigh_value_type">Double</span></li>
</ul>


=== meanLow ===
<h3 class="parameter_description" id="meanLow">meanLow</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="meanLow_short_desc">Low end of mean range (min = 0.0)</span></li>
<li>Long Description: <span id="meanLow_long_desc"> The default is
        for there to be no shift in mean, but shifts from a minimum value to
        a maximum value may be specified. The minimum must be greater than or
        equal to this minimum.</span></li>
<li>Default Value: <span id="meanLow_default_value">0.5</span></li>
<li>Lower Bound: <span id="meanLow_lower_bound">0.0</span></li>
<li>Upper Bound: <span id="meanLow_upper_bound">1.7976931348623157E308</span></li>
<li>Value
                Type: <span id="meanLow_value_type">Double</span></li>
</ul>


=== measurementVariance ===
<h3 class="parameter_description" id="measurementVariance">measurementVariance</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="measurementVariance_short_desc"> Additive measurement noise
        variance (min = 0.0)</span></li>
<li>Long Description: <span id="measurementVariance_long_desc"> If the value is greater than
        zero, independent Gaussian noise will be added with mean zero and the
        given variance to each variable in the simulated output.</span>
</li>
<li>Default Value: <span id="measurementVariance_default_value">0.0</span></li>
<li>Lower
                Bound: <span id="measurementVariance_lower_bound">0.0</span></li>
<li>Upper Bound: <span id="measurementVariance_upper_bound">1.7976931348623157E308</span>
</li>
<li>Value Type: <span id="measurementVariance_value_type">Double</span></li>
</ul>


=== mgmParam1 ===
<h3 class="parameter_description" id="mgmParam1">mgmParam1</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="mgmParam1_short_desc">MGM tuning parameter #1 (min =
        0.0)</span></li>
<li>Long Description: <span id="mgmParam1_long_desc"> The MGM algorithm has three internal tuning
        parameters, of which this is one.</span></li>
<li>Default Value:
                <span id="mgmParam1_default_value">0.1</span></li>
<li>Lower Bound:
                <span id="mgmParam1_lower_bound">0.0</span></li>
<li>Upper Bound:
                <span id="mgmParam1_upper_bound">1.7976931348623157E308</span></li>
<li>Value Type: <span id="mgmParam1_value_type">Double</span></li>
</ul>


=== mgmParam2 ===
<h3 class="parameter_description" id="mgmParam2">mgmParam2</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="mgmParam2_short_desc">MGM tuning parameter #2 (min =
        0.0)</span></li>
<li>Long Description: <span id="mgmParam2_long_desc"> The MGM algorithm has three internal tuning
        parameters, of which this is one.</span></li>
<li>Default Value:
                <span id="mgmParam2_default_value">0.1</span></li>
<li>Lower Bound:
                <span id="mgmParam2_lower_bound">0.0</span></li>
<li>Upper Bound:
                <span id="mgmParam2_upper_bound">1.7976931348623157E308</span></li>
<li>Value Type: <span id="mgmParam2_value_type">Double</span></li>
</ul>


=== mgmParam3 ===
<h3 class="parameter_description" id="mgmParam3">mgmParam3</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="mgmParam3_short_desc">MGM tuning parameter #3 (min =
        0.0)</span></li>
<li>Long Description: <span id="mgmParam3_long_desc">The MGM algorithm has three internal tuning
        parameters, of which this is one.</span></li>
<li>Default Value:
                <span id="mgmParam3_default_value">0.1</span></li>
<li>Lower Bound:
                <span id="mgmParam3_lower_bound">0.0</span></li>
<li>Upper Bound:
                <span id="mgmParam3_upper_bound">1.7976931348623157E308</span></li>
<li>Value Type: <span id="mgmParam3_value_type">Double</span></li>
</ul>


=== mimbuildType ===
<h3 class="parameter_description" id="mimbuildType">mimbuildType</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="mimbuildType_short_desc">Mimbuild type: 1 = PCA, 2 = Bollen</span></li>
<li>Long Description: <span id="mimbuildType_long_desc">Mimbuild type: 1 = PCA, 2 = Bollen</span></li>
<li>Default Value: <span id="mimbuildType_default_value">1</span></li>
<li>Lower Bound:
                <span id="mimbuildType_lower_bound">1</span></li>
<li>Upper Bound:
                <span id="mimbuildType_upper_bound">2</span></li>
<li>Value Type: <span id="mimbuildType_value_type">Integer</span></li>
</ul>


=== mimLatentGroupSpecs ===
<h3 class="parameter_description" id="mimLatentGroupSpecs">mimLatentGroupSpecs</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="mimLatentGroupSpecs_short_desc">
                MIM: List of count:children:(rank), comma separated; e.g. 5:6(1),2:8(2):</span></li>
<li>Long Description: <span id="mimLatentGroupSpecs_long_desc">
                List of count:children:(rank), comma separated; e.g. 5:6(1),2:8(2)</span></li>
<li>Default Value: <span id="mimLatentGroupSpecs_default_value">5:6(1)</span></li>
<li>Lower Bound: <span id="mimLatentGroupSpecs_lower_bound"></span></li>
<li>Upper Bound: <span id="mimLatentGroupSpecs_upper_bound"></span></li>
<li>Value Type: <span id="mimLatentGroupSpecs_value_type">String</span></li>
</ul>


=== mimLatentMeasuredImpureParents ===
<h3 class="parameter_description" id="mimLatentMeasuredImpureParents">mimLatentMeasuredImpureParents</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="mimLatentMeasuredImpureParents_short_desc">MIM: Number of Latent --&gt;
        Measured impure edges</span></li>
<li>Long Description: <span id="mimLatentMeasuredImpureParents_long_desc"> It is possible for
        structural nodes to have as children measured variables that are
        children of other structural nodes. These edges in the graph will be
        considered impure.</span></li>
<li>Default Value: <span id="mimLatentMeasuredImpureParents_default_value">0</span></li>
<li>Lower Bound: <span id="mimLatentMeasuredImpureParents_lower_bound">-2147483648</span></li>
<li>Upper Bound: <span id="mimLatentMeasuredImpureParents_upper_bound">2147483647</span></li>
<li>Value Type: <span id="mimLatentMeasuredImpureParents_value_type">Integer</span></li>
</ul>


=== mimMeasuredMeasuredImpureAssociations ===
<h3 class="parameter_description" id="mimMeasuredMeasuredImpureAssociations">
            mimMeasuredMeasuredImpureAssociations</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="mimMeasuredMeasuredImpureAssociations_short_desc">MIM: Number of
        Measured &lt;-&gt; Measured impure edges</span></li>
<li>Long Description:
                <span id="mimMeasuredMeasuredImpureAssociations_long_desc"> It is
        possible for measures from two different structural nodes to be
        confounded. These confounding (bidirected) edges will be considered
        to be impure.</span></li>
<li>Default Value: <span id="mimMeasuredMeasuredImpureAssociations_default_value">0</span></li>
<li>Lower Bound: <span id="mimMeasuredMeasuredImpureAssociations_lower_bound">-2147483648</span></li>
<li>Upper Bound: <span id="mimMeasuredMeasuredImpureAssociations_upper_bound">2147483647</span>
</li>
<li>Value Type: <span id="mimMeasuredMeasuredImpureAssociations_value_type">Integer</span></li>
</ul>


=== mimMeasuredMeasuredImpureParents ===
<h3 class="parameter_description" id="mimMeasuredMeasuredImpureParents">mimMeasuredMeasuredImpureParents</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="mimMeasuredMeasuredImpureParents_short_desc">MIM: Number of Measured --&gt;
        Measured impure edges</span></li>
<li>Long Description: <span id="mimMeasuredMeasuredImpureParents_long_desc"> It is possible for
        measures from two different structural nodes to have directed edges
        between them. These edges will be considered to be impure.</span>
</li>
<li>Default Value: <span id="mimMeasuredMeasuredImpureParents_default_value">0</span></li>
<li>Lower Bound: <span id="mimMeasuredMeasuredImpureParents_lower_bound">-2147483648</span></li>
<li>Upper Bound: <span id="mimMeasuredMeasuredImpureParents_upper_bound">2147483647</span></li>
<li>Value Type: <span id="mimMeasuredMeasuredImpureParents_value_type">Integer</span></li>
</ul>


=== mimMetaEdgeConnectionType ===
<h3 class="parameter_description" id="mimMetaEdgeConnectionType">mimMetaEdgeConnectionType</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="mimMetaEdgeConnectionType_short_desc">
                    1 = Cartesian Product 2 = Corresponding, 3 = Patchy Connections
        </span></li>
<li>Long Description: <span id="mimMetaEdgeConnectionType_long_desc">
                    1 = Cartesian Product 2 = Corresponding, 3 = Patchy Connections
        </span></li>
<li>Default Value: <span id="mimMetaEdgeConnectionType_default_value">1</span></li>
<li>Lower Bound: <span id="mimMetaEdgeConnectionType_lower_bound">1</span></li>
<li>Upper
                Bound:
                <span4 id="mimMetaEdgeConnectionType_upper_bound">3
</span4></li>
<li>Value
                Type: <span id="mimMetaEdgeConnectionType_value_type">Integer</span></li>
</ul>


=== mimMimNumStructuralNodes ===
<h3 class="parameter_description" id="mimMimNumStructuralNodes">mimMimNumStructuralNodes</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="mimMimNumStructuralNodes_short_desc">Number of measurements per
        Latent</span></li>
<li>Long Description: <span id="mimMimNumStructuralNodes_long_desc"> Each structural node in the
        MIM will be created to have this many measured children.</span></li>
<li>Default Value: <span id="mimMimNumStructuralNodes_default_value">5</span></li>
<li>Lower
                Bound: <span id="mimMimNumStructuralNodes_lower_bound">-2147483648</span></li>
<li>Upper Bound: <span id="mimMimNumStructuralNodes_upper_bound">2147483647</span></li>
<li>Value Type: <span id="mimMimNumStructuralNodes_value_type">Integer</span></li>
</ul>


=== mimNumChildrenPerGroup ===
<h3 class="parameter_description" id="mimNumChildrenPerGroup">mimNumChildrenPerGroup</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="mimNumChildrenPerGroup_short_desc">MIM: Number of children for
                    each group  latents</span></li>
<li>Long Description: <span id="mimNumChildrenPerGroup_long_desc">Each group of latents shares
                    a common set of children of this size.</span></li>
<li>Default Value: <span id="mimNumChildrenPerGroup_default_value">0</span></li>
<li>Lower Bound: <span id="mimNumChildrenPerGroup_lower_bound">-2147483648</span></li>
<li>Upper Bound: <span id="mimNumChildrenPerGroup_upper_bound">2147483647</span></li>
<li>Value Type: <span id="mimNumChildrenPerGroup_value_type">Integer</span></li>
</ul>


=== mimNumStructuralEdges ===
<h3 class="parameter_description" id="mimNumStructuralEdges">mimNumStructuralEdges</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="mimNumStructuralEdges_short_desc">MIM: Number of structural
        edges</span></li>
<li>Long Description: <span id="mimNumStructuralEdges_long_desc"> This is a parameter for generating
        random multiple indicator models (MIMs). A structural edge is an edge
        connecting two structural nodes.</span></li>
<li>Default Value:
                <span id="mimNumStructuralEdges_default_value">5</span></li>
<li>Lower
                Bound: <span id="mimNumStructuralEdges_lower_bound">-2147483648</span></li>
<li>Upper
                Bound: <span id="mimNumStructuralEdges_upper_bound">2147483647</span></li>
<li>Value
                Type: <span id="mimNumStructuralEdges_value_type">Integer</span></li>
</ul>


=== mimNumStructuralNodes ===
<h3 class="parameter_description" id="mimNumStructuralNodes">mimNumStructuralNodes</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="mimNumStructuralNodes_short_desc">Number of structural
        nodes</span></li>
<li>Long Description: <span id="mimNumStructuralNodes_long_desc"> This is a parameter for generating
        random multiple indicator models (MIMs). A structural node is one of
        the latent variables in the model; each structural node has a number
        of child measured variables.</span></li>
<li>Default Value: <span id="mimNumStructuralNodes_default_value">3</span></li>
<li>Lower Bound:
                <span id="mimNumStructuralNodes_lower_bound">-2147483648</span></li>
<li>Upper Bound: <span id="mimNumStructuralNodes_upper_bound">2147483647</span></li>
<li>Value
                Type: <span id="mimNumStructuralNodes_value_type">Integer</span></li>
</ul>


=== minCategories ===
<h3 class="parameter_description" id="minCategories">minCategories</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="minCategories_short_desc">Minimum number of categories (min =
        2)</span></li>
<li>Long Description: <span id="minCategories_long_desc"> The minimum number of categories to be
        used for randomly generated discrete variables. The default is
        2.</span></li>
<li>Default Value: <span id="minCategories_default_value">3</span></li>
<li>Lower Bound: <span id="minCategories_lower_bound">2</span></li>
<li>Upper Bound: <span id="minCategories_upper_bound">2147483647</span></li>
<li>Value Type:
                <span id="minCategories_value_type">Integer</span></li>
</ul>


=== minCountPerCell ===
<h3 class="parameter_description" id="minCountPerCell">minCountPerCell</h3>
<ul class="minCountPerCell_list">
<li>Short Description: <span id="minCountPerCell_short_desc">
            		The minimum count per cell in a chi square table.
            </span></li>
<li>Long Description: <span id="minCountPerCell_long_desc">
                   Increasing this can improve accuracy of chi square estimates.
                    </span></li>
<li>Default Value: <span id="minCountPerCell_default_value">1</span></li>
<li>Lower
                Bound: <span id="minCountPerCell_lower_bound">1</span></li>
<li>Upper Bound: <span id="minCountPerCell_upper_bound">1000000</span></li>
<li>Value Type:
                <span id="minCountPerCell_value_type">Integer</span></li>
</ul>


=== minParamSampleSize ===
<h3 class="parameter_description" id="minParamSampleSize">minParamSampleSize</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="minParamSampleSize_short_desc">The minimum sample size per parameter</span>
</li>
<li>Long Description: <span id="minParamSampleSize_long_desc">The minimum sample size per parameter</span>
</li>
<li>Default Value: <span id="minParamSampleSize_default_value">20</span></li>
<li>Lower
                Bound: <span id="minParamSampleSize_lower_bound">1</span></li>
<li>Upper Bound: <span id="minParamSampleSize_upper_bound">100000000</span></li>
<li>Value Type:
                <span id="minParamSampleSize_value_type">Integer</span></li>
</ul>


=== minSampleSizePerCell ===
<h3 class="parameter_description" id="minSampleSizePerCell">minSampleSizePerCell</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="minSampleSizePerCell_short_desc">For conditional Gaussian, the minimum sample size per cell</span>
</li>
<li>Long Description: <span id="minSampleSizePerCell_long_desc">For conditional Gaussian, the minimum sample size per cell</span>
</li>
<li>Default Value: <span id="minSampleSizePerCell_default_value">4</span></li>
<li>Lower
                Bound: <span id="minSampleSizePerCell_lower_bound">2</span></li>
<li>Upper Bound: <span id="minSampleSizePerCell_upper_bound">100000000</span></li>
<li>Value Type:
                <span id="minSampleSizePerCell_value_type">Integer</span></li>
</ul>


=== mnarNumExtraInfluences ===
<h3 class="parameter_description" id="mnarNumExtraInfluences">mnarNumExtraInfluences</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="mnarNumExtraInfluences_short_desc">
                MNAR: The number of extra influences on missing value selection.
            </span></li>
<li>Long Description: <span id="mnarNumExtraInfluences_long_desc">
                         id="mnarNumExtraInfluences_short_desc"&gt;
                MNAR: The number of extra influences on missing value selection.
            </span></li>
<li>Default
                Value: <span id="mnarNumExtraInfluences_default_value">0</span></li>
<li>Lower Bound: <span id="mnarNumExtraInfluences_lower_bound">0</span></li>
<li>Upper
                Bound: <span id="mnarNumExtraInfluences_upper_bound">2147483647</span></li>
<li>Value Type: <span id="mnarNumExtraInfluences_value_type">Integer</span></li>
</ul>


=== mnarNumVariablesWithMissing ===
<h3 class="parameter_description" id="mnarNumVariablesWithMissing">mnarNumVariablesWithMissing</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="mnarNumVariablesWithMissing_short_desc">
                MNAR: The number of variables with missing values.
            </span></li>
<li>Long Description: <span id="mnarNumVariablesWithMissing_long_desc">
                         id="mnarNumVariablesWithMissing_short_desc"&gt;
                MNAR: The number of variables with missing values.
                </span></li>
<li>Default
                Value: <span id="mnarNumVariablesWithMissing_default_value">5</span></li>
<li>Lower Bound:
                <span id="mnarNumVariablesWithMissing_lower_bound">0</span>
</li>
<li>Upper
                Bound: <span id="mnarNumVariablesWithMissing_upper_bound">2147483647</span></li>
<li>Value Type: <span id="mnarNumVariablesWithMissing_value_type">Integer</span></li>
</ul>


=== mnarThreshold ===
<h3 class="parameter_description" id="mnarThreshold">mnarThreshold</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="mnarThreshold_short_desc">
                MNAR: Remove this fraction upper tail values for columns with missing values
            </span></li>
<li>Long Description: <span id="mnarThreshold_long_desc">
                         id="mnarThreshold_short_desc"&gt;
               MNAR: Remove this fraction upper tail values for columns with missing values
                 </span></li>
<li>Default
                Value: <span id="mnarThreshold_default_value">0.1</span></li>
<li>Lower Bound: <span id="mnarThreshold_lower_bound">0.0</span></li>
<li>Upper
                Bound: <span id="mnarThreshold_upper_bound">1.0</span></li>
<li>Value Type: <span id="mnarThreshold_value_type">Double</span></li>
</ul>


=== noRandomlyDeterminedIndependence ===
<h3 class="parameter_description" id="noRandomlyDeterminedIndependence">
            noRandomlyDeterminedIndependence</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="noRandomlyDeterminedIndependence_short_desc"> Yes, if using the
        cutoff threshold for the independence test.</span></li>
<li>Long
                Description: <span id="noRandomlyDeterminedIndependence_long_desc">null</span></li>
<li>Default Value: <span id="noRandomlyDeterminedIndependence_default_value">false</span></li>
<li>Lower Bound: <span id="noRandomlyDeterminedIndependence_lower_bound"></span></li>
<li>Upper Bound: <span id="noRandomlyDeterminedIndependence_upper_bound"></span></li>
<li>Value Type: <span id="noRandomlyDeterminedIndependence_value_type">Boolean</span></li>
</ul>


=== numBasisFunctions ===
<h3 class="parameter_description" id="numBasisFunctions">numBasisFunctions</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="numBasisFunctions_short_desc"> Number of functions to use in
        (truncated) basis</span></li>
<li>Long Description: <span id="numBasisFunctions_long_desc"> This parameter specifies how many
        of the most significant basis functions to use as a basis.</span>
</li>
<li>Default Value: <span id="numBasisFunctions_default_value">3</span></li>
<li>Lower Bound:
                <span id="numBasisFunctions_lower_bound">1</span></li>
<li>Upper
                Bound: <span id="numBasisFunctions_upper_bound">2147483647</span></li>
<li>Value
                Type: <span id="numBasisFunctions_value_type">Integer</span></li>
</ul>


=== numberOfExpansions ===
<h3 class="parameter_description" id="numberOfExpansions">numberOfExpansions</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="numberOfExpansions_short_desc">Number of expansions of the algorithm away from the target</span>
</li>
<li>Long Description: <span id="numberOfExpansions_long_desc">Each expansion iterates to concentrically more variables </span>
</li>
<li>Default Value: <span id="numberOfExpansions_default_value">2</span></li>
<li>Lower
                Bound: <span id="numberOfExpansions_lower_bound">1</span></li>
<li>Upper Bound: <span id="numberOfExpansions_upper_bound">1000</span></li>
<li>Value Type:
                <span id="numberOfExpansions_value_type">Integer</span></li>
</ul>


=== numberResampling ===
<h3 class="parameter_description" id="numberResampling">numberResampling</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="numberResampling_short_desc">The number of bootstraps/resampling
        iterations (min = 0)</span></li>
<li>Long Description: <span id="numberResampling_long_desc"> For bootstrapping, the number of
        bootstrap iterations that should be done by the algorithm, with
        results summarized.</span></li>
<li>Default Value: <span id="numberResampling_default_value">0</span></li>
<li>Lower Bound:
                <span id="numberResampling_lower_bound">0</span></li>
<li>Upper
                Bound: <span id="numberResampling_upper_bound">2147483647</span></li>
<li>Value Type: <span id="numberResampling_value_type">Integer</span></li>
</ul>


=== numBscBootstrapSamples ===
<h3 class="parameter_description" id="numBscBootstrapSamples">numBscBootstrapSamples</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="numBscBootstrapSamples_short_desc"> The number of bootstrappings
        drawing from posterior dist. (min = 1)</span></li>
<li>Long
                Description: <span id="numBscBootstrapSamples_long_desc"> The number
        of bootstrappings drawing from posterior dist. (min = 1)</span></li>
<li>Default Value: <span id="numBscBootstrapSamples_default_value">50</span></li>
<li>Lower
                Bound: <span id="numBscBootstrapSamples_lower_bound">1</span></li>
<li>Upper Bound: <span id="numBscBootstrapSamples_upper_bound">2147483647</span></li>
<li>Value Type: <span id="numBscBootstrapSamples_value_type">Integer</span></li>
</ul>


=== numCategories ===
<h3 class="parameter_description" id="numCategories">numCategories</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="numCategories_short_desc">Number of categories for discrete
        variables (min = 2)</span></li>
<li>Long Description: <span id="numCategories_long_desc"> The number of categories to be used for
        randomly generated discrete variables. The default is 4; the minimum
        is 2.</span></li>
<li>Default Value: <span id="numCategories_default_value">4</span></li>
<li>Lower Bound: <span id="numCategories_lower_bound">2</span></li>
<li>Upper Bound: <span id="numCategories_upper_bound">2147483647</span></li>
<li>Value Type:
                <span id="numCategories_value_type">Integer</span></li>
</ul>


=== numCategoriesToDiscretize ===
<h3 class="parameter_description" id="numCategoriesToDiscretize">numCategoriesToDiscretize</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="numCategoriesToDiscretize_short_desc"> The number of categories
        used to discretize continuous variables, if necessary (min =
        2)</span></li>
<li>Long Description: <span id="numCategoriesToDiscretize_long_desc"> In case the exact algorithm
        is not used for discrete children and continuous parents is not used,
        this parameter gives the number of categories to use for this
        second (discretize) backup copy of the continuous variables. </span>
</li>
<li>Default Value: <span id="numCategoriesToDiscretize_default_value">3</span></li>
<li>Lower
                Bound: <span id="numCategoriesToDiscretize_lower_bound">2</span></li>
<li>Upper Bound: <span id="numCategoriesToDiscretize_upper_bound">2147483647</span></li>
<li>Value Type: <span id="numCategoriesToDiscretize_value_type">Integer</span></li>
</ul>


=== numLags ===
<h3 class="parameter_description" id="numLags">numLags</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="numLags_short_desc">The number of lags in the time lag
        model</span></li>
<li>Long Description: <span id="numLags_long_desc">
        A time lag model may take variables from previous time steps into
        account. This determines how many steps back these relevant variables
        might go.</span></li>
<li>Default Value: <span id="numLags_default_value">1</span></li>
<li>Lower Bound: <span id="numLags_lower_bound">-2147483648</span></li>
<li>Upper Bound:
                <span id="numLags_upper_bound">2147483647</span></li>
<li>Value Type:
                <span id="numLags_value_type">Integer</span></li>
</ul>


=== numLatents ===
<h3 class="parameter_description" id="numLatents">numLatents</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="numLatents_short_desc">Number of additional latent variables (min
        = 0)</span></li>
<li>Long Description: <span id="numLatents_long_desc"> The number of additional latent
        variables to include in the datasets</span></li>
<li>Default Value:
                <span id="numLatents_default_value">0</span></li>
<li>Lower Bound:
                <span id="numLatents_lower_bound">0</span></li>
<li>Upper Bound:
                <span id="numLatents_upper_bound">2147483647</span></li>
<li>Value
                Type: <span id="numLatents_value_type">Integer</span></li>
</ul>


=== numMeasures ===
<h3 class="parameter_description" id="numMeasures">numMeasures</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="numMeasures_short_desc">Number of measured variables (min =
        1)</span></li>
<li>Long Description: <span id="numMeasures_long_desc"> The number of measured (recorded in data)
        variables to include in the dataset. </span></li>
<li>Default Value:
                <span id="numMeasures_default_value">10</span></li>
<li>Lower Bound:
                <span id="numMeasures_lower_bound">1</span></li>
<li>Upper Bound:
                <span id="numMeasures_upper_bound">2147483647</span></li>
<li>Value
                Type: <span id="numMeasures_value_type">Integer</span></li>
</ul>


=== numRandomizedSearchModels ===
<h3 class="parameter_description" id="numRandomizedSearchModels">numRandomizedSearchModels</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="numRandomizedSearchModels_short_desc">The number of search
        probabilistic model (min = 1)</span></li>
<li>Long Description:
                <span id="numRandomizedSearchModels_long_desc"> The number of search
        probabilistic model (min = 1)</span></li>
<li>Default Value: <span id="numRandomizedSearchModels_default_value">10</span></li>
<li>Lower
                Bound: <span id="numRandomizedSearchModels_lower_bound">1</span></li>
<li>Upper Bound: <span id="numRandomizedSearchModels_upper_bound">2147483647</span></li>
<li>Value Type: <span id="numRandomizedSearchModels_value_type">Integer</span></li>
</ul>


=== numRuns ===
<h3 class="parameter_description" id="numRuns">numRuns</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="numRuns_short_desc">Number of runs (min = 1)</span></li>
<li>Long
                Description: <span id="numRuns_long_desc"> An analysis(randomly pick
        graph, randomly simulate a dataset, run an algorithm on it, look at
        the result) may be run over and over again this many times.</span>
</li>
<li>Default Value: <span id="numRuns_default_value">1</span></li>
<li>Lower Bound: <span id="numRuns_lower_bound">1</span></li>
<li>Upper Bound: <span id="numRuns_upper_bound">2147483647</span></li>
<li>Value Type: <span id="numRuns_value_type">Integer</span></li>
</ul>


=== numStarts ===
<h3 class="parameter_description" id="numStarts">numStarts</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="numStarts_short_desc">The number of restarts, random after the
        first (default 1)</span></li>
<li>Long Description: <span id="numStarts_long_desc"> The number of times the algorithm should
        be started from different initializations. By default, the algorithm
        will be run through at least once using the initialized parameters
        (zero random restarts).</span></li>
<li>Default Value: <span id="numStarts_default_value">1</span></li>
<li>Lower Bound: <span id="numStarts_lower_bound">1</span></li>
<li>Upper Bound: <span id="numStarts_upper_bound">2147483647</span></li>
<li>Value Type:
                <span id="numStarts_value_type">Integer</span></li>
</ul>


=== numSub-samples ===
<h3 class="parameter_description" id="numSub-samples">numSub-samples</h3>
<ul class="numSub-samples_list">
<li>Short Description: <span id="numSub-samples_short_desc">Number of
        sub-samples</span></li>
<li>Long Description: <span id="numSub-samples_long_desc">Number of sub-samples</span></li>
<li>Default Value: <span id="numSub-samples_default_value">50</span></li>
<li>Lower Bound:
                <span id="numSub-samples_lower_bound">1</span></li>
<li>Upper Bound:
                <span id="numSub-samples_upper_bound">500000</span></li>
<li>Value
                Type: <span id="numSub-samples_value_type">Integer</span></li>
</ul>


=== numSubsamples ===
<h3 class="parameter_description" id="numSubsamples">numSubsamples</h3>
<ul class="numSubsamples_list">
<li>Short Description: <span id="numSubsamples_short_desc">
                The number of subsamples to generate.
            </span></li>
<li>Long Description: <span id="numSubsamples_long_desc">
           		CStaR works by generating subsamples and summarizing across them; this
           		specified the number of subsamples to generate. Must be &gt;= 1.
                effects in the CStaR table </span></li>
<li>Default Value: <span id="numSubsamples_default_value">10</span></li>
<li>Lower
                Bound: <span id="numSubsamples_lower_bound">1</span></li>
<li>Upper Bound: <span id="numSubsamples_upper_bound">100000</span></li>
<li>Value Type:
                <span id="numSubsamples_value_type">Integer</span></li>
</ul>


=== numThreads ===
<h3 class="parameter_description" id="numThreads">numThreads</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="numThreads_short_desc">The number of threads (&gt;= 1) to use for the search</span></li>
<li>Long Description: <span id="numThreads_long_desc">The number of threads to use for the search.</span>
</li>
<li>Default Value: <span id="numThreads_default_value">1</span></li>
<li>Lower
                Bound: <span id="numThreads_lower_bound">1</span></li>
<li>Upper Bound: <span id="numThreads_upper_bound">1000000</span></li>
<li>Value Type:
                <span id="numThreads_value_type">Integer</span></li>
</ul>


=== orientationAlpha ===
<h3 class="parameter_description" id="orientationAlpha">orientationAlpha</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="orientationAlpha_short_desc"> Alpha threshold used for
        orientation (where necessary). ('0' turns this off.)</span></li>
<li>Long Description: <span id="orientationAlpha_long_desc">Used for
        orienting 2-cycles and testing for zero edges.</span></li>
<li>Default Value: <span id="orientationAlpha_default_value">0.0</span></li>
<li>Lower Bound:
                <span id="orientationAlpha_lower_bound">0.0</span></li>
<li>Upper
                Bound: <span id="orientationAlpha_upper_bound">1.0</span></li>
<li>Value Type: <span id="orientationAlpha_value_type">Double</span></li>
</ul>


=== orientTowardMConnections ===
<h3 class="parameter_description" id="orientTowardMConnections">orientTowardMConnections</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="orientTowardMConnections_short_desc">Yes if Richardson's step C
        (orient toward d-connection) should be used</span></li>
<li>Long
                Description: <span id="orientTowardMConnections_long_desc"> Please
        see the description of this algorithm in Thomas Richardson and Peter
        Spirtes in Chapter 7 of Computation, Causation, &amp; Discovery by
        Glymour and Cooper eds.</span></li>
<li>Default Value: <span id="orientTowardMConnections_default_value">true</span></li>
<li>Lower Bound: <span id="orientTowardMConnections_lower_bound"></span></li>
<li>Upper
                Bound: <span id="orientTowardMConnections_upper_bound"></span></li>
<li>Value Type: <span id="orientTowardMConnections_value_type">Boolean</span></li>
</ul>


=== orientVisibleFeedbackLoops ===
<h3 class="parameter_description" id="orientVisibleFeedbackLoops">orientVisibleFeedbackLoops</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="orientVisibleFeedbackLoops_short_desc">Yes if visible feedback
        loops should be oriented</span></li>
<li>Long Description: <span id="orientVisibleFeedbackLoops_long_desc"> Please see the description
        of this algorithm in Thomas Richardson and Peter Spirtes in Chapter 7
        of Computation, Causation, &amp; Discovery by Glymour and Cooper
        eds.</span></li>
<li>Default Value: <span id="orientVisibleFeedbackLoops_default_value">true</span></li>
<li>Lower Bound: <span id="orientVisibleFeedbackLoops_lower_bound"></span></li>
<li>Upper
                Bound: <span id="orientVisibleFeedbackLoops_upper_bound"></span></li>
<li>Value Type: <span id="orientVisibleFeedbackLoops_value_type">Boolean</span></li>
</ul>


=== otherPermMethod ===
<h3 class="parameter_description" id="otherPermMethod">otherPermMethod</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="otherPermMethod_short_desc"> 1 = RCG, 2 = GSP, 3 = ESP, 4 =
        SP</span></li>
<li>Long Description: <span id="otherPermMethod_long_desc"> RCG (Random Carnival Game); GSP
        ("Greedy SP") GSP using tucking ESP ("Edge SP") is from Solus et al.
        SP ("Sparsest Permutation") Raskutti and Uhler </span></li>
<li>Default Value: <span id="otherPermMethod_default_value">1</span></li>
<li>Lower Bound:
                <span id="otherPermMethod_lower_bound">1</span></li>
<li>Upper Bound:
                <span id="otherPermMethod_upper_bound">5</span></li>
<li>Value Type:
                <span id="otherPermMethod_value_type">Integer</span></li>
</ul>


=== outputCpdag ===
<h3 class="parameter_description" id="outputCpdag">outputCpdag</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="outputCpdag_short_desc">Yes if CPDAG should be output, no if a
        DAG.</span></li>
<li>Long Description: <span id="outputCpdag_long_desc">BOSS can output a DAG or the CPDAG of the
        DAG.</span></li>
<li>Default Value: <span id="outputCpdag_default_value">true</span></li>
<li>Lower Bound:
                <span id="outputCpdag_lower_bound"></span></li>
<li>Upper Bound:
                <span id="outputCpdag_upper_bound"></span></li>
<li>Value Type: <span id="outputCpdag_value_type">Boolean</span></li>
</ul>


=== outputRBD ===
<h3 class="parameter_description" id="outputRBD">outputRBD</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="outputRBD_short_desc"> Constraint Scoring: Yes: Dependent
        Scoring, No: Independent Scoring.</span></li>
<li>Long Description:
                <span id="outputRBD_long_desc"> Constraint Scoring: Yes: Dependent
        Scoring, No: Independent Scoring.</span></li>
<li>Default Value:
                <span id="outputRBD_default_value">true</span></li>
<li>Lower Bound:
                <span id="outputRBD_lower_bound"></span></li>
<li>Upper Bound: <span id="outputRBD_upper_bound"></span></li>
<li>Value Type: <span id="outputRBD_value_type">Boolean</span></li>
</ul>


=== parallelized ===
<h3 class="parameter_description" id="parallelized">parallelized</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="parallelized_short_desc">
                    Yes if the search should be parallelized</span></li>
<li>Long Description: <span id="parallelized_long_desc">This search is capable of being
                    parallelized; select yes if the search should be parallelized,
                    not if it should be run in a single thread</span></li>
<li>Default Value:
                <span id="parallelized_default_value">false</span></li>
<li>Lower Bound:
                <span id="parallelized_lower_bound"></span></li>
<li>Upper Bound:
                <span id="parallelized_upper_bound"></span></li>
<li>Value
                Type: <span id="parallelized_value_type">Boolean</span></li>
</ul>


=== pathsMaxDistanceFromEndpoint ===
<h3 class="parameter_description" id="pathsMaxDistanceFromEndpoint">pathsMaxDistanceFromEndpoint</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="pathsMaxDistanceFromEndpoint_short_desc">
                The maximum distance of an allowable node from the endpoint of a path
                for adjustment
        	</span></li>
<li>Long
                Description: <span id="pathsMaxDistanceFromEndpoint_long_desc">
                In order to give guidance to which adjustment sets to report, this
                parameter lets one give a maximum distance from the endpoint of a
                path for a node to be included in an adjustment set.
        </span></li>
<li>Default Value:
                <span id="pathsMaxDistanceFromEndpoint_default_value">3</span></li>
<li>Lower
                Bound: <span id="pathsMaxDistanceFromEndpoint_lower_bound">0</span></li>
<li>Upper Bound: <span id="pathsMaxDistanceFromEndpoint_upper_bound">100000</span></li>
<li>Value Type:
                <span id="pathsMaxDistanceFromEndpoint_value_type">Integer</span></li>
</ul>


=== pathsMaxLength ===
<h3 class="parameter_description" id="pathsMaxLength">pathsMaxLength</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="pathsMaxLength_short_desc">
                The maximum length of a path to report
        	</span></li>
<li>Long
                Description: <span id="pathsMaxLength_long_desc">
                Since paths may be long, especially for large graphs, this parameter
                allows one to limit the length of a path to report. It must be at least
                2.
        </span></li>
<li>Default Value:
                <span id="pathsMaxLength_default_value">8</span></li>
<li>Lower
                Bound: <span id="pathsMaxLength_lower_bound">2</span></li>
<li>Upper Bound: <span id="pathsMaxLength_upper_bound">100000</span></li>
<li>Value Type:
                <span id="pathsMaxLength_value_type">Integer</span></li>
</ul>


=== pathsMaxLengthAdjustment ===
<h3 class="parameter_description" id="pathsMaxLengthAdjustment">pathsMaxLengthAdjustment</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="pathsMaxLengthAdjustment_short_desc">
                The maximum length of a backdoor path to consider for adjustment.
        	</span></li>
<li>Long
                Description: <span id="pathsMaxLengthAdjustment_long_desc">
                The maximum length of a backdoor path to consider for finding an
                adjustment set. Amenable paths of any length are considered.
        </span></li>
<li>Default Value:
                <span id="pathsMaxLengthAdjustment_default_value">8</span></li>
<li>Lower
                Bound: <span id="pathsMaxLengthAdjustment_lower_bound">2</span></li>
<li>Upper Bound: <span id="pathsMaxLengthAdjustment_upper_bound">100000</span></li>
<li>Value Type:
                <span id="pathsMaxLengthAdjustment_value_type">Integer</span></li>
</ul>


=== pathsMaxNumSets ===
<h3 class="parameter_description" id="pathsMaxNumSets">pathsMaxNumSets</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="pathsMaxNumSets_short_desc">
                The maximum number of adjustment sets to output
        	</span></li>
<li>Long
                Description: <span id="pathsMaxNumSets_long_desc">
                There may be too many legal adjustments to sets to output; this places
                a bound on how many to output. These will be listed in order of
                increasing size.
        </span></li>
<li>Default Value:
                <span id="pathsMaxNumSets_default_value">4</span></li>
<li>Lower
                Bound: <span id="pathsMaxNumSets_lower_bound">0</span></li>
<li>Upper Bound: <span id="pathsMaxNumSets_upper_bound">100000</span></li>
<li>Value Type:
                <span id="pathsMaxNumSets_value_type">Integer</span></li>
</ul>


=== pathsNearWhichEndpoint ===
<h3 class="parameter_description" id="pathsNearWhichEndpoint">pathsNearWhichEndpoint</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="pathsNearWhichEndpoint_short_desc">
                1 = near source, 2 = near target, 3 = near either
        	</span></li>
<li>Long
                Description: <span id="pathsNearWhichEndpoint_long_desc">
                Adjustment sets may be found near the source, near the target, or
                near either.
        </span></li>
<li>Default Value:
                <span id="pathsNearWhichEndpoint_default_value">1</span></li>
<li>Lower
                Bound: <span id="pathsNearWhichEndpoint_lower_bound">1</span></li>
<li>Upper Bound: <span id="pathsNearWhichEndpoint_upper_bound">3</span></li>
<li>Value Type:
                <span id="pathsNearWhichEndpoint_value_type">Integer</span></li>
</ul>


=== pcHeuristic ===
<h3 class="parameter_description" id="pcHeuristic">pcHeuristic</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="pcHeuristic_short_desc">
                Heuristics to stabilize skeleton: 0 = None, 1 = Heuristic 1, 2 = Heuristic 2, 3 = Heuristic 3
            </span></li>
<li>Long Description: <span id="pcHeuristic_long_desc">
                NONE = no heuristic, PC-1 = sort nodes alphabetically;
                PC-1 = sort edges by p-value; PC-3 = additionally sort edges in reverse order
                using p-values of associated independence facts. See CPS.
            </span></li>
<li>Default Value: <span id="pcHeuristic_default_value">0</span></li>
<li>Lower Bound: <span id="pcHeuristic_lower_bound">0</span></li>
<li>Upper Bound: <span id="pcHeuristic_upper_bound">3</span></li>
<li>Value Type: <span id="pcHeuristic_value_type">Integer</span></li>
</ul>


=== penaltyDiscount ===
<h3 class="parameter_description" id="penaltyDiscount">penaltyDiscount</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="penaltyDiscount_short_desc">Penalty discount (min =
        0.0)</span></li>
<li>Long Description: <span id="penaltyDiscount_long_desc"> The parameter c added to a modified
        BIC score of the form 2L – c k ln N, where L is the likelihood, k the
        number of degrees of freedom, and N the sample size. Higher c yield
        sparser graphs. </span></li>
<li>Default Value: <span id="penaltyDiscount_default_value">2.0</span></li>
<li>Lower Bound:
                <span id="penaltyDiscount_lower_bound">0.0</span></li>
<li>Upper
                Bound: <span id="penaltyDiscount_upper_bound">1.7976931348623157E308</span></li>
<li>Value Type: <span id="penaltyDiscount_value_type">Double</span></li>
</ul>


=== penaltyDiscountZs ===
<h3 class="parameter_description" id="penaltyDiscountZs">penaltyDiscountZs</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="penaltyDiscountZs_short_desc">Penalty discount (min =
        0.0)</span></li>
<li>Long Description: <span id="penaltyDiscountZs_long_desc"> The parameter c added to a modified
        BIC score of the form 2L – c k lambda, where L is the likelihood, k the
        number of degrees of freedom, and lambda the choice of GIC lambda. Higher c yield
        sparser graphs. </span></li>
<li>Default Value: <span id="penaltyDiscountZs_default_value">1.0</span></li>
<li>Lower Bound:
                <span id="penaltyDiscountZs_lower_bound">0.0</span></li>
<li>Upper
                Bound: <span id="penaltyDiscountZs_upper_bound">1.7976931348623157E308</span></li>
<li>Value Type: <span id="penaltyDiscountZs_value_type">Double</span></li>
</ul>


=== percentDiscrete ===
<h3 class="parameter_description" id="percentDiscrete">percentDiscrete</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="percentDiscrete_short_desc">Percentage of discrete variables (0 -
        100) for mixed data</span></li>
<li>Long Description: <span id="percentDiscrete_long_desc"> For a mixed data type simulation,
        specifies the percentage of variables that should be simulated
        (randomly) as discrete. The rest will be taken to be continuous. The
        default is 0—i.e. no discrete variables.</span></li>
<li>Default
                Value: <span id="percentDiscrete_default_value">50.0</span></li>
<li>Lower Bound: <span id="percentDiscrete_lower_bound">0.0</span></li>
<li>Upper Bound:
                <span id="percentDiscrete_upper_bound">100.0</span></li>
<li>Value
                Type: <span id="percentDiscrete_value_type">Double</span></li>
</ul>


=== percentResampleSize ===
<h3 class="parameter_description" id="percentResampleSize">percentResampleSize</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="percentResampleSize_short_desc">The percentage of resample size
        (min = 10%)</span></li>
<li>Long Description: <span id="percentResampleSize_long_desc"> This parameter specifies the
        percentage of records in the bootstrap (as a percentage of the total
        original sample size of the data being bootstrapped).</span></li>
<li>Default Value: <span id="percentResampleSize_default_value">100</span></li>
<li>Lower
                Bound: <span id="percentResampleSize_lower_bound">10</span></li>
<li>Upper Bound: <span id="percentResampleSize_upper_bound">100</span></li>
<li>Value
                Type: <span id="percentResampleSize_value_type">Integer</span></li>
</ul>


=== piThr ===
<h3 class="parameter_description" id="piThr">piThr</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="piThr_short_desc">A fixed threshold for calculating E[V] and PCER</span></li>
<li>Long Description: <span id="piThr_long_desc"> A fixed threshold, default 0.5 </span>
</li>
<li>Default Value: <span id="piThr_default_value">0.6</span></li>
<li>Lower
                Bound: <span id="piThr_lower_bound">0</span></li>
<li>Upper Bound: <span id="piThr_upper_bound">1</span></li>
<li>Value Type:
                <span id="piThr_value_type">Double</span></li>
</ul>


=== poissonLambda ===
<h3 class="parameter_description" id="poissonLambda">poissonLambda</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="poissonLambda_short_desc">Lambda parameter for the Poisson distribution
        (&gt; 0)</span></li>
<li>Long Description: <span id="poissonLambda_long_desc"> Lambda parameter for the Poisson distribution</span></li>
<li>Default Value: <span id="poissonLambda_default_value">1</span></li>
<li>Lower
                Bound: <span id="poissonLambda_lower_bound">1e-10</span></li>
<li>Upper Bound: <span id="poissonLambda_upper_bound">Infinity</span></li>
<li>Value
                Type: <span id="poissonLambda_value_type">Double</span></li>
</ul>


=== polynomialConstant ===
<h3 class="parameter_description" id="polynomialConstant">polynomialConstant</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="polynomialConstant_short_desc">
                    For polynomial kernel: The constant
                    </span></li>
<li>Long Description: <span id="polynomialConstant_long_desc">
                    The constant of the polynomial kernel, if used, which
                    determine tradeoff between higher and lower order terms
        </span></li>
<li>Default Value: <span id="polynomialConstant_default_value">1</span></li>
<li>Lower Bound: <span id="polynomialConstant_lower_bound">0</span></li>
<li>Upper Bound: <span id="polynomialConstant_upper_bound">5000</span></li>
<li>Value Type: <span id="polynomialConstant_value_type">Double</span></li>
</ul>


=== polynomialDegree ===
<h3 class="parameter_description" id="polynomialDegree">polynomialDegree</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="polynomialDegree_short_desc">
                    For polynomial kernel: The degree
                    </span></li>
<li>Long Description: <span id="polynomialDegree_long_desc">
                    The degree of the polynomial kernel, if used
        </span></li>
<li>Default Value: <span id="polynomialDegree_default_value">2</span></li>
<li>Lower Bound: <span id="polynomialDegree_lower_bound">1</span></li>
<li>Upper Bound: <span id="polynomialDegree_upper_bound">5000000</span></li>
<li>Value Type: <span id="polynomialDegree_value_type">Double</span></li>
</ul>


=== precomputeCovariances ===
<h3 class="parameter_description" id="precomputeCovariances">precomputeCovariances</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="precomputeCovariances_short_desc">True if covariance matrix should
                	be precomputed for tabular continuous data</span></li>
<li>Long Description:
                <span id="precomputeCovariances_long_desc">
                For more than 5000 variables or so, set this to false in order to calculate covariances
                on the fly from data.
        </span></li>
<li>Default Value:
                <span id="precomputeCovariances_default_value">true</span></li>
<li>Lower Bound:
                <span id="precomputeCovariances_lower_bound"></span></li>
<li>Upper Bound: <span id="precomputeCovariances_upper_bound"></span></li>
<li>Value Type: <span id="precomputeCovariances_value_type">Boolean</span></li>
</ul>


=== preserveMarkov ===
<h3 class="parameter_description" id="preserveMarkov">preserveMarkov</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="preserveMarkov_short_desc">
                    Preserve the Markov property (checking MBs) if initial graph is Markov
        </span></li>
<li>Long Description: <span id="preserveMarkov_long_desc">
                The Markov property checking MBs says that if msep(x, y | MB(x)) then x _||_ y | MB(x).
                Checking true for this property will tell the algorithm to ensure
                this property if the scoring step produces a Markov graph. Not applicable
                when running the algorithm from Oracle.
        </span></li>
<li>Default Value: <span id="preserveMarkov_default_value">false</span></li>
<li>Lower Bound: <span id="preserveMarkov_lower_bound"></span></li>
<li>Upper
                Bound: <span id="preserveMarkov_upper_bound"></span></li>
<li>Value
                Type: <span id="preserveMarkov_value_type">Boolean</span></li>
</ul>


=== priorEquivalentSampleSize ===
<h3 class="parameter_description" id="priorEquivalentSampleSize">priorEquivalentSampleSize</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="priorEquivalentSampleSize_short_desc">Prior equivalent sample
        size (min = 1.0)</span></li>
<li>Long Description: <span id="priorEquivalentSampleSize_long_desc"> This sets the prior
        equivalent sample size. This number is added to the sample size for
        each conditional probability table in the model and is divided
        equally among the cells in the table. </span></li>
<li>Default
                Value: <span id="priorEquivalentSampleSize_default_value">10.0</span></li>
<li>Lower Bound: <span id="priorEquivalentSampleSize_lower_bound">1.0</span>
</li>
<li>Upper Bound:
                <span id="priorEquivalentSampleSize_upper_bound">1.7976931348623157E308</span>
</li>
<li>Value Type:
                <span id="priorEquivalentSampleSize_value_type">Double</span>
</li>
</ul>


=== probabilityOfEdge ===
<h3 class="parameter_description" id="probabilityOfEdge">probabilityOfEdge</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="probabilityOfEdge_short_desc"> Probability of an adjacency being
        included in the graph</span></li>
<li>Long Description: <span id="probabilityOfEdge_long_desc"> Every possible adjacency in the
        graph is included it the graph with this probability. </span></li>
<li>Default Value: <span id="probabilityOfEdge_default_value">0.05</span></li>
<li>Lower
                Bound: <span id="probabilityOfEdge_lower_bound">0.0</span></li>
<li>Upper Bound: <span id="probabilityOfEdge_upper_bound">1.0</span></li>
<li>Value Type:
                <span id="probabilityOfEdge_value_type">Double</span></li>
</ul>


=== probCycle ===
<h3 class="parameter_description" id="probCycle">probCycle</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="probCycle_short_desc">The probability of adding a cycle to the
        graph</span></li>
<li>Long Description: <span id="probCycle_long_desc"> Sets the probability that any particular
        set of 3, 4, or 5 of nodes will be used to form a cycle in the
        graph.</span></li>
<li>Default Value: <span id="probCycle_default_value">1.0</span></li>
<li>Lower Bound: <span id="probCycle_lower_bound">0.0</span></li>
<li>Upper Bound: <span id="probCycle_upper_bound">1.0</span></li>
<li>Value Type: <span id="probCycle_value_type">Double</span></li>
</ul>


=== probRemoveColumn ===
<h3 class="parameter_description" id="probRemoveColumn">probRemoveColumn</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="probRemoveColumn_short_desc">Probability of randomly removing a column from a dataset</span>
</li>
<li>Long
                Description: <span id="probRemoveColumn_long_desc">
                	For testing algorithms with overlapping variables, columns may be removed
                	from datasets with this probability.
        		</span>
</li>
<li>Default Value: <span id="probRemoveColumn_default_value">0.0</span></li>
<li>Lower Bound: <span id="probRemoveColumn_lower_bound">0.0</span></li>
<li>Upper Bound: <span id="probRemoveColumn_upper_bound">1.0</span></li>
<li>Value Type: <span id="probRemoveColumn_value_type">Double</span></li>
</ul>


=== probTwoCycle ===
<h3 class="parameter_description" id="probTwoCycle">probTwoCycle</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="probTwoCycle_short_desc">The probability of creating a 2-cycles
        in the graph (0 - 1)</span></li>
<li>Long Description: <span id="probTwoCycle_long_desc"> Any edge X*-*Y may be replaced with a
        2-cycle (feedback loop) between X and Y with this probability.</span>
</li>
<li>Default Value: <span id="probTwoCycle_default_value">0.0</span></li>
<li>Lower Bound:
                <span id="probTwoCycle_lower_bound">0.0</span></li>
<li>Upper Bound:
                <span id="probTwoCycle_upper_bound">1.0</span></li>
<li>Value Type:
                <span id="probTwoCycle_value_type">Double</span></li>
</ul>


=== randomizeColumns ===
<h3 class="parameter_description" id="randomizeColumns">randomizeColumns</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="randomizeColumns_short_desc">Yes if the order of the columns in
        each dataset should be randomized</span></li>
<li>Long Description:
                <span id="randomizeColumns_long_desc"> In the real world where
        unfaithfulness is an issue the order of variables in the data may for
        some algorithms affect the output. For testing purposes, if Yes, the
        data columns are randomly re-ordered.</span></li>
<li>Default Value:
                <span id="randomizeColumns_default_value">true</span></li>
<li>Lower
                Bound: <span id="randomizeColumns_lower_bound"></span></li>
<li>Upper
                Bound: <span id="randomizeColumns_upper_bound"></span></li>
<li>Value
                Type: <span id="randomizeColumns_value_type">Boolean</span></li>
</ul>


=== randomSelectionSize ===
<h3 class="parameter_description" id="randomSelectionSize">randomSelectionSize</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="randomSelectionSize_short_desc">The number of datasets that
        should be taken in each random sample</span></li>
<li>Long
                Description: <span id="randomSelectionSize_long_desc"> The number of
        dataset that should be taken in each random sample of
        datasets.</span></li>
<li>Default Value: <span id="randomSelectionSize_default_value">1</span></li>
<li>Lower Bound:
                <span id="randomSelectionSize_lower_bound">-2147483648</span></li>
<li>Upper Bound: <span id="randomSelectionSize_upper_bound">2147483647</span></li>
<li>Value
                Type: <span id="randomSelectionSize_value_type">Integer</span></li>
</ul>


=== rcit.approx ===
<h3 class="parameter_description" id="rcit.approx">rcit.approx</h3>
<ul class="parameter_description_list">
<li>Short Description:
                <span id="rcit.approx_short_desc">
                Null approximation method: 1 = LpB4, 2 = HBE, 3 = Gamma, 4 = Chi², 5 = Permutation
            </span>
</li>
<li>Long Description:
                <span id="rcit.approx_long_desc">
                    1 = Lindsay–Pilla–Basak (LpB4) 2 = Hall–Buckley–Eagleson (HBE)
                    3 = Gamma (Satterthwaite–Welch) 4 = Chi² (normalized)
                    5 = Permutation test (slower, more accurate for small samples)</span></li>
<li>Default Value: <span id="rcit.approx_default_value">1</span></li>
<li>Lower Bound: <span id="rcit.approx_lower_bound">1</span></li>
<li>Upper Bound: <span id="rcit.approx_upper_bound">5</span></li>
<li>Value Type: <span id="rcit.approx_value_type">Integer</span></li>
</ul>


=== rcit.centerFeatures ===
<h3 class="parameter_description" id="rcit.centerFeatures">rcit.centerFeatures</h3>
<ul class="parameter_description_list">
<li>Short Description:
                <span id="rcit.centerFeatures_short_desc">Center feature matrices</span>
</li>
<li>Long Description:
                <span id="rcit.centerFeatures_long_desc">
                  If true, center random-feature matrices before regression and test-statistic computation.
                  Recommended for numerical stability and alignment with kernelized formulations.
                </span>
</li>
<li>Default Value: <span id="rcit.centerFeatures_default_value">true</span></li>
<li>Lower Bound: <span id="rcit.centerFeatures_lower_bound"></span></li>
<li>Upper Bound: <span id="rcit.centerFeatures_upper_bound"></span></li>
<li>Value Type: <span id="rcit.centerFeatures_value_type">Boolean</span></li>
</ul>


=== rcit.lambda ===
<h3 class="parameter_description" id="rcit.lambda">rcit.lambda</h3>
<ul class="parameter_description_list">
<li>Short Description:
                <span id="rcit.lambda_short_desc">Ridge regularization (λ)</span>
</li>
<li>Long Description:
                <span id="rcit.lambda_long_desc">
                Ridge penalty used when residualizing feature maps of <i>X</i> and <i>Y</i> against <i>Z</i>.
                Prevents ill-conditioning when <i>Z</i> features are collinear.
        </span>
</li>
<li>Default Value: <span id="rcit.lambda_default_value">0.001</span></li>
<li>Lower Bound: <span id="rcit.lambda_lower_bound">0.0</span></li>
<li>Upper Bound: <span id="rcit.lambda_upper_bound">1.7976931348623157E308</span></li>
<li>Value Type: <span id="rcit.lambda_value_type">Double</span></li>
</ul>


=== rcit.numFeaturesXY ===
<h3 class="parameter_description" id="rcit.numFeaturesXY">rcit.numFeaturesXY</h3>
<ul class="parameter_description_list">
<li>Short Description:
                <span id="rcit.numFeaturesXY_short_desc">Random Fourier features for X and Y</span>
</li>
<li>Long Description:
                <span id="rcit.numFeaturesXY_long_desc">
              Number of random Fourier features for the tested variables <i>X</i> and <i>Y</i>.
              Small values (e.g., 3–10) often suffice; increasing improves power but adds cost.
            </span>
</li>
<li>Default Value: <span id="rcit.numFeaturesXY_default_value">5</span></li>
<li>Lower Bound: <span id="rcit.numFeaturesXY_lower_bound">1</span></li>
<li>Upper Bound: <span id="rcit.numFeaturesXY_upper_bound">2147483647</span></li>
<li>Value Type: <span id="rcit.numFeaturesXY_value_type">Integer</span></li>
</ul>


=== rcit.numFeaturesZ ===
<h3 class="parameter_description" id="rcit.numFeaturesZ">rcit.numFeaturesZ</h3>
<ul class="parameter_description_list">
<li>Short Description:
                <span id="rcit.numFeaturesZ_short_desc">Random Fourier features for Z</span>
</li>
<li>Long Description:
                <span id="rcit.numFeaturesZ_long_desc">
                  Number of random Fourier features used to represent the conditioning set <i>Z</i>.
                  Larger values are more accurate but slower; values in the 50–300 range are typical.
                </span>
</li>
<li>Default Value: <span id="rcit.numFeaturesZ_default_value">100</span></li>
<li>Lower Bound: <span id="rcit.numFeaturesZ_lower_bound">1</span></li>
<li>Upper Bound: <span id="rcit.numFeaturesZ_upper_bound">2147483647</span></li>
<li>Value Type: <span id="rcit.numFeaturesZ_value_type">Integer</span></li>
</ul>


=== rcit.permutations ===
<h3 class="parameter_description" id="rcit.permutations">rcit.permutations</h3>
<ul class="parameter_description_list">
<li>Short Description:
                <span id="rcit.permutations_short_desc">Permutations for "perm" approx</span>
</li>
<li>Long Description:
                <span id="rcit.permutations_long_desc">
                  Number of permutations used when <code>rcit.approx = "perm"</code>.
                  Ignored for analytic approximations (<code>lpd4</code>, <code>hbe</code>, <code>gamma</code>, <code>chi2</code>).
                </span>
</li>
<li>Default Value: <span id="rcit.permutations_default_value">500</span></li>
<li>Lower Bound: <span id="rcit.permutations_lower_bound">1</span></li>
<li>Upper Bound: <span id="rcit.permutations_upper_bound">2147483647</span></li>
<li>Value Type: <span id="rcit.permutations_value_type">Integer</span></li>
</ul>


=== rcit.rcitMode ===
<h3 class="parameter_description" id="rcit.rcitMode">rcit.rcitMode</h3>
<ul class="parameter_description_list">
<li>Short Description:
                <span id="rcit.rcitMode_short_desc">Use RCIT (true) or RCoT (false)</span>
</li>
<li>Long Description:
                <span id="rcit.rcitMode_long_desc">
      Chooses between the two randomized kernel tests:
      <b>RCIT</b> augments <i>Y</i> with <i>Z</i> features (tests <i>X ⟂ Y,Z | Z</i>),
      while <b>RCoT</b> uses only <i>X</i> and <i>Y</i> features with residualization against <i>Z</i>.
      In the original RCIT code base this switch is exposed as <code>rcit=True/False</code>.
    </span>
</li>
<li>Default Value: <span id="rcit.rcitMode_default_value">true</span></li>
<li>Lower Bound: <span id="rcit.rcitMode_lower_bound"></span></li>
<li>Upper Bound: <span id="rcit.rcitMode_upper_bound"></span></li>
<li>Value Type: <span id="rcit.rcitMode_value_type">Boolean</span></li>
</ul>


=== rcitNumFeatures ===
<h3 class="parameter_description" id="rcitNumFeatures">rcitNumFeatures</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="rcitNumFeatures_short_desc">The number of random features to
        use</span></li>
<li>Long Description: <span id="rcitNumFeatures_long_desc"></span></li>
<li>Default Value: <span id="rcitNumFeatures_default_value">10</span></li>
<li>Lower Bound:
                <span id="rcitNumFeatures_lower_bound">1</span></li>
<li>Upper Bound:
                <span id="rcitNumFeatures_upper_bound">2147483647</span></li>
<li>Value Type: <span id="rcitNumFeatures_value_type">Integer</span></li>
</ul>


=== recursive ===
<h3 class="parameter_description" id="recursive">recursive</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="recursive_short_desc">Yes if the algorithm should proceed
        recursively, no if not</span></li>
<li>Long Description: <span id="recursive_long_desc"> Where recursive or nonrecursive variants of
        an algorithm are available, this selects which one to use.</span>
</li>
<li>Default Value: <span id="recursive_default_value">false</span></li>
<li>Lower Bound: <span id="recursive_lower_bound"></span></li>
<li>Upper Bound: <span id="recursive_upper_bound"></span></li>
<li>Value Type: <span id="recursive_value_type">Boolean</span></li>
</ul>


=== regularizationLambda ===
<h3 class="parameter_description" id="regularizationLambda">regularizationLambda</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="regularizationLambda_short_desc">
                    Small number &gt;= 0 Add lambda to the the diagonal of
                    correlation/covariance matrices. Default 1e-8.
        </span></li>
<li>Long Description: <span id="regularizationLambda_long_desc">
                    Small number &gt;= 0 Add lambda to the the diagonal of
                    correlation/covariance matricers. Default 1e-8.
         </span></li>
<li>Default Value: <span id="regularizationLambda_default_value">1e-8</span></li>
<li>Lower Bound: <span id="regularizationLambda_lower_bound">0</span></li>
<li>Upper
                Bound: <span id="regularizationLambda_upper_bound">Infinity</span></li>
<li>Value
                Type: <span id="regularizationLambda_value_type">Double</span></li>
</ul>


=== removeAlmostCycles ===
<h3 class="parameter_description" id="removeAlmostCycles">removeAlmostCycles</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="removeAlmostCycles_short_desc">
                    Yes if almost-cycles should be removed from the PAG.
        </span></li>
<li>Long Description: <span id="removeAlmostCycles_long_desc">
                    When x &lt;-&gt; y, x ~~&gt; y, removes any unshielded triples into x and
                    rebuilds the PAG.
        </span></li>
<li>Default Value: <span id="removeAlmostCycles_default_value">false</span></li>
<li>Lower Bound: <span id="removeAlmostCycles_lower_bound"></span></li>
<li>Upper
                Bound: <span id="removeAlmostCycles_upper_bound"></span></li>
<li>Value
                Type: <span id="removeAlmostCycles_value_type">Boolean</span></li>
</ul>


=== removeEffectNodes ===
<h3 class="parameter_description" id="removeEffectNodes">removeEffectNodes</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="removeEffectNodes_short_desc">True if effect nodes should bre removed from possible causes </span>
</li>
<li>Long Description: <span id="removeEffectNodes_long_desc">True if effect nodes should be removed from possible causes </span>
</li>
<li>Default Value: <span id="removeEffectNodes_default_value">true</span></li>
<li>Lower
                Bound: <span id="removeEffectNodes_lower_bound"></span></li>
<li>Upper Bound: <span id="removeEffectNodes_upper_bound"></span></li>
<li>Value Type:
                <span id="removeEffectNodes_value_type">Boolean</span></li>
</ul>


=== resamplingEnsemble ===
<h3 class="parameter_description" id="resamplingEnsemble">resamplingEnsemble</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="resamplingEnsemble_short_desc">Ensemble method: Preserved (1),
        Highest (2), Majority (3)</span></li>
<li>Long Description: <span id="resamplingEnsemble_long_desc"> Preserved = keep the highest frequency
        edges; Highest = keep the highest frequency edges but ignore the no edge
        case if maximal; Majority = keep edges only if their frequency is
        greater than 0.5. </span></li>
<li>Default Value: <span id="resamplingEnsemble_default_value">1</span></li>
<li>Lower Bound:
                <span id="resamplingEnsemble_lower_bound">1</span></li>
<li>Upper
                Bound: <span id="resamplingEnsemble_upper_bound">3</span></li>
<li>Value Type: <span id="resamplingEnsemble_value_type">Integer</span></li>
</ul>


=== resamplingWithReplacement ===
<h3 class="parameter_description" id="resamplingWithReplacement">resamplingWithReplacement</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="resamplingWithReplacement_short_desc">Yes, if sampling with
        replacement (bootstrapping)</span></li>
<li>Long Description: <span id="resamplingWithReplacement_long_desc"> Yes if resampling can be
        done with replacement, No if not. or without replacement. If with
        replacement, it is possible to have more than one copy of some of the
        records in the original dataset being included in the
        bootstrap.</span></li>
<li>Default Value: <span id="resamplingWithReplacement_default_value">true</span></li>
<li>Lower Bound: <span id="resamplingWithReplacement_lower_bound"></span></li>
<li>Upper
                Bound: <span id="resamplingWithReplacement_upper_bound"></span></li>
<li>Value Type: <span id="resamplingWithReplacement_value_type">Boolean</span></li>
</ul>


=== resolveAlmostCyclicPaths ===
<h3 class="parameter_description" id="resolveAlmostCyclicPaths">resolveAlmostCyclicPaths</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="resolveAlmostCyclicPaths_short_desc">
                    True just in case almost cyclic paths should be resolved in the
                    direction of the cycle.
                </span></li>
<li>Long Description: <span id="resolveAlmostCyclicPaths_long_desc">
                    If true we resolved &lt;-&gt; edges as --&gt; if there is a directed path x~~&gt;y.
                    </span>
</li>
<li>Default Value: <span id="resolveAlmostCyclicPaths_default_value">false</span></li>
<li>Lower
                Bound: <span id="resolveAlmostCyclicPaths_lower_bound"></span></li>
<li>Upper Bound: <span id="resolveAlmostCyclicPaths_upper_bound"></span></li>
<li>Value Type:
                <span id="resolveAlmostCyclicPaths_value_type">Boolean</span></li>
</ul>


=== sampleSize ===
<h3 class="parameter_description" id="sampleSize">sampleSize</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="sampleSize_short_desc">Sample size (min = 1)</span></li>
<li>Long
                Description: <span id="sampleSize_long_desc"> Determines now many
        records should be generated for the data. The minimum number of
        records is 1; the default is set to 1000.</span></li>
<li>Default
                Value: <span id="sampleSize_default_value">1000</span></li>
<li>Lower
                Bound: <span id="sampleSize_lower_bound">1</span></li>
<li>Upper
                Bound: <span id="sampleSize_upper_bound">2147483647</span></li>
<li>Value Type: <span id="sampleSize_value_type">Integer</span></li>
</ul>


=== saveBootstrapGraphs ===
<h3 class="parameter_description" id="saveBootstrapGraphs">saveBootstrapGraphs</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="saveBootstrapGraphs_short_desc">Yes if individual bootstrapping
                    graphs should be saved</span></li>
<li>Long Description: <span id="saveBootstrapGraphs_long_desc"> Bootstrapping provides a summary
                    over individual search graphs; select Yes here if these individual
                    graphs should be saved</span>
</li>
<li>Default Value: <span id="saveBootstrapGraphs_default_value">false</span></li>
<li>Lower
                Bound: <span id="saveBootstrapGraphs_lower_bound"></span></li>
<li>Upper Bound: <span id="saveBootstrapGraphs_upper_bound"></span></li>
<li>Value Type:
                <span id="saveBootstrapGraphs_value_type">Boolean</span></li>
</ul>


=== saveLatentVars ===
<h3 class="parameter_description" id="saveLatentVars">saveLatentVars</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="saveLatentVars_short_desc">Save latent variables.</span></li>
<li>Long Description: <span id="saveLatentVars_long_desc"> Yes if one
        wishes to have values for latent variables saved out with the rest of
        the data; No if only data for the measured variables should be
        saved.</span></li>
<li>Default Value: <span id="saveLatentVars_default_value">false</span></li>
<li>Lower Bound:
                <span id="saveLatentVars_lower_bound"></span></li>
<li>Upper Bound:
                <span id="saveLatentVars_upper_bound"></span></li>
<li>Value Type:
                <span id="saveLatentVars_value_type">Boolean</span></li>
</ul>


=== scaleFreeAlpha ===
<h3 class="parameter_description" id="scaleFreeAlpha">scaleFreeAlpha</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="scaleFreeAlpha_short_desc">For scale-free graphs, the parameter
        alpha (min = 0.0)</span></li>
<li>Long Description: <span id="scaleFreeAlpha_long_desc"> We use the algorithm for generating
        scale free graphs described in B. Bollobas,C. Borgs, J. Chayes, and
        O. Riordan (2003). Please see this article for a description of the
        parameters.</span></li>
<li>Default Value: <span id="scaleFreeAlpha_default_value">0.05</span></li>
<li>Lower Bound:
                <span id="scaleFreeAlpha_lower_bound">0.0</span></li>
<li>Upper
                Bound: <span id="scaleFreeAlpha_upper_bound">1.0</span></li>
<li>Value Type: <span id="scaleFreeAlpha_value_type">Double</span></li>
</ul>


=== scaleFreeBeta ===
<h3 class="parameter_description" id="scaleFreeBeta">scaleFreeBeta</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="scaleFreeBeta_short_desc">For scale-free graphs, the parameter
        beta (min = 0.0)</span></li>
<li>Long Description: <span id="scaleFreeBeta_long_desc"> We use the algorithm for generating
        scale free graphs described in B. Bollobas,C. Borgs, J. Chayes, and
        O. Riordan (2003). Please see this article for a description of the
        parameters.</span></li>
<li>Default Value: <span id="scaleFreeBeta_default_value">0.9</span></li>
<li>Lower Bound:
                <span id="scaleFreeBeta_lower_bound">0.0</span></li>
<li>Upper Bound:
                <span id="scaleFreeBeta_upper_bound">1.0</span></li>
<li>Value Type:
                <span id="scaleFreeBeta_value_type">Double</span></li>
</ul>


=== scaleFreeDeltaIn ===
<h3 class="parameter_description" id="scaleFreeDeltaIn">scaleFreeDeltaIn</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="scaleFreeDeltaIn_short_desc">For scale-free graphs, the parameter
        delta_in (min = 0.0)</span></li>
<li>Long Description: <span id="scaleFreeDeltaIn_long_desc"> We use the algorithm for generating
        scale free graphs described in B. Bollobas,C. Borgs, J. Chayes, and
        O. Riordan (2003). Please see this article for a description of the
        parameters.</span></li>
<li>Default Value: <span id="scaleFreeDeltaIn_default_value">3</span></li>
<li>Lower Bound:
                <span id="scaleFreeDeltaIn_lower_bound">-2147483648</span></li>
<li>Upper Bound: <span id="scaleFreeDeltaIn_upper_bound">2147483647</span></li>
<li>Value
                Type: <span id="scaleFreeDeltaIn_value_type">Integer</span></li>
</ul>


=== scaleFreeDeltaOut ===
<h3 class="parameter_description" id="scaleFreeDeltaOut">scaleFreeDeltaOut</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="scaleFreeDeltaOut_short_desc">For scale-free graphs, the
        parameter delta_out (min = 0.0)</span></li>
<li>Long Description:
                <span id="scaleFreeDeltaOut_long_desc"> We use the algorithm for
        generating scale free graphs described in B. Bollobas,C. Borgs, J.
        Chayes, and O. Riordan (2003). Please see this article for a
        description of the parameters.</span></li>
<li>Default Value: <span id="scaleFreeDeltaOut_default_value">3</span></li>
<li>Lower Bound:
                <span id="scaleFreeDeltaOut_lower_bound">-2147483648</span></li>
<li>Upper Bound: <span id="scaleFreeDeltaOut_upper_bound">2147483647</span></li>
<li>Value
                Type: <span id="scaleFreeDeltaOut_value_type">Integer</span></li>
</ul>


=== scalingFactor ===
<h3 class="parameter_description" id="scalingFactor">scalingFactor</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="scalingFactor_short_desc">Scaling factor.</span>
</li>
<li>Long
                Description: <span id="scalingFactor_long_desc">
                    For Gaussian kernel: The scaling factor.
                </span></li>
<li>Default Value: <span id="scalingFactor_default_value">1.0</span></li>
<li>Lower Bound:
                <span id="scalingFactor_lower_bound">4.9E-324</span></li>
<li>Upper Bound: <span id="scalingFactor_upper_bound">Infinity</span></li>
<li>Value
                Type: <span id="scalingFactor_value_type">Double</span></li>
</ul>


=== seed ===
<h3 class="parameter_description" id="seed">seed</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="seed_short_desc">Seed for pseudorandom number generator (-1 = off)</span></li>
<li>Long Description: <span id="seed_long_desc">The seed is the initial value of the
                    internal state of the pseudorandom number generator. A value of -1
                skips setting a new seed.</span></li>
<li>Default Value: <span id="seed_default_value">-1</span></li>
<li>Lower Bound:
                <span id="seed_lower_bound">-1</span></li>
<li>Upper
                Bound: <span id="seed_upper_bound">9223372036854775807</span></li>
<li>Value Type: <span id="seed_value_type">Long</span></li>
</ul>


=== selectionMinEffect ===
<h3 class="parameter_description" id="selectionMinEffect">selectionMinEffect</h3>
<ul class="selectionMinEffect_list">
<li>Short Description: <span id="selectionMinEffect_short_desc"> Minimum effect size for listing
        effects in the CStaR table </span></li>
<li>Long Description: <span id="selectionMinEffect_long_desc"> Minimum effect size for listing
        effects in the CStaR table </span></li>
<li>Default Value: <span id="selectionMinEffect_default_value">0.0</span></li>
<li>Lower
                Bound: <span id="selectionMinEffect_lower_bound">0.0</span></li>
<li>Upper Bound: <span id="selectionMinEffect_upper_bound">1.0</span></li>
<li>Value Type:
                <span id="selectionMinEffect_value_type">Double</span></li>
</ul>


=== selfLoopCoef ===
<h3 class="parameter_description" id="selfLoopCoef">selfLoopCoef</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="selfLoopCoef_short_desc">The coefficient for the self-loop
        (default 0.0)</span></li>
<li>Long Description: <span id="selfLoopCoef_long_desc"> For simulating time series data, each
        variable depends on itself one time-step back with a linear edge that
        has this coefficient.</span></li>
<li>Default Value: <span id="selfLoopCoef_default_value">0.0</span></li>
<li>Lower Bound:
                <span id="selfLoopCoef_lower_bound">0.0</span></li>
<li>Upper Bound:
                <span id="selfLoopCoef_upper_bound">Infinity</span></li>
<li>Value
                Type: <span id="selfLoopCoef_value_type">Double</span></li>
</ul>


=== semBicRule ===
<h3 class="parameter_description" id="semBicRule">semBicRule</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="semBicRule_short_desc"> Lambda: 1 = Chickering, 2 = Nandy</span>
</li>
<li>Long Description: <span id="semBicRule_long_desc">The
        Chickering Rule uses the difference of BIC scores to add or remove
        edges. The Nandy et al. rule uses a single calculation of a partial
        correlation in place of the likelihood difference. </span></li>
<li>Default Value: <span id="semBicRule_default_value">1</span></li>
<li>Lower Bound: <span id="semBicRule_lower_bound">1</span></li>
<li>Upper Bound: <span id="semBicRule_upper_bound">2</span></li>
<li>Value Type: <span id="semBicRule_value_type">Integer</span></li>
</ul>


=== semBicStructurePrior ===
<h3 class="parameter_description" id="semBicStructurePrior">semBicStructurePrior</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="semBicStructurePrior_short_desc">Structure Prior for SEM BIC
        (default 0)</span></li>
<li>Long Description: <span id="semBicStructurePrior_long_desc"> Structure prior; default is 0
        (turned off); may be any positive number otherwise</span></li>
<li>Default Value: <span id="semBicStructurePrior_default_value">0</span></li>
<li>Lower
                Bound: <span id="semBicStructurePrior_lower_bound">0</span></li>
<li>Upper Bound: <span id="semBicStructurePrior_upper_bound">Infinity</span></li>
<li>Value
                Type: <span id="semBicStructurePrior_value_type">Double</span></li>
</ul>


=== semGicRule ===
<h3 class="parameter_description" id="semGicRule">semGicRule</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="semGicRule_short_desc"> Lambda: 1 = ln n, 2 = pn^1/3, 3 = 2 ln
        pn, 4 = 2(ln pn + ln ln pn), 5 = ln ln n ln pn, 6 = ln n ln pn, 7 =
        Manual</span></li>
<li>Long Description: <span id="semGicRule_long_desc">The rule used for calculating the lambda
        term of the score. We follow Kim, Y., Kwon, S., &amp; Choi, H. (2012) and
        articles referenced therein. For high-dimensional data. </span></li>
<li>Default Value: <span id="semGicRule_default_value">4</span></li>
<li>Lower Bound: <span id="semGicRule_lower_bound">1</span></li>
<li>Upper Bound: <span id="semGicRule_upper_bound">7</span></li>
<li>Value Type: <span id="semGicRule_value_type">Integer</span></li>
</ul>


=== semImSimulationType ===
<h3 class="parameter_description" id="semImSimulationType">semImSimulationType</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="semImSimulationType_short_desc">Yes if recursive simulation, No
        if reduced form simulation</span></li>
<li>Long Description: <span id="semImSimulationType_long_desc"> Determines the type of simulation
        done. If recursive, the graph must be a DAG in causal order. "Reduced
        form" means X = (I - B)^-1 e, which requires a possibly large matrix
        inversion.</span></li>
<li>Default Value: <span id="semImSimulationType_default_value">true</span></li>
<li>Lower
                Bound: <span id="semImSimulationType_lower_bound"></span></li>
<li>Upper Bound: <span id="semImSimulationType_upper_bound"></span></li>
<li>Value Type:
                <span id="semImSimulationType_value_type">Boolean</span></li>
</ul>


=== sepsetFinderMethod ===
<h3 class="parameter_description" id="sepsetFinderMethod">sepsetFinderMethod</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="sepsetFinderMethod_short_desc">
					The method to use for finding sepsets, 1 = Greedy, 2 = Min-p, 3 = Max-p (default).        </span>
</li>
<li>Long Description: <span id="sepsetFinderMethod_long_desc">
					The method to use for finding sepsets, 1 = Greedy, 2 = Min-p, 3 = Max-p (default).        </span>
</li>
<li>Default Value: <span id="sepsetFinderMethod_default_value">3</span></li>
<li>Lower Bound: <span id="sepsetFinderMethod_lower_bound">1</span></li>
<li>Upper
                Bound: <span id="sepsetFinderMethod_upper_bound">3</span></li>
<li>Value
                Type: <span id="sepsetFinderMethod_value_type">Integer</span></li>
</ul>


=== shrinkageMode ===
<h3 class="parameter_description" id="shrinkageMode">shrinkageMode</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="shrinkageMode_short_desc">
                    Shrinkage Mode: 1 = None 2 = Ridge 3 = Ledoit-Wolf
        </span></li>
<li>Long Description: <span id="shrinkageMode_long_desc">
                    Shrinkage Mode: 1 = None 2 = Ridge 3 = Ledoit-Wolf
         </span></li>
<li>Default Value: <span id="shrinkageMode_default_value">1</span></li>
<li>Lower Bound: <span id="shrinkageMode_lower_bound">1</span></li>
<li>Upper
                Bound: <span id="shrinkageMode_upper_bound">3</span></li>
<li>Value
                Type: <span id="shrinkageMode_value_type">Integer</span></li>
</ul>


=== significanceChecked ===
<h3 class="parameter_description" id="significanceChecked">significanceChecked</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="significanceChecked_short_desc">
                    True if the significance of the cluster should be checked.
                    </span></li>
<li>Long Description: <span id="significanceChecked_long_desc">
            True if the significance of clusters should be checked, false if not.
            </span></li>
<li>Default Value: <span id="significanceChecked_default_value">false</span></li>
<li>Lower Bound: <span id="significanceChecked_lower_bound"></span></li>
<li>Upper Bound: <span id="significanceChecked_upper_bound"></span></li>
<li>Value
                Type: <span id="significanceChecked_value_type">Boolean</span></li>
</ul>


=== simulationErrorType ===
<h3 class="parameter_description" id="simulationErrorType">simulationErrorType</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="simulationErrorType_short_desc"> 1 = Usual LG SEM, 2 =
        U(lb, ub), 3 = Exp(lambda), 4 = Gumbel(mu,
        beta), 5 = Gamma(shape, scale)</span></li>
<li>Long Description: <span id="simulationErrorType_long_desc">Exogenous error type</span></li>
<li>Default Value: <span id="simulationErrorType_default_value">1</span></li>
<li>Lower Bound:
                <span id="simulationErrorType_lower_bound">1</span></li>
<li>Upper
                Bound: <span id="simulationErrorType_upper_bound">5</span></li>
<li>Value Type: <span id="simulationErrorType_value_type">Integer</span></li>
</ul>


=== simulationParam1 ===
<h3 class="parameter_description" id="simulationParam1">simulationParam1</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="simulationParam1_short_desc"> Indep error parameter
        #1</span></li>
<li>Long Description: <span id="simulationParam1_long_desc">Exogenous error parameter
        #1</span></li>
<li>Default Value: <span id="simulationParam1_default_value">0.0</span></li>
<li>Lower Bound:
                <span id="simulationParam1_lower_bound">-1000</span></li>
<li>Upper
                Bound: <span id="simulationParam1_upper_bound">1000</span></li>
<li>Value Type: <span id="simulationParam1_value_type">Double</span></li>
</ul>


=== simulationParam2 ===
<h3 class="parameter_description" id="simulationParam2">simulationParam2</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="simulationParam2_short_desc"> Indep error parameter #2, if
        used</span></li>
<li>Long Description: <span id="simulationParam2_long_desc">Exogenous error parameter
        #2</span></li>
<li>Default Value: <span id="simulationParam2_default_value">1.0</span></li>
<li>Lower Bound:
                <span id="simulationParam2_lower_bound">-1000</span></li>
<li>Upper
                Bound: <span id="simulationParam2_upper_bound">1000</span></li>
<li>Value Type: <span id="simulationParam2_value_type">Double</span></li>
</ul>


=== singularityLambda ===
<h3 class="parameter_description" id="singularityLambda">singularityLambda</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="singularityLambda_short_desc">
                    Singularities: Small number &gt;= 0 Add lambda to the the diagonal, &lt; 0 Pseudoinverse
        </span></li>
<li>Long Description: <span id="singularityLambda_long_desc">
                    Singularities: Small number &gt;= 0 Add lambda to the the diagonal, &lt; 0 Pseudoinverse
         </span></li>
<li>Default Value: <span id="singularityLambda_default_value">0.0</span></li>
<li>Lower Bound: <span id="singularityLambda_lower_bound">-Infinity</span></li>
<li>Upper
                Bound: <span id="singularityLambda_upper_bound">Infinity</span></li>
<li>Value
                Type: <span id="singularityLambda_value_type">Double</span></li>
</ul>


=== skewEdgeThreshold ===
<h3 class="parameter_description" id="skewEdgeThreshold">skewEdgeThreshold</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="skewEdgeThreshold_short_desc">Threshold for including additional
        edges detectable by skewness</span></li>
<li>Long Description: <span id="skewEdgeThreshold_long_desc"> For FASK, this includes an
        adjacency X—Y in the model if |corr(X, Y | X &gt; 0) – corr(X, Y | Y &gt;
        0)| exceeds some threshold. The default for this threshold is
        0.3.</span></li>
<li>Default Value: <span id="skewEdgeThreshold_default_value">0.3</span></li>
<li>Lower Bound:
                <span id="skewEdgeThreshold_lower_bound">0.0</span></li>
<li>Upper
                Bound: <span id="skewEdgeThreshold_upper_bound">Infinity</span></li>
<li>Value Type: <span id="skewEdgeThreshold_value_type">Double</span></li>
</ul>


=== skipNumRecords ===
<h3 class="parameter_description" id="skipNumRecords">skipNumRecords</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="skipNumRecords_short_desc">Number of records that should be
        skipped between recordings (min = 0)</span></li>
<li>Long
                Description: <span id="skipNumRecords_long_desc"> Data recordings are
        made every this many steps.</span></li>
<li>Default Value: <span id="skipNumRecords_default_value">0</span></li>
<li>Lower Bound:
                <span id="skipNumRecords_lower_bound">0</span></li>
<li>Upper Bound:
                <span id="skipNumRecords_upper_bound">2147483647</span></li>
<li>Value Type: <span id="skipNumRecords_value_type">Integer</span></li>
</ul>


=== stableFAS ===
<h3 class="parameter_description" id="stableFAS">stableFAS</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="stableFAS_short_desc">
                Yes if the Colombo et al. 'stable' FAS should be done, to
                avoid skeleton order dependency
            </span></li>
<li>Long Description: <span id="stableFAS_long_desc"> If Yes, the "stable" version of the PC
        adjacency search is used, which for k &gt; 0 fixes the graph for depth k
        + 1 to that of the previous depth k. </span></li>
<li>Default Value:
                <span id="stableFAS_default_value">true</span></li>
<li>Lower Bound:
                <span id="stableFAS_lower_bound"></span></li>
<li>Upper Bound: <span id="stableFAS_upper_bound"></span></li>
<li>Value Type: <span id="stableFAS_value_type">Boolean</span></li>
</ul>


=== standardize ===
<h3 class="parameter_description" id="standardize">standardize</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="standardize_short_desc">Yes if the data should be
        standardized</span></li>
<li>Long Description: <span id="standardize_long_desc"> Yes if each variable in the data should
        be standardized to have mean zero and variance 1. </span></li>
<li>Default Value: <span id="standardize_default_value">false</span></li>
<li>Lower Bound:
                <span id="standardize_lower_bound"></span></li>
<li>Upper Bound:
                <span id="standardize_upper_bound"></span></li>
<li>Value Type: <span id="standardize_value_type">Boolean</span></li>
</ul>


=== startFromCompleteGraph ===
<h3 class="parameter_description" id="startFromCompleteGraph">startFromCompleteGraph</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="startFromCompleteGraph_short_desc">
                    Yes, if the procedure should start from a complete graph
        </span></li>
<li>Long Description: <span id="startFromCompleteGraph_long_desc">
                    Yes, if the procedure should start from a complete graph
        </span></li>
<li>Default Value: <span id="startFromCompleteGraph_default_value">false</span></li>
<li>Lower Bound: <span id="startFromCompleteGraph_lower_bound"></span></li>
<li>Upper
                Bound: <span id="startFromCompleteGraph_upper_bound"></span></li>
<li>Value
                Type: <span id="startFromCompleteGraph_value_type">Boolean</span></li>
</ul>


=== structurePrior ===
<h3 class="parameter_description" id="structurePrior">structurePrior</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="structurePrior_short_desc">Structure prior coefficient (min =
        0.0)</span></li>
<li>Long Description: <span id="structurePrior_long_desc"> The default number of parents for any
        conditional probability table. Higher weight is accorded to tables
        with about that number of parents. The prior structure weights are
        distributed according to a binomial distribution.</span></li>
<li>Default Value: <span id="structurePrior_default_value">0.0</span></li>
<li>Lower Bound:
                <span id="structurePrior_lower_bound">0.0</span></li>
<li>Upper Bound:
                <span id="structurePrior_upper_bound">1.7976931348623157E308</span></li>
<li>Value Type: <span id="structurePrior_value_type">Double</span></li>
</ul>


=== symmetricFirstStep ===
<h3 class="parameter_description" id="symmetricFirstStep">symmetricFirstStep</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="symmetricFirstStep_short_desc"> Yes if the first step for
        FGES should do scoring for both X-&gt;Y and Y-&gt;X</span></li>
<li>Long
                Description: <span id="symmetricFirstStep_long_desc"> If Yes, scores
        for both X-&gt;Y and X&lt;-Y will be calculated and the higher score
        used.</span></li>
<li>Default Value: <span id="symmetricFirstStep_default_value">false</span></li>
<li>Lower
                Bound: <span id="symmetricFirstStep_lower_bound"></span></li>
<li>Upper Bound: <span id="symmetricFirstStep_upper_bound"></span></li>
<li>Value Type:
                <span id="symmetricFirstStep_value_type">Boolean</span></li>
</ul>


=== takeLogs ===
<h3 class="parameter_description" id="takeLogs">takeLogs</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="takeLogs_short_desc">Yes logs should be taken, No if not</span>
</li>
<li>Long Description: <span id="takeLogs_long_desc"> The
        formula for the score allows a log to be taken optionally in the
        information term.</span></li>
<li>Default Value: <span id="takeLogs_default_value">true</span></li>
<li>Lower Bound: <span id="takeLogs_lower_bound"></span></li>
<li>Upper Bound: <span id="takeLogs_upper_bound"></span></li>
<li>Value Type: <span id="takeLogs_value_type">Boolean</span></li>
</ul>


=== targetName ===
<h3 class="parameter_description" id="targetName">targetName</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="targetName_short_desc">Target variable name</span></li>
<li>Long
                Description: <span id="targetName_long_desc"> The name of the target
        variables--for Markov blanket searches, this is the name of the
        variable for which one wants the Markov blanket or Markov blanket
        graph. </span></li>
<li>Default Value: <span id="targetName_default_value"></span></li>
<li>Lower Bound: <span id="targetName_lower_bound"></span></li>
<li>Upper Bound: <span id="targetName_upper_bound"></span></li>
<li>Value Type: <span id="targetName_value_type">String</span></li>
</ul>


=== targets ===
<h3 class="parameter_description" id="targets">targets</h3>
<ul class="targets_list">
<li>Short Description: <span id="targets_short_desc">Target names
        (comma or space separated)</span></li>
<li>Long Description: <span id="targets_long_desc">Target names (comma or space separated).</span>
</li>
<li>Default Value: <span id="targets_default_value"></span></li>
<li>Lower Bound: <span id="targets_lower_bound"></span></li>
<li>Upper Bound: <span id="targets_upper_bound"></span></li>
<li>Value Type: <span id="targets_value_type">String</span></li>
</ul>


=== testTimeout ===
<h3 class="parameter_description" id="testTimeout">testTimeout</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="testTimeout_short_desc">
                    Timeout for tests in milliseconds, or -1 if no timeout.
        </span></li>
<li>Long Description: <span id="testTimeout_long_desc">
                    Timeout for tests in milliseconds, or -1 if no timeout.
                </span></li>
<li>Default Value: <span id="testTimeout_default_value">-1</span></li>
<li>Lower Bound: <span id="testTimeout_lower_bound">-1</span></li>
<li>Upper Bound: <span id="testTimeout_upper_bound">9223372036854775807</span></li>
<li>Value Type: <span id="testTimeout_value_type">Long</span></li>
</ul>
<ul class="parameter_description_list">
<li>Short Description:
                <span id="breakTies_short_desc">Yes if the algorithm should try
        moving variables pairwise</span></li>
<li>Long Description: <span id="breakTies_long_desc"> In some cases, two moves are required
        simultaneously to get an orientation right in the final step. This is
        not generally needed when optimizing using BIC or for large
        models.</span></li>
<li>Default Value: <span id="breakTies_default_value">true</span></li>
<li>Lower Bound: <span id="breakTies_lower_bound"></span></li>
<li>Upper Bound: <span id="breakTies_upper_bound"></span></li>
<li>Value Type: <span id="breakTies_value_type">Boolean</span></li>
</ul>


=== tetrad_test_bpc ===
<h3 class="parameter_description" id="tetrad_test_bpc">tetrad_test_bpc</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="tetrad_test_bpc_short_desc">
                The tetrad test used: 1 = Wishart, 2 = Delta (Bollen-Ting)
                </span></li>
<li>Long Description:
                <span id="tetrad_test_bpc_long_desc">
                The tetrad test used: 1 = Wishart, 2 = Delta
        		</span></li>
<li>Default Value: <span id="tetrad_test_bpc_default_value">2</span></li>
<li>Lower Bound:
                <span id="tetrad_test_bpc_lower_bound">1</span></li>
<li>Upper Bound: <span id="tetrad_test_bpc_upper_bound">2</span></li>
<li>Value Type: <span id="tetrad_test_bpc_value_type">Integer</span></li>
</ul>


=== tetrad_test_fofc ===
<h3 class="parameter_description" id="tetrad_test_fofc">tetrad_test_fofc</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="tetrad_test_fofc_short_desc">
                The tetrad test used: 1 = CCA, 2 = Bollen-Ting, 3 = Wishart
                </span></li>
<li>Long Description:
                <span id="tetrad_test_fofc_long_desc">
                The tetrad test used: 1 = CCA, 2 = Bollen-Ting, 3 = Wishart
        		</span></li>
<li>Default Value: <span id="tetrad_test_fofc_default_value">1</span></li>
<li>Lower Bound:
                <span id="tetrad_test_fofc_lower_bound">1</span></li>
<li>Upper Bound: <span id="tetrad_test_fofc_upper_bound">4</span></li>
<li>Value Type: <span id="tetrad_test_fofc_value_type">Integer</span></li>
</ul>


=== thr ===
<h3 class="parameter_description" id="thr">thr</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="thr_short_desc">THR parameter (GLASSO) (min = 0.0)</span></li>
<li>Long Description: <span id="thr_long_desc"> Sets the maximum
        number of iterations of the optimization loop.</span></li>
<li>Default Value: <span id="thr_default_value">1.0E-4</span></li>
<li>Lower Bound: <span id="thr_lower_bound">0.0</span></li>
<li>Upper
                Bound: <span id="thr_upper_bound">1.7976931348623157E308</span></li>
<li>Value Type: <span id="thr_value_type">Double</span></li>
</ul>


=== thresholdBHat ===
<h3 class="parameter_description" id="thresholdBHat">thresholdBHat</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="thresholdBHat_short_desc">Threshold on the B Hat matrix.
        </span></li>
<li>Long Description: <span id="thresholdBHat_long_desc">The estimated B matrix
                    is thresholded by setting small entries less than this threshold
                    to zero.</span>
</li>
<li>Default Value: <span id="thresholdBHat_default_value">0.1</span></li>
<li>Lower Bound:
                <span id="thresholdBHat_lower_bound">0.0</span></li>
<li>Upper
                Bound: <span id="thresholdBHat_upper_bound">Infinity</span></li>
<li>Value Type: <span id="thresholdBHat_value_type">Double</span></li>
</ul>


=== thresholdForNumEigenvalues ===
<h3 class="parameter_description" id="thresholdForNumEigenvalues">thresholdForNumEigenvalues</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="thresholdForNumEigenvalues_short_desc"> Threshold to determine
        how many eigenvalues to use--the lower the more (0 to 1)</span></li>
<li>Long Description: <span id="thresholdForNumEigenvalues_long_desc"> Referring to Zhang, K.,
        Peters, J., Janzing, D., &amp; Schölkopf, B. (2012), this parameter is
        the threshold to determine how many eigenvalues to use--the lower the
        more (0 to 1).</span></li>
<li>Default Value: <span id="thresholdForNumEigenvalues_default_value">0.001</span></li>
<li>Lower Bound: <span id="thresholdForNumEigenvalues_lower_bound">0.0</span></li>
<li>Upper
                Bound: <span id="thresholdForNumEigenvalues_upper_bound">Infinity</span></li>
<li>Value Type: <span id="thresholdForNumEigenvalues_value_type">Double</span></li>
</ul>


=== thresholdNoRandomConstrainSearch ===
<h3 class="parameter_description" id="thresholdNoRandomConstrainSearch">
            thresholdNoRandomConstrainSearch</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="thresholdNoRandomConstrainSearch_short_desc"> Yes, if using the
        cutoff threshold for the meta-constraints independence test (stage
        2).</span></li>
<li>Long Description: <span id="thresholdNoRandomConstrainSearch_long_desc"> Yes, if using the
        cutoff threshold for the meta-constraints independence test (stage
        2).</span></li>
<li>Default Value: <span id="thresholdNoRandomConstrainSearch_default_value">true</span></li>
<li>Lower Bound: <span id="thresholdNoRandomConstrainSearch_lower_bound"></span></li>
<li>Upper Bound: <span id="thresholdNoRandomConstrainSearch_upper_bound"></span></li>
<li>Value Type: <span id="thresholdNoRandomConstrainSearch_value_type">Boolean</span></li>
</ul>


=== thresholdNoRandomDataSearch ===
<h3 class="parameter_description" id="thresholdNoRandomDataSearch">thresholdNoRandomDataSearch</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="thresholdNoRandomDataSearch_short_desc"> Yes, if using the cutoff
        threshold for the constraints independence test (stage 1).</span>
</li>
<li>Long Description: <span id="thresholdNoRandomDataSearch_long_desc">null</span></li>
<li>Default Value: <span id="thresholdNoRandomDataSearch_default_value">false</span></li>
<li>Lower Bound: <span id="thresholdNoRandomDataSearch_lower_bound"></span></li>
<li>Upper
                Bound: <span id="thresholdNoRandomDataSearch_upper_bound"></span></li>
<li>Value
                Type: <span id="thresholdNoRandomDataSearch_value_type">Boolean</span></li>
</ul>


=== thresholdW ===
<h3 class="parameter_description" id="thresholdW">thresholdW</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="thresholdW_short_desc">Threshold on the W matrix.
        </span></li>
<li>Long Description: <span id="thresholdW_long_desc">The estimated W matrix
                    is thresholded by setting small entries less than this threshold
                    to zero.
                    </span>
</li>
<li>Default Value: <span id="thresholdW_default_value">0.1</span></li>
<li>Lower Bound:
                <span id="thresholdW_lower_bound">0.0</span></li>
<li>Upper
                Bound: <span id="thresholdW_upper_bound">Infinity</span></li>
<li>Value Type: <span id="thresholdW_value_type">Double</span></li>
</ul>


=== timeLag ===
<h3 class="parameter_description" id="timeLag">timeLag</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="timeLag_short_desc">
                For time lag searches,`a time lag,
                automatically applied (zero if none)</span></li>
<li>Long Description: <span id="timeLag_long_desc">Automatically applies the time lag
                    transform to the data, creating additional lagged variables. If
                    zero, no time lag is applied. A positive integer</span></li>
<li>Default Value: <span id="timeLag_default_value">0</span></li>
<li>Lower Bound: <span id="timeLag_lower_bound">0</span></li>
<li>Upper
                Bound: <span id="timeLag_upper_bound">2147483647</span></li>
<li>Value Type: <span id="timeLag_value_type">Integer</span></li>
</ul>


=== timeLagReplicatingGraph ===
<h3 class="parameter_description" id="timeLagReplicatingGraph">timeLagReplicatingGraph</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="timeLagReplicatingGraph_short_desc">
                    For time lag searches, whether to make the graph replicate edges across time lags, SVAR-style
        </span></li>
<li>Long Description: <span id="timeLagReplicatingGraph_long_desc">
                    For time lag searches, whether to make the graph replicate edges across time lags, SVAR-style
                    <option class="" value=""></option>
</span></li>
<li>Default Value: <span id="timeLagReplicatingGraph_default_value">false</span></li>
<li>Lower Bound: <span id="timeLagReplicatingGraph_lower_bound"></span></li>
<li>Upper
                Bound: <span id="timeLagReplicatingGraph_upper_bound"></span></li>
<li>Value
                Type: <span id="timeLagReplicatingGraph_value_type">Boolean</span></li>
</ul>


=== timeLimit ===
<h3 class="parameter_description" id="timeLimit">timeLimit</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="timeLimit_short_desc">Time limit</span></li>
<li>Long
                Description: <span id="timeLimit_long_desc">T-Separation requires a
        time limit. Default 1000.</span></li>
<li>Default Value: <span id="timeLimit_default_value">1000.0</span></li>
<li>Lower Bound:
                <span id="timeLimit_lower_bound">0.0</span></li>
<li>Upper Bound:
                <span id="timeLimit_upper_bound">1.7976931348623157E308</span></li>
<li>Value Type: <span id="timeLimit_value_type">Double</span></li>
</ul>


=== timeout ===
<h3 class="parameter_description" id="timeout">timeout</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="timeout_short_desc">Timeout (best graph returned, -1 = no
        timeout)</span></li>
<li>Long Description: <span id="timeout_long_desc"> The algorithm will time out at approximately
        this number of seconds from when it started and return the final
        graph found at that point. </span></li>
<li>Default Value: <span id="timeout_default_value">-1</span></li>
<li>Lower Bound: <span id="timeout_lower_bound">-1</span></li>
<li>Upper Bound: <span id="timeout_upper_bound">2147483647</span></li>
<li>Value Type: <span id="timeout_value_type">Integer</span></li>
</ul>


=== topBracket ===
<h3 class="parameter_description" id="topBracket">topBracket</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="topBracket_short_desc">Top bracket to look for causes in</span></li>
<li>Long
                Description: <span id="topBracket_long_desc">Top bracket, 'q'</span></li>
<li>Default
                Value: <span id="topBracket_default_value">5</span></li>
<li>Lower Bound:
                <span id="topBracket_lower_bound">1</span></li>
<li>Upper Bound: <span id="topBracket_upper_bound">500000</span></li>
<li>Value Type: <span id="topBracket_value_type">Integer</span></li>
</ul>


=== trimmingStyle ===
<h3 class="parameter_description" id="trimmingStyle">trimmingStyle</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="trimmingStyle_short_desc">Trimming Style: 1 = None, 2 = Adjacencies, 3 = MB DAG, 4 = Possibly directed paths</span>
</li>
<li>Long Description: <span id="trimmingStyle_long_desc">'Adjacencies' trims to the adjacencies the targets, MB DAGs to the Union(MB(targets)) U targets,
                potentially directed trims to nodes with potentially directed paths to the targets. </span>
</li>
<li>Default Value: <span id="trimmingStyle_default_value">3</span></li>
<li>Lower
                Bound: <span id="trimmingStyle_lower_bound">1</span></li>
<li>Upper Bound: <span id="trimmingStyle_upper_bound">4</span></li>
<li>Value Type:
                <span id="trimmingStyle_value_type">Integer</span></li>
</ul>


=== trueErrorVariance ===
<h3 class="parameter_description" id="trueErrorVariance">trueErrorVariance</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="trueErrorVariance_short_desc">True error variance</span></li>
<li>Long Description: <span id="trueErrorVariance_long_desc"> The
        true error variance of the model, assuming this is the same for all
        variables.</span></li>
<li>Default Value: <span id="trueErrorVariance_default_value">1.0</span></li>
<li>Lower Bound:
                <span id="trueErrorVariance_lower_bound">0.0</span></li>
<li>Upper
                Bound: <span id="trueErrorVariance_upper_bound">1.7976931348623157E308</span></li>
<li>Value Type: <span id="trueErrorVariance_value_type">Double</span></li>
</ul>


=== truncationLimit ===
<h3 class="parameter_description" id="truncationLimit">truncationLimit</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="truncationLimit_short_desc">Truncation limit for
                    basis functions</span></li>
<li>Long Description: <span id="truncationLimit_long_desc">
                    Basis functions 1 though this number will be used.. The Degenerate Gaussian
                    category indicator variables for mixed data are also used.
         </span></li>
<li>Default Value: <span id="truncationLimit_default_value">3</span></li>
<li>Lower Bound:
                <span id="truncationLimit_lower_bound">1</span></li>
<li>Upper
                Bound: <span id="truncationLimit_upper_bound">1000</span></li>
<li>Value Type: <span id="truncationLimit_value_type">Integer</span></li>
</ul>


=== tscClusterRank ===
<h3 class="parameter_description" id="tscClusterRank">tscClusterRank</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="tscClusterRank_short_desc">
                TSC cluster rank (if desired)
        	</span></li>
<li>Long
                Description: <span id="tscClusterRank_long_desc">
                TSC cluster rank (if desired)
        </span></li>
<li>Default Value:
                <span id="tscClusterRank_default_value">1</span></li>
<li>Lower
                Bound: <span id="tscClusterRank_lower_bound">0</span></li>
<li>Upper Bound: <span id="tscClusterRank_upper_bound">500</span></li>
<li>Value Type:
                <span id="tscClusterRank_value_type">Integer</span></li>
</ul>


=== tscClusterSize ===
<h3 class="parameter_description" id="tscClusterSize">tscClusterSize</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="tscClusterSize_short_desc">
                TSC cluster size (if desired)
        	</span></li>
<li>Long
                Description: <span id="tscClusterSize_long_desc">
                TSC cluster size (if desired)
        </span></li>
<li>Default Value:
                <span id="tscClusterSize_default_value">2</span></li>
<li>Lower
                Bound: <span id="tscClusterSize_lower_bound">0</span></li>
<li>Upper Bound: <span id="tscClusterSize_upper_bound">500</span></li>
<li>Value Type:
                <span id="tscClusterSize_value_type">Integer</span></li>
</ul>


=== tscEnableHierarchy ===
<h3 class="parameter_description" id="tscEnableHierarchy">tscEnableHierarchy</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="tscEnableHierarchy_short_desc">
                    Yes, if hierarchical latents should be detected
        </span></li>
<li>Long Description: <span id="tscEnableHierarchy_long_desc">
                    Yes, if hierarchical latents should be detected
        </span></li>
<li>Default Value: <span id="tscEnableHierarchy_default_value">true</span></li>
<li>Lower Bound: <span id="tscEnableHierarchy_lower_bound"></span></li>
<li>Upper
                Bound: <span id="tscEnableHierarchy_upper_bound"></span></li>
<li>Value
                Type: <span id="tscEnableHierarchy_value_type">Boolean</span></li>
</ul>


=== tscMinRankDrop ===
<h3 class="parameter_description" id="tscMinRankDrop">tscMinRankDrop</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="tscMinRankDrop_short_desc">
                    Min rank drop for detecting hierarchical latents
        </span></li>
<li>Long Description: <span id="tscMinRankDrop_long_desc">
                    Min rank drop for detecting hierarchical latents
        </span></li>
<li>Default Value: <span id="tscMinRankDrop_default_value">1</span></li>
<li>Lower Bound: <span id="tscMinRankDrop_lower_bound">1</span></li>
<li>Upper
                Bound: <span id="tscMinRankDrop_upper_bound">100</span></li>
<li>Value
                Type: <span id="tscMinRankDrop_value_type">Integer</span></li>
</ul>


=== tscMinRedundancy ===
<h3 class="parameter_description" id="tscMinRedundancy">tscMinRedundancy</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="tscMinRedundancy_short_desc">
                Minimum redundancy for clusters beyond size = rank + 1
        	</span></li>
<li>Long
                Description: <span id="tscMinRedundancy_long_desc">
                Minimum redundancy: require at least k extra indicators
                    per latent (|C| ≥ r+1+k). Higher values suppress trivially sized clusters.
        </span></li>
<li>Default Value:
                <span id="tscMinRedundancy_default_value">0</span></li>
<li>Lower
                Bound: <span id="tscMinRedundancy_lower_bound">0</span></li>
<li>Upper Bound: <span id="tscMinRedundancy_upper_bound">1000</span></li>
<li>Value Type:
                <span id="tscMinRedundancy_value_type">Integer</span></li>
</ul>


=== tscMode ===
<h3 class="parameter_description" id="tscMode">tscMode</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="tscMode_short_desc">
                TSC mode: 1 = Metaloop, 2 = Specific size/rank
        	</span></li>
<li>Long
                Description: <span id="tscMode_long_desc">
                TSC mode: 1 = Metaloop, 2 = Specific cluster size/rank
        </span></li>
<li>Default Value:
                <span id="tscMode_default_value">1</span></li>
<li>Lower
                Bound: <span id="tscMode_lower_bound">1</span></li>
<li>Upper Bound: <span id="tscMode_upper_bound">2</span></li>
<li>Value Type:
                <span id="tscMode_value_type">Integer</span></li>
</ul>


=== tscPcUseBoss ===
<h3 class="parameter_description" id="tscPcUseBoss">tscPcUseBoss</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="tscPcUseBoss_short_desc">
                    Yes, if the procedure should use BOSS (with the BOSS-specific parameters) and not PC
        </span></li>
<li>Long Description: <span id="tscPcUseBoss_long_desc">
                    Yes, if the procedure should use BOSS (with the BOSS-specific parameters) and not PC
        </span></li>
<li>Default Value: <span id="tscPcUseBoss_default_value">false</span></li>
<li>Lower Bound: <span id="tscPcUseBoss_lower_bound"></span></li>
<li>Upper
                Bound: <span id="tscPcUseBoss_upper_bound"></span></li>
<li>Value
                Type: <span id="tscPcUseBoss_value_type">Boolean</span></li>
</ul>


=== tscSingletonPolicy ===
<h3 class="parameter_description" id="tscSingletonPolicy">tscSingletonPolicy</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="tscSingletonPolicy_short_desc">
                    Singletons: 1 = Exclude 2 = Include 3 = Collect as Noise
        </span></li>
<li>Long Description: <span id="tscSingletonPolicy_long_desc">
                    Singletons: 1 = Exclude 2 = Include 3 = Collect as Noise
        </span></li>
<li>Default Value: <span id="tscSingletonPolicy_default_value">1</span></li>
<li>Lower Bound: <span id="tscSingletonPolicy_lower_bound">1</span></li>
<li>Upper
                Bound:
                <span4 id="tscSingletonPolicy_upper_bound">3
</span4></li>
<li>Value
                Type: <span id="tscSingletonPolicy_value_type">Integer</span></li>
</ul>


=== twoCycleAlpha ===
<h3 class="parameter_description" id="twoCycleAlpha">twoCycleAlpha</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="twoCycleAlpha_short_desc">Alpha orienting 2-cycles (min =
        0.0)</span></li>
<li>Long Description: <span id="twoCycleAlpha_long_desc"> The alpha level of a T-test used to
        determine where 2-cycles exist in the graph. A value of zero turns
        off 2-cycle detection. </span></li>
<li>Default Value: <span id="twoCycleAlpha_default_value">0.0</span></li>
<li>Lower Bound:
                <span id="twoCycleAlpha_lower_bound">0.0</span></li>
<li>Upper Bound:
                <span id="twoCycleAlpha_upper_bound">1.0</span></li>
<li>Value Type:
                <span id="twoCycleAlpha_value_type">Double</span></li>
</ul>


=== twoCycleScreeningThreshold ===
<h3 class="parameter_description" id="twoCycleScreeningThreshold">twoCycleScreeningThreshold</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="twoCycleScreeningThreshold_short_desc"> Upper bound for
        |left-right| to count as 2-cycle. (Set to zero to turn off
        pre-screening.)</span></li>
<li>Long Description: <span id="twoCycleScreeningThreshold_long_desc"> 2-cycles are screened by
        looking to see if the left-right rule returns a difference smaller
        than this threshold. To turn off the screening, set this to
        zero.</span></li>
<li>Default Value: <span id="twoCycleScreeningThreshold_default_value">0.0</span></li>
<li>Lower Bound: <span id="twoCycleScreeningThreshold_lower_bound">0.0</span></li>
<li>Upper
                Bound: <span id="twoCycleScreeningThreshold_upper_bound">Infinity</span></li>
<li>Value Type: <span id="twoCycleScreeningThreshold_value_type">Double</span></li>
</ul>


=== upperBound ===
<h3 class="parameter_description" id="upperBound">upperBound</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="upperBound_short_desc">Upper bound cutoff threshold</span></li>
<li>Long Description: <span id="upperBound_long_desc">null</span></li>
<li>Default Value: <span id="upperBound_default_value">0.7</span></li>
<li>Lower Bound: <span id="upperBound_lower_bound">0.0</span></li>
<li>Upper Bound: <span id="upperBound_upper_bound">1.0</span></li>
<li>Value Type: <span id="upperBound_value_type">Double</span></li>
</ul>


=== useBes ===
<h3 class="parameter_description" id="useBes">useBes</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="useBes_short_desc">True if the optional BES step should be used</span></li>
<li>Long Description: <span id="useBes_long_desc">This algorithm can use the backward equivalence search
                    from the GES algorithm as one of its steps.</span></li>
<li>Default Value: <span id="useBes_default_value">false</span></li>
<li>Lower Bound: <span id="useBes_lower_bound"></span></li>
<li>Upper Bound: <span id="useBes_upper_bound"></span></li>
<li>Value Type:
                <span id="useBes_value_type">Boolean</span></li>
</ul>


=== useCorrDiffAdjacencies ===
<h3 class="parameter_description" id="useCorrDiffAdjacencies">useCorrDiffAdjacencies</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="useCorrDiffAdjacencies_short_desc">Yes if adjacencies from
        conditional correlation differences should be used</span></li>
<li>Long Description: <span id="useCorrDiffAdjacencies_long_desc">
        FASK can use adjacencies X—Y where |corr(X,Y|X&gt;0) – corr(X,Y|Y&gt;0)| &gt;
        threshold. This expression will be nonzero only if there is a path
        between X and Y; heuristically, if the difference is greater than,
        say, 0.3, we infer an adjacency.</span></li>
<li>Default Value:
                <span id="useCorrDiffAdjacencies_default_value">true</span></li>
<li>Lower Bound: <span id="useCorrDiffAdjacencies_lower_bound"></span></li>
<li>Upper Bound:
                <span id="useCorrDiffAdjacencies_upper_bound"></span></li>
<li>Value
                Type: <span id="useCorrDiffAdjacencies_value_type">Boolean</span></li>
</ul>


=== useDataOrder ===
<h3 class="parameter_description" id="useDataOrder">useDataOrder</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="useDataOrder_short_desc"> Yes just in case data variable
        order should be used for the first initial permutation. </span></li>
<li>Long Description: <span id="useDataOrder_long_desc"> In
        either case, if multiple starting points are used, taking the best
        scoring model from among these, subsequent starting points will all
        be random shuffles. </span></li>
<li>Default Value: <span id="useDataOrder_default_value">true</span></li>
<li>Lower
                Bound: <span id="useDataOrder_lower_bound"></span></li>
<li>Upper Bound: <span id="useDataOrder_upper_bound"></span></li>
<li>Value Type: <span id="useDataOrder_value_type">Boolean</span></li>
</ul>


=== useFasAdjacencies ===
<h3 class="parameter_description" id="useFasAdjacencies">useFasAdjacencies</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="useFasAdjacencies_short_desc">Yes if adjacencies from the FAS
        search (correlation) should be used</span></li>
<li>Long
                Description: <span id="useFasAdjacencies_long_desc"> Determines
        whether adjacencies found by conditional correlation should be
        included in the final model.</span></li>
<li>Default Value: <span id="useFasAdjacencies_default_value">true</span></li>
<li>Lower
                Bound: <span id="useFasAdjacencies_lower_bound"></span></li>
<li>Upper Bound: <span id="useFasAdjacencies_upper_bound"></span></li>
<li>Value Type: <span id="useFasAdjacencies_value_type">Boolean</span></li>
</ul>


=== useGap ===
<h3 class="parameter_description" id="useGap">useGap</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="useGap_short_desc">Yes if the GAP algorithms should be used. Not
        if the SAG algorithm should be used</span></li>
<li>Long
                Description: <span id="useGap_long_desc"> True if one should first
        find all possible initial sets, grows these out, and then picks a
        non-overlapping such largest sets from these. Not if one should grow
        pure clusters one at a time, excluding variables found in earlier
        clusters.</span></li>
<li>Default Value: <span id="useGap_default_value">false</span></li>
<li>Lower Bound: <span id="useGap_lower_bound"></span></li>
<li>Upper Bound: <span id="useGap_upper_bound"></span></li>
<li>Value Type: <span id="useGap_value_type">Boolean</span></li>
</ul>


=== useMaxPHeuristic ===
<h3 class="parameter_description" id="useMaxPHeuristic">useMaxPHeuristic</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="useMaxPHeuristic_short_desc">
                    Yes if the max P heuristic version should be used to search for sepsets
            </span></li>
<li>Long Description: <span id="useMaxPHeuristic_long_desc">
                    Yes if the max P heuristic version should be used to search for sepsets
            </span></li>
<li>Default Value: <span id="useMaxPHeuristic_default_value">false</span></li>
<li>Lower Bound: <span id="useMaxPHeuristic_lower_bound"></span></li>
<li>Upper
                Bound: <span id="useMaxPHeuristic_upper_bound"></span></li>
<li>Value
                Type: <span id="useMaxPHeuristic_value_type">Boolean</span></li>
</ul>


=== useMaxPOrientationHeuristic ===
<h3 class="parameter_description" id="useMaxPOrientationHeuristic">useMaxPOrientationHeuristic</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="useMaxPOrientationHeuristic_short_desc">
                    Use the max p heuristic version
                    </span></li>
<li>Long Description: <span id="useMaxPOrientationHeuristic_long_desc">
                    Use the max p heuristic version
     		</span></li>
<li>Default Value: <span id="useMaxPOrientationHeuristic_default_value">false</span></li>
<li>Lower Bound: <span id="useMaxPOrientationHeuristic_lower_bound"></span></li>
<li>Upper
                Bound: <span id="useMaxPOrientationHeuristic_upper_bound"></span></li>
<li>Value
                Type: <span id="useMaxPOrientationHeuristic_value_type">Boolean</span></li>
</ul>


=== useScore ===
<h3 class="parameter_description" id="useScore">useScore</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="useScore_short_desc">Yes if the score should be used; no if the
        test should be used</span></li>
<li>Long Description: <span id="useScore_long_desc"> BOSS can run either from a score or a test;
        this lets you choose which.</span></li>
<li>Default Value: <span id="useScore_default_value">true</span></li>
<li>Lower Bound: <span id="useScore_lower_bound"></span></li>
<li>Upper Bound: <span id="useScore_upper_bound"></span></li>
<li>Value Type: <span id="useScore_value_type">Boolean</span></li>
</ul>


=== useSkewAdjacencies ===
<h3 class="parameter_description" id="useSkewAdjacencies">useSkewAdjacencies</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="useSkewAdjacencies_short_desc">Yes if adjacencies based on
        skewness should be used</span></li>
<li>Long Description: <span id="useSkewAdjacencies_long_desc"> FASK can use adjacencies X—Y where
        |corr(X,Y|X&gt;0) – corr(X,Y|Y&gt;0)| &gt; threshold. This expression will be
        nonzero only if there is a path between X and Y; heuristically, if
        the difference is greater than, say, 0.3, we infer an adjacency. To
        see adjacencies included for this reason, set this parameter to
        “Yes”. Sanchez-Romero, Ramsey et al., (2018) Network
        Neuroscience.</span></li>
<li>Default Value: <span id="useSkewAdjacencies_default_value">true</span></li>
<li>Lower
                Bound: <span id="useSkewAdjacencies_lower_bound"></span></li>
<li>Upper Bound: <span id="useSkewAdjacencies_upper_bound"></span></li>
<li>Value Type:
                <span id="useSkewAdjacencies_value_type">Boolean</span></li>
</ul>


=== varHigh ===
<h3 class="parameter_description" id="varHigh">varHigh</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="varHigh_short_desc">High end of variance range (min =
        0.0)</span></li>
<li>Long Description: <span id="varHigh_long_desc">
        The parameter 'b' for drawing independent variance values, from +U(a,
        b). </span></li>
<li>Default Value: <span id="varHigh_default_value">3.0</span></li>
<li>Lower Bound: <span id="varHigh_lower_bound">0.0</span></li>
<li>Upper Bound: <span id="varHigh_upper_bound">1.7976931348623157E308</span></li>
<li>Value
                Type: <span id="varHigh_value_type">Double</span></li>
</ul>


=== varLow ===
<h3 class="parameter_description" id="varLow">varLow</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="varLow_short_desc">Low end of variance range (min =
        0.0)</span></li>
<li>Long Description: <span id="varLow_long_desc">
        The parameter 'a' for drawing independent variance values, from +U(a,
        b). </span></li>
<li>Default Value: <span id="varLow_default_value">1.0</span></li>
<li>Lower Bound: <span id="varLow_lower_bound">0.0</span></li>
<li>Upper Bound: <span id="varLow_upper_bound">1.7976931348623157E308</span></li>
<li>Value
                Type: <span id="varLow_value_type">Double</span></li>
</ul>


=== verbose ===
<h3 class="parameter_description" id="verbose">verbose</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="verbose_short_desc">Yes if verbose output should be printed or
        logged</span></li>
<li>Long Description: <span id="verbose_long_desc"> If this parameter is set to ‘Yes’, extra
        (“verbose”) output will be printed if available giving some details
        about the step-by-step operation of the algorithm.</span></li>
<li>Default Value: <span id="verbose_default_value">false</span></li>
<li>Lower Bound: <span id="verbose_lower_bound"></span></li>
<li>Upper Bound: <span id="verbose_upper_bound"></span></li>
<li>Value Type: <span id="verbose_value_type">Boolean</span></li>
</ul>


=== verbose ===
<h3 class="parameter_description" id="include_structure_model">verbose</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="include_structure_model_short_desc">Yes if the (MimBuild)
        structure model should be included in the output graph</span></li>
<li>Long Description: <span id="include_structure_model_long_desc">
        FOFC proper yields a measurement model--that is, a set of pure
        children for each of the discovered latents. One can estimate the
        structure over the latents (the structure model) using Mimbuild. This
        structure model is included in the output if this parameter is set to
        Yes.</span></li>
<li>Default Value: <span id="include_structure_model_default_value">false</span></li>
<li>Lower
                Bound: <span id="include_structure_model_lower_bound"></span></li>
<li>Upper Bound: <span id="include_structure_model_upper_bound"></span></li>
<li>Value Type:
                <span id="include_structure_model_value_type">Boolean</span></li>
</ul>


=== wThreshold ===
<h3 class="parameter_description" id="wThreshold">wThreshold</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="wThreshold_short_desc">wThreshold</span></li>
<li>Long Description: <span id="wThreshold_long_desc">Tuning parameter for DAGMA</span>
</li>
<li>Default Value: <span id="wThreshold_default_value">0.1</span></li>
<li>Lower
                Bound: <span id="wThreshold_lower_bound">0</span></li>
<li>Upper Bound: <span id="wThreshold_upper_bound">Infinity</span></li>
<li>Value Type:
                <span id="wThreshold_value_type">Double</span></li>
</ul>


=== zsMaxIndegree ===
<h3 class="parameter_description" id="zsMaxIndegree">zsMaxIndegree</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="zsMaxIndegree_short_desc">Maximum indegree of true graph (min = 0)</span>
</li>
<li>Long Description: <span id="zsMaxIndegree_long_desc">This is the maximum number of parents one expects any node to have in the true model.</span>
</li>
<li>Default Value: <span id="zsMaxIndegree_default_value">4</span></li>
<li>Lower Bound: <span id="zsMaxIndegree_lower_bound">0</span></li>
<li>Upper Bound: <span id="zsMaxIndegree_upper_bound">2147483647</span></li>
<li>Value Type: <span id="zsMaxIndegree_value_type">Integer</span></li>
</ul>


=== zSRiskBound ===
<h3 class="parameter_description" id="zSRiskBound">zSRiskBound</h3>
<ul class="parameter_description_list">
<li>Short Description: <span id="zSRiskBound_short_desc">Risk bound</span></li>
<li>Long Description: <span id="zSRiskBound_long_desc">
                This is the probability of getting the true model if a correct model is discovered. Could underfit.</span>
</li>
<li>Default Value: <span id="zSRiskBound_default_value">0.1</span></li>
<li>Lower Bound: <span id="zSRiskBound_lower_bound">0</span></li>
<li>Upper Bound: <span id="zSRiskBound_upper_bound">1</span></li>
<li>Value Type: <span id="zSRiskBound_value_type">Double</span></li>
</ul>


