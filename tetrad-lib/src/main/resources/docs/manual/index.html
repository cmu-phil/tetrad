<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/html" xmlns="http://www.w3.org/1999/html" xmlns="http://www.w3.org/1999/html">
<head>
    <meta charset="utf-8">
    <meta content="ie=edge" http-equiv="X-UA-Compatible">
    <title>Tetrad Single HTML Manual</title>
    <meta content="" name="description">
    <meta content="width=device-width, initial-scale=1, shrink-to-fit=no"
          name="viewport">
    <link href="css/normalize.css" rel="stylesheet">
    <link href="css/tetrad.css" rel="stylesheet">
</head>
<body>

<div class="inner">

    <div class="header"><h1>Tetrad Manual</h1>
        <p>Last updated: 2/6/2024</p></div>

    <!-- Table of Contents, give each section a unique id -->
    <div
            class="toc_container">

        <b>Table of Contents</b>
        <ul class="ul">
            <li><a href="#introduction">Introduction</a></li>
            <li><a href="#graph_box">Graph Box</a></li>
            <li><a href="#compare_box">Compare Box</a></li>
            <li><a href="#parametric_model_box">Parametric Model Box</a></li>
            <li><a href="#instantiated_model_box">Instantiated Model Box</a></li>
            <li><a href="#data_box">Data Box</a></li>
            <li><a href="#estimator_box">Estimator Box</a></li>
            <li><a href="#updater_box">Updater Box</a></li>
            <li><a href="#knowledge_box">Knowledge Box</a></li>
            <li><a href="#simulation_box">Simulation Box</a></li>
            <li><a href="#search_box">Search Box</a></li>
            <li><a href="#regression_box">Regression Box</a></li>
            <li><a href="#appendix">Appendix</a></li>
        </ul>

    </div>

    <!-- Assign id with the section name, this will be linked in the
    table of contents --> <h1 id="introduction"><span
        class="section_heading">Introduction</span></h1>

    <p>Tetrad is a suite of software for the discovery, estimation, and
        simulation of causal models. Some of the functions that you can perform
        with Tetrad include, but are not limited to:</p>

    <ul class="ul">
        <li>Loading an existing data set, restricting
            potential models using your a-priori causal knowledge, and searching for
            a model that explains it using one of Tetrad’s causal search algorithms
        </li>
        <li>Loading an existing causal graph and existing data set, and
            estimating a parameterized model from them
        </li>
        <li>Creating a new causal
            graph, parameterizing a model from it, and simulating data from that
            model
        </li>
    </ul>

    <p>Tetrad allows for numerous types of data, graph, and model to be
        input and output, and some functions may be restricted based on what
        types of data or graph the user inputs. Other functions may simply not
        perform as well on certain types of data.</p>

    <p>All analysis in Tetrad is performed graphically using a box
        paradigm, found in a sidebar to the left of the workspace. A box either
        houses an object such as a graph or a dataset, or performs an operation
        such as a search or an estimation. Some boxes require input from other
        boxes in order to work. Complex operations are performed by stringing
        chains of boxes together in the workspace. For instance, to simulate
        data, you would input a graph box into a parametric model box, the PM box
        into an instantiated model box, and finally the IM box into a simulation
        box.</p>

    <p>In order to use a box, click on it in the sidebar, then click
        inside the workspace. This creates an empty box, which you can
        be instantiated by double-clicking. Most boxes have multiple options
        available on instantiation, which will be explained in further detail in
        this manual.</p>

    <p>In order to use one box as input to another, draw an arrow between
        them by clicking on the arrow tool in the sidebar, and clicking and
        dragging from the first box to the second in the workspace.</p>

    <p>Starting 1/14/2024, we will compile Tetrad under JDK 17 and use language level 17.</p>

    <p>Tetrad may be cited using the following reference: Ramsey, J. D.,
        Zhang, K., Glymour, M., Romero, R. S., Huang, B., Ebert-Uphoff, I., ... &
        Glymour, C. (2018). TETRAD—A toolbox for causal discovery. In 8th
        International Workshop on Climate Informatics.</p>

    <h1 id="graph_box"><span class="section_heading">Graph
    Box</span></h1>

    <p>The graph box can be used to create a new graph, or to copy or
        edit a graph from another box.</p>

    <h2>Possible Parent Boxes of the Graph Box</h2>

    <ul class="ul">
        <li>Another graph box</li>
        <li>A parametric model box</li>
        <li>An instantiated model box</li>
        <li>An estimator box</li>
        <li>A data box</li>
        <li>A simulation box</li>
        <li>A search box</li>
        <li>An updater box</li>
        <li>A regression box</li>
    </ul>

    <h2>Possible Child Boxes of the Graph Box</h2>

    <ul class="ul">
        <li>Another graph box</li>
        <li>A compare box</li>
        <li>A parametric model
            box
        </li>
        <li>A data box</li>
        <li>A simulation box</li>
        <li>A search
            box
        </li>
        <li>A knowledge box</li>
    </ul>

    <h2>Creating a New Graph</h2>

    <p>When you first open a graph box with no parent, you will be
        presented with several options for which kind of graph you would like to
        create: a general graph, a directed acyclic graph (DAG), a structural
        equation model (SEM)graph, or a time lag graph. Once you have selected
        the type of graph you want to create, an empty graph box will open.</p>

    <p>You can add variables to your graph by clicking on the variable
        button on the left, then clicking inside the graph area. Add edges by
        clicking on an edge type, then clicking and dragging from one variable to
        another. Variables may be measured (represented by rectangular icons) or
        latent (represented by elliptical icons). Edges may be directed,
        undirected, bidirected, or uncertain (represented by circles at the ends
        of an edge). Depending on the type of graph you choose to create, your
        choice of edges may be limited.</p>

    <p><i>DAGs</i> allow only directed edges. If an edge would create a
        cycle, it will not be accepted. A graph box containing a DAG can be used
        as input for any parametric model box, and is the only kind of graph box
        that can be used as input for a Bayes parametric model.</p>

    <p><i>SEM graphs</i> allow only directed and bidirected edges. A
        graph box containing a SEM graph can be used as input to a SEM parametric
        model or generalized SEM parametric model, where a bidirected edge
        between two variables X and Y will be interpreted as X and Y having
        correlated error terms.</p>

    <p><i>Time lag graphs</i> allow only directed edges. New variables
        that you add will be initialized with a single lag. (The number of lags
        in the graph may be changed under “Edit—Configuration…”) Edges from later
        lags to earlier lags will not be accepted. Edges added within one lag
        will automatically be replicated in later lags. </p>

    <p>The general <i>graph</i> option allows all edge types and
        configurations.</p>


    <h2>Creating a Random Graph </h2>

    <p>Instead of manually creating a new graph, you can randomly create
        one. To do so, open up a new empty graph box and click on “Graph—Random
        Graph.” This will open up a dialog box from which you can choose the type
        of random graph you would like to create by clicking through the tabs at
        the top of the window. Tetrad will randomly generate a DAG, a multiple
        indicator model (MIM) graph, or a scale-free graph. Each type of graph is
        associated with a number of parameters (including but not limited to the
        number of nodes and the maximum degree) which you can set.</p>

    <p>Once a graph has been randomly generated, you can directly edit it
        within the same graph box by adding or removing any variables or edges
        that that type of graph box allows. So, for instance, although you cannot
        randomly generate a graph with bidirected edges, you can manually add
        bidirected edges to a randomly generated DAG in a SEM graph box.</p>

    <p>Random graph generation is not available for time lag graphs. </p>

    <h2>Loading a Saved Graph</h2>

    <p>If you have previously saved a graph from Tetrad, you can load it
        into a new graph box by clicking “File—Load…,” and then clicking on the
        file type of the saved graph. Tetrad can load graphs from XML, from text,
        and from JSON files.</p>

    <p>To save a graph to file, click “File—Save…,” then click on the
        file type you would like to save your graph as. Tetrad can save graphs to
        XML, text, JSON, R and dot files. (If you save your graph to R or dot,
        you will not be able to load that file back into Tetrad.)</p>

    <p>You can also save an image of your graph by clicking “File—Save
        Graph Image…” Tetrad cannot load graphs from saved image files.</p>


    <h2>Copying a Graph</h2>

    <p>There are two ways to copy a graph. </p>

    <p>To copy a graph from any box which contains one, first, create a
        new graph box in the workspace, and draw an arrow from the box whose
        graph you want to copy to the new graph box. When opened, the new graph
        box will automatically contain a direct copy of the graph its parent box
        contains. </p>

    <h2>Manipulating a Graph</h2>

    <p>If you create a graph box as a child of another box, you can also
        choose to perform a graph manipulation on the parent graph. Your graph
        box will then contain the manipulated version of the parent graph.</p>

    <p>The available graph manipulations are:</p>

    <h3>Display Subgraphs</h3>

    <p>This option allows you to isolate a subgraph from the parent
        graph. Add variables to the subgraph by highlighting the variable name in
        the “Unselected” pane and clicking on the right arrow. The highlighted
        variable will then show up in the “Selected” pane. (You may also define
        which variables go in the “Selected” pane by clicking on the “Text
        Input…” button and typing the variable names directly into the window.)
        Choose the type of subgraph you want to display from the drop-down panel
        below. Then click “Graph It!” and the resulting subgraph of the selected
        variables will appear in the pane on the right. (Some types of subgraph,
        such as “Markov Blanket,” will include unselected variables if they are
        part of the subgraph as defined on the selected variables. So, for
        instance, an unselected variable that is in the Markov blanket of a
        selected variable will appear in the Markov Blanket subgraph. Edges
        between unselected variables will not be shown.) For large or very dense
        graphs, it may take a long time to isolate and display subgraphs.</p>

    <p>The types of subgraphs that can be displayed are:</p>

    <ul class="ul">
        <li>Subgraph (displays the selected nodes and all
            edges between them)
        </li>
        <li>Adjacents (displays the selected nodes and
            all edges between them, as well as nodes adjacent to the selected nodes)
        </li>
        <li>Adjacents of adjacents (displays the selected nodes and all
            edges between them, as well as nodes adjacent to the selected nodes and
            nodes adjacent to adjacencies of the selected nodes)
        </li>
        <li>Adjacents
            of adjacents of adjacents (displays the selected nodes and all edges
            between them, as well as nodes adjacent to the selected nodes, nodes
            adjacent to adjacencies of the selected nodes, and nodes adjacent to
            adjacencies of adjacencies of the selected nodes)
        </li>
        <li>Markov
            Blankets (displays the selected nodes and all edges between them, as well
            as the Markov blankets of each selected node)
        </li>
        <li>Treks (displays
            the selected nodes, with an edge between each pair if and only if a trek
            exists between them in the full graph)
        </li>
        <li>Trek Edges (displays the
            selected nodes, and any treks between them, including nodes not in the
            selected set if they are part of a trek)
        </li>
        <li>Paths (displays the
            selected nodes, with an edge between each pair if and only if a path
            exists between them in the full graph)
        </li>
        <li>Path Edges (displays the
            selected nodes, and any paths between them, including nodes not in the
            selected set if they are part of a path)
        </li>
        <li>Directed Paths
            (displays the selected nodes, with a directed edge between each pair if
            and only if a directed path exists between them in the full graph)
        </li>
        <li>Directed Path Edges (displays the selected nodes, and any directed
            paths between them, including nodes not in the selected set if they are
            part of a path)
        </li>
        <li>Y Structures (displays any Y structures
            involving at least two of the selected nodes)
        </li>
        <li>Pag_Y Structures
            (displays any Y PAGs involving at least two of the selected nodes)
        </li>
        <li>Indegree (displays the selected nodes and their parents)</li>
        <li>Outdegree (displays the selected nodes and their children)</li>
        <li>Degree (displays the selected nodes and their parents and
            children)
        </li>
    </ul>

    <h3>Choose Random DAG in CPDAG</h3>

    <p>If given a CPDAG as input, this chooses a random DAG from the
        Markov equivalence class of the CPDAG to display. The resulting DAG
        functions as a normal graph box.</p>

    <h3>Choose Zhang MAG in PAG</h3>

    <p>If given a partial ancestral graph (PAG) as input, this chooses a
        mixed ancestral graph (MAG) from the equivalence class of the PAG
        to display using Zhang's method. The resulting MAG functions as a
        normal graph box.</p>

    <h3>Show DAGs in CPDAG</h3>

    <p>If given a CPDAG as input, this displays all DAGs in the CPDAG’s
        Markov equivalence class. Each DAG is displayed in its own tab. Most
        graph box functionality is not available in this type of graph box, but
        the DAG currently on display can be copied by clicking “Copy Selected
        Graph.”</p>

    <h3>Generate CPDAG from DAG</h3>

    <p>If given a DAG as input, this displays the CPDAG of the Markov
        equivalence class to which the parent graph belongs. The resulting CPDAG
        functions as a normal graph box.</p>

    <h3>Generate PAG from DAG</h3>

    <p>Converts an input graph from partial ancestral to directed acyclic
        format. The resulting DAG functions as a normal graph box.</p>

    <h3>Generate PAG from tsDAG</h3>

    <p>Converts an input graph from partial ancestral to time series DAG
        format. The resulting DAG functions as a normal graph box.</p>

    <h3>Make Bidirected Edges Undirected</h3>

    <p>Replaces all bidirected edges in the input graph with undirected
        edges.</p>

    <h3>Make Undirected Edges Bidirected</h3>

    <p>Replaces all undirected edges in the input graph with bidirected
        edges.</p>

    <h3>Make All Edges Undirected</h3>

    <p>Replaces all edges in the input graph with undirected edges.</p>

    <h3>Generate Complete Graph</h3>

    <p>Creates a completely connected, undirected graph from the
        variables in the input graph.</p>

    <h3>Extract Structure Model</h3>

    <p>Isolates the subgraph of the input graph involving all and only
        latent variables.</p>


    <h2>Other Graph Box Functions</h2>

    <h3>Edges and Edge Type Frequencies</h3>

    <p>At the bottom of the graph box, the Edges and Edge Type
        Frequencies section provides an accounting of every edge in the graph,
        and how certain Tetrad is of its type. The first three columns contain a
        list, in text form, of all the edges in the graph. The columns to the
        right are all blank in manually constructed graphs, user-loaded graphs,
        and graphs output by searches with default settings. They are only filled
        in for graphs that are output by searches performed with bootstrapping.
        In those cases, the fourth column will contain the percentage of
        bootstrap outputs in which the edge type between these two variables
        matches the edge type in the final graph. All the columns to the right
        contain the percentages of the bootstrap outputs that output each
        possible edge type.</p>

    <p>For more information on bootstrap searches, see the Search Box
        section of the manual.</p>

    <h3>Layout</h3>

    <p>You can change the layout of your graph by clicking on the
        “Layout” tab and choosing between several common layouts. You can also
        rearrange the layout of one graph box to match the layout of another
        graph box (so long as the two graphs have identical variables) by
        clicking “Layout—Copy Layout” and “Layout—Paste Layout.” You do not need
        to a highlight the graph in order to copy the layout.</p>

    <h3>Graph Properties</h3>

    <p>Clicking on “Graph—Graph Properties” will give you a text box
        containing the following properties of your graph:</p>

    <ul class="ul">
        <li>Number of nodes</li>
        <li>Number of latent
            nodes
        </li>
        <li>Number of adjacencies</li>
        <li>Number of directed edges (not in 2-cycles)</li>
        <li>Number of bidirected edges</li>
        <li>Number of undirected edges</li>
        <li>Max degree</li>
        <li>Max indegree</li>
        <li>Max outdegree</li>
        <li>Average degree</li>
        <li>Density</li>
        <li>Number of latents</li>
        <li>Cyclic/Acyclic</li>
    </ul>

    <h3>Paths</h3>

    <p>Clicking on “Graph—Paths” opens a dialog box that allows you to
        see all the paths between any two variables. You can specify whether you
        want to see only adjacencies, only directed paths, only semidirected
        paths, or all treks between the two variables of interest, and the
        maximum length of the paths you are interested in using drop boxes at the
        top of the pane. To apply those settings, click “update.”</p>

    <h3>Correlation</h3>

    <p>You can automatically correlate or uncorrelated exogenous
        variables under the Graph tab.</p>

    <h3>Highlighting</h3>

    <p>You can highlight bidirected edges, undirected edges, and latent
        nodes under the Graph tab.</p>

    <h1 id="compare_box"><span class="section_heading">Compare
    Box</span></h1>

    <p>The compare box compares two or more graphs.</p>

    <h2>Possible Parent Boxes of the Compare box:</h2>

    <ul class="ul">
        <li>A graph box</li>
        <li>An instantiated model
            box
        </li>
        <li>An estimator box</li>
        <li>A simulation box</li>
        <li>A search
            box
        </li>
        <li>A regression box</li>
    </ul>

    <h2>Possible Child Boxes of the Compare box:</h2>

    <ul class="ul">
        <li>None</li>
    </ul>

    <h2>Edgewise Comparisons</h2>

    <p>An edgewise comparison compares two graphs, and gives a textual
        list of the edges which must be added to or taken away from one to make
        it identical to the other.</p>

    <p>Take, for example, the following two graphs. The first is the
        reference graph, the second is the graph to be compared to it.
        When the Edgewise Comparison box is opened, a comparison like this
        appears:</p>

    <img alt=""
         src="images/compare_box_12.png" width="360">

    <p>You may choose (by a menu in the upper left part of the box) whether the
        graph being compared is the original DAG, or the CPDAG of the original
        DAG, of the PAG of the original DAG</p>

    <p>When the listed changes have been made to the second graph, it
        will be identical to the first graph.</p>


    <h2>Stats List Graph Comparisons</h2>

    <p>A stats list graph comparison tallies up and presents statistics
        for the differences and similarities between a true graph and a reference
        graph. Consider the example used in the above section; once again, we’ll
        let graph one be the true graph. Just as above, when the graphs are input
        to the tabular graph compare box, we must specify which of the graphs is
        the reference graph, and whether it contains latent variables. When the
        comparison is complete, the following window results:</p>

    <img alt="" src="images/compare_box_1.png" width="650">

    <p>You may choose (by a menu in the upper left part of the box) whether the
        graph being compared is the original DAG, or the CPDAG of the original
        DAG, of the PAG of the original DAG</p>

    <p>The first columns gives an abbreviation for the statistic; the
        second columns gives a definition of the statistic. The third columns
        gives the statistic value. </p>

    <h2>Misclassifications</h2>

    <p>A misclassification procedure organizes a graph comparison by edge
        type. The edge types (undirected, directed, uncertain, partially
        uncertain, bidirected, and null) are listed as the rows and columns of a
        matrix, with the true graph edges as the row headers and the target graph
        edges as the column headers. If, for example, there are three pairs of
        variables that are connected by undirected edges in the reference graph,
        but are connected by directed edges in the estimated graph, then there
        will be a 3 in the (undirected, directed) cell of the matrix. An
        analogous method is used to represent endpoint errors. For example:</p>

    <img alt="" src="images/compare_box_13.png" width="650">

    <h2>Graph Intersections</h2>

    <p>A graph intersection compares two or more graphs in the same
        comparison. It does so by ranking adjacencies (edges without regard to
        direction) and orientations based on how many of the graphs they appear
        in. In an n-graph comparison, it first lists any adjacencies found in all
        n graphs. Then it lists all adjacencies found in n – 1 graphs, then
        adjacencies found in n – 2 graphs, and so on. </p>

    <p>After it has listed all adjacencies, it lists any orientations
        that are not contradicted among the graphs, again in descending order of
        how many graphs the orientation appears in. An uncontradicted orientation
        is one on which all graphs either agree or have no opinion. So if the
        edge X  Y appears in all n graphs, it will be listed first. If the edge
        X  Z appears in n – 1 graphs, it will be listed next, but only if the
        nth graph doesn’t contradict it—that is, only if the edge Z  X does not
        appear in the final graph. If the undirected edge Z – X appears in the
        final graph, the orientation X  Z is still considered to be
        uncontradicted.</p>

    <p>Finally, any contradicted orientations (orientations that the
        graphs disagree on) are listed.</p>

    <h2>Independence Facts Comparison</h2>

    <p>Rather than comparing edges or orientation, this option directly
        compares the implied dependencies in two graphs. When you initially open
        the box, you will see the following window:</p>

    <img alt="" src="images/compare_box_6.png" width="650">

    <p>The drop-down menu allows you to choose which variables you want
        to check the dependence of. If you select more than two variables, any
        subsequent variables will be considered members of the conditioning set.
        So, if you select variables X1, X2, and X3, in that order, the box will
        determine whether X1 is independent of X2, conditional on X3, in each of
        the graphs being compared. When you click “List,” in the bottom right of
        the window, the results will be displayed in the center of the window:
    </p>

    <img alt="" src="images/compare_box_7.png" width="650">

    <h2>Edge Weight Similarity Comparisons</h2>

    <p>Edge weight (linear coefficient) similarity comparisons compare
        two linear SEM instantiated models. The output is a score equal to the
        sum of the squares of the differences between each corresponding edge
        weight in each model. Therefore, the lower the score, the more similar
        the two graphs are. The score has peculiarities: it does not take account
        of the variances of the variables, and may therefore best be used with
        standardized models; the complete absence of an edge is scored as 0—so a
        negative coefficient compares less well with a positive coefficient than
        does no edge at all.</p>

    <p>Consider, for example, an edge weight similarity comparison
        between the following two SEM IMs:</p>

    <img alt="" src="images/compare_box_8.png" width="360">

    <img alt="" src="images/compare_box_9.png" width="360">

    <p>When they are input into an edge weight similarity comparison, the
        following window results: </p>


    <img alt="" src="images/compare_box_10.png" width="450">

    <p>This is, unsurprisingly, a high score; the input models have few
        adjacencies in common, let alone similar parameters.</p>

    <h2>Model Fit</h2>

    <p>A model fit comparison takes a simulation box and a search box
        (ideally, a search that has been run on the simulated data in the
        simulation box), and provides goodness-of-fit statistics, including a
        Student’s t statistic and p value for each edge, for the output graph and
        the data, as well as estimating the values of any parameters. It looks
        and functions identically to the estimator box, but unlike the estimator
        box, it takes the search box directly as a parent, without needing to
        isolate and parameterize the graph output by the search.</p>

    <h2>Markov Check</h2>

    <p>
        The Markov Checker checks to see whether the Markov Condition is satisfied
        for a given graph. A simple version of the Markov Condition states that
        for any variable X, X is independent of all non-descendants of X given
        X’s parents. The Markov Checker will output all such implied independences
        and their p-values; these p-values should be distributed as U(0, 1) if the
        Markov Condition is satisfied, so violations can often be detected by
        plotting a histogram of these p-values or doing an Anderson-Darling test
        or a Kolmogorov-Smirnov test to see if the hypothesis that they are drawn
        from a U(0, 1) distribution can be rejected. This sort of check is actually
        more general, since graphical implicaitons of separation are not limited to
        directect acyclic graphs (DAGs) but can be inferred from many types of
        graphs, including CPDAGs, MAGs, ADMGs, and PAGs.
    </p>

    <p>
        Instructions for using the Markov Checker are included in the box itself,
        in the "Help" tab.
    </p>

    <h2>IDA Check</h2>

    <p>
        The IDA Checker check loops through all pairs of variable (X, Y) and
        calculates the IDA minimum effect for each X on Y, for a linear CPDAG
        model. The IDA minimum effect is the minimum effect of X on Y, regressing
        Y on S U {X} for all possible parent sets of X in the CPDAG. This gives
        a range of effects, and one then see whether the true effect of X on Y
        (as calculated from the true SEM IM) falls within this range. If it does
        not, then the IDA minimum effect is not consistent with the true effect.
    </p>

    <p>
        The IDA check table gives information to help the user assess these results
        along with several summary statistics. Further instructions for using the
        IDA Checker are included in the box itself, in the "Help" tab.
    </p>

    <h2>Algcomparison</h2>

    <p>
        The Algcomparison (Algorithm comparison) tool allows the user to compare the
        results of multiple searches. The user can select one or more simulations,
        one or more algorithm (with selected test and/or score), and one or more
        table columns representing columns of parameter values or else statistics
        that are calculated based on the comparisons done. For most of these values,
        the use can specify multiple options for values, and the tool will iterate
        over all sensible combinations of these values and output a table of results.
        Full results, including all simulated dataset, all true graphs, all estimated
        graphs, and all timing results, are saved to the hard drive.
    </p>

    <p>
        Further instructions for using the Algcomparison tool are included in the
        box itself, in the "Help" tab.
    </p>


    <h1 id="parametric_model_box"><span
            class="section_heading">Parametric Model Box</span></h1>

    <p>The parametric model box takes a nonparameterized input graph and
        creates a causal model.</p>

    <h2>Possible Parent Boxes of the Parametric Model Box:</h2>

    <ul class="ul">
        <li>A graph box</li>
        <li>Another parametric model
            box
        </li>
        <li>An instantiated model box</li>
        <li>An estimator box</li>
        <li>A data box</li>
        <li>A simulation box</li>
        <li>A search box</li>
        <li>A
            regression box
        </li>
    </ul>


    <h2>Possible Child Boxes of the Parametric Model Box:</h2>

    <ul class="ul">
        <li>A graph box</li>
        <li>Another parametric model
            box
        </li>
        <li>An instantiated model box</li>
        <li>An estimator box</li>
        <li>A data box</li>
        <li>A simulation box</li>
        <li>A search box</li>
        <li>A
            knowledge box
        </li>
    </ul>

    <h2>Bayes Parametric Models</h2>

    <p>A Bayes parametric model takes as input a DAG. Bayes PMs represent
        causal structures in which all the variables are categorical.</p>

    <p>Bayes PMs consist of three components: the graphical
        representation of the causal structure of the model; for each named
        variable, the number of categories which that variable can assume; and
        the names of the categories associated with each variable.</p>

    <p>You may either manually assign categories to the variables or have
        Tetrad assign them at random. If you choose to manually create a Bayes
        PM, each variable will initially be assigned two categories, named
        numerically. If you choose to have Tetrad assign the categories, you can
        specify a minimum and maximum number of categories possible for any given
        variable. You can then manually edit the number of categories and
        category names.</p>

    <p>Take, for example, the following DAG:</p>

    <img alt="" src="images/parametric_model_box_1.png" width="360">

    <p>One possible random Bayes PM that Tetrad might generate from the
        above DAG, using the default settings, looks like this:</p>

    <img alt="" src="images/parametric_model_box_2.png" width="650">

    <p>To view the number and names of the categories associated with
        each variable, you can click on that variable in the graph, or choose it
        from the drop-down menu on the right. In this graph, X1 and X2 each have
        three categories, and the rest of the variables have four categories. The
        categories are named numerically by default.</p>

    <p>The number of categories associated with a particular variable can
        be changed by clicking up or down in the drop-down menu on the right.
        Names of categories can be changed by overwriting the text already
        present.</p>

    <p>Additionally, several commonly-used preset variable names are
        provided under the “Presets” tab on the right. If you choose one of these
        configurations, the number of categories associated with the current
        variable will automatically be changed to agree with the configuration
        you have chosen. If you want all the categories associated with a
        variable to have the same name with a number appended (e.g., x1, x2, x3),
        choose the “x1, x2, x3…” option under Presets.</p>

    <p>You can also copy category names between variables in the same
        Bayes PM by clicking on “Transfer—Copy categories” and “Transfer—Paste
        categories.”</p>

    <h2>SEM Parametric Models</h2>

    <p>The parametric model of a structural equation model (SEM) will
        take any type of graph as input, as long as the graph contains only
        directed and bidirected edges. SEM PMs represent causal structures in
        which all variables are continuous. </p>

    <p>A SEM PM has two components: the graphical causal structure of the
        model, and a list of parameters used in a set of linear equations that
        define the causal relationships in the model. Each variable in a SEM PM
        is a linear function of a subset of the other variables and of an error
        term drawn from a Normal distribution.</p>

    <p>Here is an example of a SEM graph and the SEM PM that Tetrad
        creates from it:</p>

    <img alt="" src="images/parametric_model_box_3.png" width="360">

    <img alt="" src="images/parametric_model_box_4.png" width="450">

    <p>You can see the error terms in the model by clicking
        “Parameters—Show Error Terms.” In a SEM model, a bidirected edge
        indicates that error terms are correlated, so when error terms are
        visible, the edge between X1 and X2 will instead run between their error
        terms.</p>

    <p>To change a parameter’s name or starting value for estimation,
        double-click on the parameter in the window.</p>

    <h2>Generalized SEM Parametric Models</h2>

    <p>A generalized SEM parametric model takes as input any type of
        graph, as long as the graph contains only directed edges. (The
        generalized SEM PM cannot currently interpret bidirected edges.) Like a
        SEM PM, it represents causal structures in which all variables are
        continuous. Also like a SEM PM, a generalized SEM PM contains two
        components: the graphical causal structure of the model, and a set of
        equations representing the causal structure of the model. Each variable
        in a generalized SEM PM is a function of a subset of the other variables
        and an error term. By default, the functions are linear and the error
        terms are drawn from a Normal distribution (as in a SEM PM), but the
        purpose of a generalized SEM PM is to allow editing of these
        features.</p>

    <p>Here is an example of a general graph and the default generalized
        SEM PM Tetrad creates using it:</p>

    <img alt="" src="images/parametric_model_box_5.png" width="360">

    <img alt="" src="images/parametric_model_box_6.png" width="650">


    <p>You can view the error terms by clicking “Tools: Show Error
        Terms.”

    <p>The Variables tab contains a list of the variables and the
        expressions that define them, and a list of the error terms and the
        distributions from which their values will be drawn. Values will be drawn
        independently for each case if the model is instantiated (see IM box) and
        used to simulate data (see data box).</p>

    <p>The Parameters tab contains a list of the parameters and the
        distributions from which they are drawn. When the model in instantiated
        in the IM box, a fixed value of each parameter will be selected according
        to the specified distribution. </p>

    <p>To edit an expression or parameter, double-click on it (in any
        tab). This will open up a window allowing you to change the function that
        defines the variable or distribution of the parameter.</p>

    <p>For instance, if you double-click on the expression next to X1
        (b1*X5+E_X1), the following window opens:</p>

    <img alt="" src="images/parametric_model_box_7.png" width="500">

    <p>The drop-down menu at the top of the window lists valid operators
        and functions. You could, for example, change the expression from linear
        to quadratic by replacing b1*X5+E_X1 with b1*X5^2+E_X1. You can also form
        more complicated expressions, using, for instance, exponential or sine
        functions. If the expression you type is well-formed, it will appear in
        black text; if it is invalid, it will appear in red text. Tetrad will not
        accept any invalid changes. </p>

    <p>Parameters are edited in the same way as expressions.</p>

    <p>If you want several expressions or parameters to follow the same
        non-linear model, you may wish to use the Apply Templates tool. This
        allows you to edit the expressions or parameters associated with several
        variables at the same time. To use the Apply Templates tool, click
        “Tools: Apply Templates….” This will open the following window:</p>

    <img alt="" src="images/parametric_model_box_8.png" width="500">

    <p>You can choose to edit variables, error terms, or parameters by
        clicking through the “apply to” radio buttons. If you type a letter or
        expression into the “starts with” box, the template you create will apply
        only to variables, error terms, or parameters which begin with that
        letter for expression. For example, in the given generalized PM, there
        are two types of parameters: the standard deviations s1-s6 and the edge
        weights b1-b7. If you click on the “Parameters” radio button and type “b”
        into the “Starts with” box, only parameters b1-b7 will be affected by the
        changes you make.</p>

    <p>The “Type Template” box itself works in the same way that the
        “Type Expression” box works in the “Edit Expression” window, with a few
        additions. If you scroll through the drop-down menu at the top of the
        window, you will see the options NEW, TSUM, and TPROD. Adding NEW to a
        template creates a new parameter for every variable the template is
        applied to. TSUM means “sum of the values of this variable’s parents,”
        and TPROD means “product of the values of this variable’s parents.” The
        contents of the parentheses following TSUM and TPROD indicate any
        operations which should be performed upon each variable in the sum or
        product, with the dollar sign ($) functioning as a wild card. For
        example, in the image above, TSUM(NEW(b)*$) means that, for each parent
        variable of the variable in question, a new “b” will be created and
        multiplied by the parent variable’s value, and then all the products
        will be added together.</p>


    <h1 id="instantiated_model_box"><span
            class="section_heading">Instantiated Model Box</span></h1>

    <p>The instantiated model (IM) box takes a parametric model and
        assigns values to the parameters.</p>

    <h2>Possible Parent Boxes of the Instantiated Model Box:</h2>

    <ul class="ul">
        <li>A parametric model box</li>
        <li>Another
            instantiated model box
        </li>
        <li>An estimator box</li>
        <li>A simulation
            box
        </li>
        <li>An updater box</li>
    </ul>

    <h2>Possible Child Boxes of the Instantiated Model Box:</h2>

    <ul class="ul">
        <li>A graph box</li>
        <li>A compare box</li>
        <li>A
            parametric model box
        </li>
        <li>Another instantiated model box</li>
        <li>An
            estimator box
        </li>
        <li>A simulation box</li>
        <li>A search box</li>
        <li>An
            updater box
        </li>
        <li>A classify box</li>
        <li>A knowledge box</li>
    </ul>


    <h2>Bayes Instantiated Models</h2>

    <p>A Bayes IM consists of a Bayes parametric model with defined
        probability values for all variables. This means that, conditional on the
        values of each of its parent variables, there is a defined probability
        that a variable will take on each of its possible values. For each
        assignment of a value to each of the parents of a variable X, the
        probabilities of the several values of X must sum to 1.</p>

    <p>You can manually set the probability values for each variable, or
        have Tetrad assign them randomly. If you choose to have Tetrad assign
        probability values, you can manually edit them later.</p>

    <p>Here is an example of a Bayes PM and its randomly created
        instantiated model:</p>

    <img alt="" src="images/instantiated_model_box_1.png" width="650">

    <img alt="" src="images/instantiated_model_box_2.png" width="650">

    <p>In the model above, when X4 and X5 are both 0, the probability
        that X5 is 0 is 0.0346, that X5 is 1 is 0.4425, and that X5 is 2 is
        0.5229. Since X5 must be 0, 1, or 2, those three values must add up to
        one, as must the values in every row.</p>

    <p>To view the probability values of a variable, either double click
        on the variable in the graph or choose it from the drop-down menu on the
        right. You can manually set a given probability value by overwriting the
        text box. Be warned that changing the value in one cell will delete the
        values in all the other cells in the row. Since the values in any row
        must sum to one, if all the cells in a row but one are set, Tetrad
        will automatically change the value in the last cell to make the sum
        correct. For instance, in the above model, if you change the first row
        such that the probability that X5 = 0 is 0.5000 and the probability that
        X5 = 1 is 0.4000, the probability that X5 = 2 will automatically be set
        to 0.1000.</p>

    <p>If you right-click on a cell in the table (or two-finger click on
        Macs), you can choose to randomize the probabilities in the row
        containing that cell, randomize the values in all incomplete rows in the
        table, randomize the entire table, or randomize the table of every
        variable in the model. You can also choose to clear the row or table.</p>

    <h2>Dirichlet Instantiated Models</h2>

    <p>A Dirichlet instantiated model is a specialized form of a Bayes
        instantiated model. Like a Bayes IM, a Dirichlet IM consists of a Bayes
        parametric model with defined probability values. Unlike a Bayes IM,
        these probability values are not manually set or assigned randomly.
        Instead, the pseudocount is manually set or assigned uniformly, and the
        probability values are derived from it. The pseudocount of a given value
        of a variable is the number of data points for which the variable takes
        on that value, conditional on the values of the variable’s parents, where
        these numbers are permitted to take on non-negative real values. Since we
        are creating models without data, we can set the pseudocount to be any
        number we want. If you choose to create a Dirichlet IM, a window will
        open allowing you to either manually set the pseudocounts, or have Tetrad
        set all the pseudocounts in the model to one number, which you
        specify.</p>

    <p>Here is an example of a Bayes PM and the Dirichlet IM which Tetrad
        creates from it when all pseudocounts are set to one:</p>

    <img alt="" src="images/instantiated_model_box_3.png" width="650">

    <img alt="" src="images/instantiated_model_box_4.png" width="650">

    <p>In the above model, when X2=0 and X6=0, there is one (pseudo) data
        point at which X4=0, one at which X4=1, and one at which X4=2. There are
        three total (pseudo) data points in which X2=0 and X6=0. You can view the
        pseudocounts of any variable by clicking on it in the graph or choosing
        it from the drop-down menu at the top of the window. To edit the value of
        a pseudocount, double-click on it and overwrite it. The total count of a
        row cannot be directly edited.</p>

    <p>From the pseudocounts, Tetrad determines the conditional
        probability of a category. This estimation is done by taking the
        pseudocount of a category and dividing it by the total count for its row.
        For instance, the total count of X4 when X2=0 and X6=0 is 3. So the
        conditional probability of X4=0 given that X2=0 and X6=0 is 1/3. The
        reasoning behind this is clear: in a third of the data points in which X2
        and X6 are both 0, X4 is also 0, so the probability that X4=0 given that
        X2 and X6 also equal 0 is probably one third. This also guarantees that
        the conditional probabilities for any configuration of parent variables
        add up to one, which is necessary.</p>

    <p>To view the table of conditional probabilities for a variable,
        click the Probabilities tab. In the above model, the Probabilities tab
        looks like this: </p>

    <img alt="" src="images/instantiated_model_box_5.png" width="650">

    <h2>SEM Instantiated Models</h2>

    <p>A SEM instantiated model is a SEM parametric model in which the
        parameters and error terms have defined values. It assumes that
        relationships between variables are linear, and that error terms have
        Gaussian distributions. If you choose to create a SEM IM, the following
        window will open:</p>

    <img alt="" src="images/instantiated_model_box_6.png" width="450">


    <p>Using this box, you can specify the ranges of values from which
        you want coefficients, covariances, and variances to be drawn for the
        parameters in the model. In the above box, for example, all linear
        coefficients will be between -1.0 and 1.0. If you uncheck “symmetric
        about zero,” they will only be between 0.0 and 1.0.</p>

    <p>Here is an example of a SEM PM and a SEM IM generated from it
        using the default settings: </p>

    <img alt="" src="images/instantiated_model_box_7.png" width="360">

    <img alt="" src="images/instantiated_model_box_8.png" width="450">

    <p>You can now manually edit the values of parameters in one of two
        ways. Double-clicking on the parameter in the graph will open up a small
        text box for you to overwrite. Or you can click on the Tabular Editor
        tab, which will show all the parameters in a table which you can edit.
        The Tabular Editor tab of our SEM IM looks like this:</p>

    <img alt="" src="images/instantiated_model_box_9.png" width="450">

    <p>In the Tabular Editor tab of a SEM estimator box (which functions
        similarly to the SEM IM box), the SE, T, and P columns provide statistics
        showing how robust the estimation of each parameter is. Our SEM IM,
        however, is in an instantiated model box, so these columns are empty.</p>

    <p>The Implied Matrices tab shows matrices of relationships between
        variables in the model. In the Implied Matrices tab, you can view the
        covariance or correlation matrix for all variables (including latents) or
        just measured variables. In our SEM IM, the Implied Matrices tab looks
        like this:</p>

    <img alt="" src="images/instantiated_model_box_10.png" width="450">

    <p>You can choose the matrix you wish to view from the drop-down menu
        at the top of the window. Only half of any matrix is shown, because in a
        well-formed acyclic model, the matrices should be symmetric. The cells in
        the Implied Matrices tab cannot be edited.</p>

    <p>In an estimator box, the Model Statistics tab provides goodness of
        fit statistics for the SEM IM which has been estimated. Our SEM IM,
        however, is in an instantiated model box, so no estimation has occurred,
        and the Model Statistics tab is empty.</p>


    <h2>Standardized SEM Instantiated Models </h2>

    <p>A standardized SEM instantiated model consists of a SEM parametric
        model with defined values for its parameters. In a standardized SEM IM,
        each variable (not error terms) has a Normal distribution with 0 mean and
        unit variance. The input PM to a standardized SEM IM must be acyclic.</p>

    <p>Here is an example of an acyclic SEM PM and the standardized SEM
        IM which Tetrad creates from it</p>

    <img alt="" src="images/instantiated_model_box_11.png" width="360">

    <img alt="" src="images/instantiated_model_box_12.png" width="450">


    <p>To edit a parameter, double-click on it. A slider will open at the
        bottom of the window (shown above for the edge parameter between X1 and
        X2). Click and drag the slider to change the value of the parameter, or
        enter the specific value you wish into the box. The value must stay
        within a certain range in order for the variables in the model to
        remain standard Normal (N(0, 1)), so if you attempt to overwrite
        the text box on the bottom right with a value outside the listed range,
        Tetrad will not allow it. That is, given that the variables are all
        distributed as N(0, 1), there is a limited range in which each parameter
        may be adjusted; these ranges vary parameter by parameter, given
        the values of the other parameters. In a standardized SEM IM, error
        terms are not considered parameters and cannot be edited, but you can
        view them by clicking Parameters: Show Error Terms. </p>

    <p>It is possible to make a SEM IM with a time lag graph, even with latent
        variables. This does not work for other types of models, such as
        Bayes IMs or for mixed data (for which no IM is currently available--
        though mixed data can be simulated in the Simulate box with an appropriate
        choice of simulation model). Standardization for time lag model
        is not currently available.</p>

    <p>The Implied Matrices tab works in the same way that it does in a
        normal SEM IM.</p>


    <h2>Generalized SEM Instantiated Models</h2>

    <p>A generalized SEM instantiated model consists of a generalized SEM
        parametric model with defined values for its parameters. Since the
        distributions of the parameters were specified in the SEM PM, Tetrad does
        not give you the option of specifying these before it creates the
        instantiated model.</p>

    <p>Here is an example of a generalized SEM PM and its generalized SEM
        IM:</p>

    <img alt="" src="images/instantiated_model_box_13.png" width="450">

    <img alt="" src="images/instantiated_model_box_14.png" width="450">

    <p>Note that the expressions for X6 and X2 are not shown, having been
        replaced with the words “long formula.” Formulae over a certain
        length—the default setting is 25 characters—are hidden to improve
        visibility. Long formulae can be viewed in the Variables tab, which lists
        all variables and their formulae. You can change the cutoff point for
        long formulae by clicking Tools: Formula Cutoff.</p>

    <p>If you double-click on a formula in either the graph or the
        Variables tab, you can change the value of the parameters in that
        formula. </p>


    <h1 id="data_box"><span class="section_heading">Data Box</span></h1>

    <p>The data box stores or manipulates data sets.</p>

    <h2>Possible Parent Boxes of the Data Box</h2>

    <ul class="ul">
        <li>A graph box</li>
        <li>An estimator box</li>
        <li>Another data box</li>
        <li>A simulation box</li>
        <li>A regression
            box
        </li>
    </ul>


    <h2>Possible Child Boxes of the Data Box</h2>

    <ul class="ul">
        <li>A graph box</li>
        <li>A parametric model box</li>
        <li>Another data box</li>
        <li>An estimator box</li>
        <li>A simulation
            box
        </li>
        <li>A search box</li>
        <li>A classify box</li>
        <li>A regression
            box
        </li>
        <li>A knowledge box</li>
    </ul>

    <h2>Using the Data Box:</h2>

    <p>The data box stores the actual data sets from which causal
        structures are determined. Data can be loaded into the data box from a
        preexisting source, manually filled in Tetrad, or simulated from an
        instantiated model.</p>

    <h2>Loading Data</h2>

    <p>Data sets loaded into Tetrad may be categorical, continuous,
        mixed, or covariance data.</p>

    <h3>General Tabular Data</h3>

    <p>To load data, create a data box with no parent. When you double-click
        it, an empty data window will appear: </p>

    <img alt="" src="images/data_box_1.png" width="650">

    <p>Click "File -> Load Data" and select the text file or files that
        contain your data. The following window will appear:</p>

    <img alt="" src="images/data_box_2.png" width="650">

    <p>The text of the source file appears in the Data Preview window.
        Above, there are options to describe your file, so that Tetrad can load
        it correctly. If you are loading categorical, continuous, or mixed data
        values, select the “Tabular Data” button. If you are loading a covariance
        matrix, select “Covariance Data.” Note that if you are loading a
        covariance matrix, your text file should contain only the lower half of
        the matrix, as Tetrad will not accept an entire matrix.</p>

    <p>Below the file type, you can specify a number of other details
        about your file, including information about the type of data
        (categorical/continuous/mixed), metadata JSON file, delimiter between
        data values, variable names, and more. If your data is mixed (some
        variables categorical, and some continuous), you must specify the maximum
        number of categories discrete variables in your data can take on. All
        columns with more than that number of values will be treated as
        continuous; the others will be treated as categorical. If you do not list
        the variable names in the file, you should uncheck “First row variable
        names.” If you provide case IDs, check the box for the appropriate column
        in the “Case ID column to ignore” area. If the case ID column is labeled,
        provide the name of the label; otherwise, the case ID column should be
        the first column, and you should check “First column.”</p>

    <p>Below this, you can specify your comment markers, quote
        characters, and the character which marks missing data values. Tetrad
        will use that information to distinguish continuous from discrete
        variables. You may also choose more files to load (or remove files that
        you do not wish to load) in the “Files” panel on the lower left.</p>

    <h3>Metadata JSON File</h3>
    <p> Metadata is optional in general data
        handling. But it can be very helpful if you want to overwrite the data
        type of given variable column. And the metadata MUST be a JSON file
        like the following example. </p>

    <pre>
{
"domains": [
{
"name": "raf",
"discrete": false
},
{
"name": "mek",
"discrete": true
}
]
}
</pre>

    <p> You can specify the name and data type for each variable.
        Variables that are not in the metadata file will be treated as domain
        variables and their data type will be the default data type when reading
        in columns described previously. </p>

    <p>When you are satisfied with your description of your data, click
        “Validate” at the bottom of the window. Tetrad will check that your file
        is correctly formatted. If it is, you will receive a screen telling you
        that validation has passed with no error. At this point, you can revisit
        the settings page, or click “Load” to load the data. </p>

    <img alt="" src="images/data_box_3.png" width="650">

    <img alt="" src="images/data_box_4.png" width="650">

    <p>You can now save this data set to a text file by clicking File:
        Save Data.</p>

    <p>In addition to loading data from a file, you can manually enter
        data values and variable names by overwriting cells in the data
        table.</p>


    <h3>Covariance Data</h3>
    <p>Covariance matrices loaded into Tetrad
        should be ascii text files. The first row contains the sample size, the
        second row contains the names of the variables. The first two rows are
        followed by a lower triangular matrix. For example:</p>

    <pre>
1000
X1  X2  X3  X4  X5  X6
1.0000
0.0312  1.0000
-0.5746 0.4168  1.0000
-0.5996 0.4261  0.9544  1.0000
0.8691  0.0414  -0.4372 -0.4487 1.0000
0.6188  0.0427  -0.1023 -0.0913 0.7172  1.0000
</pre>


    <p>Categorical, continuous, or mixed data should also be an ascii
        text file, with columns representing variables and rows representing
        cases. Beyond that, there is a great deal of flexibility in the layout:
        delimiters may be commas, colons, tabs, spaces, semicolons, pipe symbols,
        or whitespace; comments and missing data may be marked by any symbol you
        like; there may be a row of variable names or not; and case IDs may be
        present or not. There should be no sample size row. For example:</p>

    <pre>
X1  X2  X3  X4  X5
-3.0133 1.0361  0.2329  2.7829  -0.2878
0.5542  0.3661  0.2480  1.6881  0.0775
3.5579  -0.7431 -0.5960 -2.5502 1.5641
-0.0858 1.0400  -0.8255 0.3021  0.2654
-0.9666 -0.5873 -0.6350 -0.1248 1.1684
-1.7821 1.8063  -0.9814 1.8505  -0.7537
-0.8162 -0.6715 0.3339  2.6631  0.9014
-0.3150 -0.5103 -2.2830 -1.2462 -1.2765
-4.1204 2.9980  -0.3609 4.8079  0.6005
1.4658  -1.4069 1.7234  -1.7129 -3.8298
    </pre>

    <h3>Handling Tabular Data with Interventional Variables</h3>

    <p>This is an advanced topic for datasets that contain interventional
        (i.e., experimental) variables. We model a single intervention using two
        variables: status variable and value variable. Below is a sample dataset,
        in which `raf`, `mek`, `pip2`, `erk`, `atk` are the 5 domain variables,
        and `cd3_s` and `cd3_v` are an interventional pair (status and value
        variable respectively). `icam` in another intervention variable, but it's
        a combined variable that doesn't have status.</p>

    <pre>
raf mek pip2    erk akt cd3_s   cd3_v   icam
3.5946  3.1442  3.3429  2.81    3.2958  0   1.2223  *
3.8265  3.2771  3.2884  3.3534  3.7495  0   2.3344  *
4.2399  3.9908  3.0057  3.2149  3.7495  1   0   3.4423
4.4188  4.5304  3.157   2.7619  3.0819  1   3.4533  1.0067
3.7773  3.3945  2.9821  3.4372  4.0271  0   4.0976  *
</pre>

    <p>And the sample metadata JSON file looks like this:</p>

    <pre>
{
"interventions": [
{
"status": {
"name": "cd3_s",
"discrete": true
},
"value": {
"name": "cd3_v",
"discrete": false
}
},
{
"status": null,
"value": {
"name": "icam",
"discrete": false
}
}
],
"domains": [
{
"name": "raf",
"discrete": false
},
{
"name": "mek",
"discrete": false
}
]
}
</pre>

    <p>Each intervention consists of a status variable and value
        variable. There are cases that you may have a combined interventional
        variable that doesn't have the status variable. In this case, just use
        `null`. The data type of each variable can either be discrete or
        continuous. We use a boolean flag to indicate the data type. From the
        above example, we only specified two domain variables in the metadata
        JSON, any variables not specified in the metadata will be treated as
        domain variables.</p>


    <h2>Manipulating Data</h2>

    <p>The data box can also be used to manipulate data sets that have
        already been loaded or simulated. If you create a data box as the child
        of another box containing a data set, you will be presented with a list
        of operations that can be performed on the data. The available data
        manipulations are:</p>

    <h3>Discretize Dataset</h3>

    <p>This operation allows you to make some or all variables in a data
        set discrete. If you choose it, a window will open. </p>

    <img alt="" src="images/data_box_5.png" width="650">

    <p>When the window first opens, no variables are selected, and the
        right side of the window appears blank; in this case, we have already
        selected X1 ourselves. In order to discretize a variable, Tetrad assigns
        all data points within a certain range to a category. You can tell Tetrad
        to break the range of the dataset into approximately even sections
        (Evenly Distributed Intervals) or to break the data points themselves
        into approximately even chunks (Evenly Distributed Values). Use the
        scrolling menu to increase or decrease the number of categories to
        create. You can also rename categories by overwriting the text boxes on
        the left, or change the ranges of the categories by overwriting the text
        boxes on the right. To discretize another variable, simply select it from
        the left. If you want your new data set to include the variables you did
        not discretize, check the box at the bottom of the window.</p>

    <p>You may discretize multiple variables at once by selecting
        multiple variables. In this case, the ranges are not shown, as they will
        be different from variable to variable.</p>

    <h3>Convert Numerical Discrete to Continuous</h3>

    <p>If you choose this option, any discrete variables with numerical
        category values will be treated as continuous variables with real values.
        For example, “1” will be converted to “1.0.”</p>

    <h3>Calculator</h3>

    <p>The Calculator option allows you to add and edit relationships
        between variables in your data set, and to add new variables to the data
        set. </p>

    <img alt="" src="images/data_box_6.png" width="650">

    <p>In many ways, this tool works like the Edit Expression window in a
        generalized SEM parametric model. To edit the formula that defines a
        variable (which will change that variable’s values in the table) type
        that variable name into the text box to the left of the equals sign. To
        create a new variable, type a name for that variable into the text box to
        the left of the equals sign. Then, in the box on the right, write the
        formula by which you wish to define a new variable in place of, or in
        addition to, the old variable. You can select functions from the
        scrolling menu below. (For an explanation of the meaning of some the
        functions, see the section on generalized SEM models in the Parametric
        Model Box chapter.) To edit or create several formulae at once, click the
        “Add Expression” button, and another blank formula will appear. To delete
        a formula, check the box next to it and click the “Remove Selected
        Expressions” button.</p>

    <p>When you click “Save” a table will appear listing the data. Values
        of variables whose formulae you changed will be changed, and any new
        variables you created will appear with defined values.</p>

    <h3>Merge Deterministic Interventional Variables</h3>

    <p>This option looks for pairs of interventional variables (currently
        only discrete variables) that are deterministic and merges them into one
        combined variable. For domain variables that are fully determined,
        we'll add an attribute to them. Later in the knowledge box (Edges and
        Tiers), all the interventional variables (both status and value
        variables) and the fully-determined domain variables will be
        automatically put to top tier. And all other domain variables will be
        placed in the second tier.</p>

    <h3>Merge Datasets</h3>

    <p>This operation takes two or more data boxes as parents and creates
        a data box containing all data sets in the parent boxes. Individual data
        sets will be contained in their own tabs in the resulting box.</p>

    <h3>Convert to Correlation Matrix</h3>

    <p>This operation takes a tabular data set and outputs the lower half
        of the correlation matrix of that data set.</p>

    <h3>Convert to Covariance Matrix</h3>

    <p>This operation takes a tabular data set and outputs the lower half
        of the covariance matrix of that data set.</p>

    <h3>Inverse Matrix</h3>

    <p>This operation takes a covariance or correlation matrix and
        outputs its inverse. (Note: The output will not be acceptable in Tetrad
        as a covariance or correlation matrix, as it is not lower
        triangular.)</p>

    <h3>Simulate Tabular from Covariance</h3>

    <p>This operation takes a covariance matrix and outputs a tabular
        data set whose covariances comply with the matrix.</p>

    <h3>Difference of Covariance Matrices</h3>

    <p>This operation takes two covariance matrices and outputs their
        difference. The resulting matrix will be a well-formatted Tetrad
        covariance matrix data set.</p>

    <h3>Sum of Covariance Matrices</h3>

    <p>This operation takes two covariance matrices and outputs their
        sum. The resulting matrix will be a well-formatted Tetrad covariance
        matrix data set.</p>

    <h3>Average of Covariance Matrices</h3>

    <p>This operation takes two or more covariance matrices and outputs
        their average. The resulting matrix will be a well-formatted Tetrad
        covariance matrix data set.</p>

    <h3>Convert to Time Lag Data</h3>

    <p>This operation takes a tabular data set and outputs a time lag
        data set, in which each variable is recorded several times over the
        course of an experiment. You can specify the number of lags in the data.
        Each contains the same data, shifted by one “time unit.” For instance, if
        the original data set had 1000 cases, and you specify that the time lag
        data set should contain two lags, then the third stage variable values
        will be those of cases 1 to 998, the second stage variable values will be
        those of cases 2 to 999, and the first stage variable values will be
        those of cases 3 to 1000.</p>

    <h3>Convert to Time Lag Data with Index</h3>

    <p>This operation takes a tabular data set and outputs a time lag
        data set in the same manner as “Convert to Time Lag Data,” then adds an
        index variable.</p>

    <h3>Convert to AR Residuals</h3>

    <p>This operation is performed on a time lag data set. Tetrad
        performs a linear regression on each variable in each lag with respect to
        each of the variables in the previous lag, and derives the error terms.
        The output data set contains only the error terms.</p>

    <h3>Whiten</h3>

    <p>Takes a continuous tabular data set and converts it to a data set
        whose covariance matrix is the identity matrix.</p>

    <h3>Nonparanormal Transform</h3>

    <p>Takes a continuous tabular data set and increases its Gaussianity,
        using a nonparanormal transformation to smooth the variables. (Note: This
        operation increases only marginal Gaussianity, not the joint, and in
        linear systems may eliminate information about higher moments that can
        aid in non-Gaussian orientation procedures.) </p>

    <h3>Convert to Residuals</h3>

    <p>The input for this operation is a directed acyclic graph (DAG) and
        a data set. Tetrad performs a linear regression on each variable in the
        data set with respect to all the variables that the graph shows to be
        its parents, and derives the error terms. The output data set contains
        only the error terms.</p>

    <h3>Standardize Data</h3>

    <p>This operation manipulates the data in your data set such that
        each variable has 0 mean and unit variance.</p>

    <h3>Remove Cases with Missing Values</h3>

    <p>If you choose this operation, Tetrad will remove any row in which
        one or more of the values is missing.</p>

    <h3>Replace Missing Values with Column Mode</h3>

    <p>If you choose this operation, Tetrad will replace any missing
        value markers with the most commonly used value in the column.</p>

    <h3>Replace Missing Values with Column Mean</h3>

    <p>If you choose this operation, Tetrad will replace any missing
        value markers with the average of all the values in the column.
        Replace Missing Values with Regression Predictions: If you choose this
        operation, Tetrad will perform a linear regression on the data in order
        to estimate the most likely value of any missing value.</p>

    <h3>Replace Missing Values by Extra Category</h3>

    <p>This operation takes as input a discrete data set. For every
        variable which has missing values, Tetrad will create an extra category
        for that variable (named by default “Missing”) and replace any missing
        data markers with that category.</p>

    <h3>Replace Missing with Random</h3>

    <p>For discrete data, replaces missing values at random from the list
        of categories the variable takes in other cases. For continuous data,
        finds the minimum and maximum values of the column (ignoring the missing
        values) and picks a random number from U(min, max)</p>

    <h3>Inject Missing Data Randomly</h3>

    <p>If you choose this operation, Tetrad will replace randomly
        selected data values with a missing data marker. You can set the
        probability with which any particular value will be replaced (that is,
        approximately the percentage of values for each variable which will be
        replaced with missing data markers).</p>

    <h3>Bootstrap Sample</h3>

    <p>This operation draws a random subset of the input data set (you
        specify the size of the subset) with replacement (that is, cases which
        appear once in the original data set can appear multiple times in the
        subset). The resulting data set can be used along with similar subsets to
        achieve more accurate estimates of parameters.</p>

    <h3>Split by Cases</h3>

    <p>This operation allows you to split a data set into several smaller
        data sets. When you choose it, a window opens. </p>

    <img alt="" src="images/data_box_7.png" width="360">


    <p>If you would like the subsets to retain the ordering they had in
        the original set, click “Original Order.” Otherwise, the ordering of the
        subsets will be assigned at random. You can also increase and decrease
        the number of subsets created, and specify the range of each subset.</p>

    <h3>Permute Rows</h3>

    <p>This operation randomly reassigns the ordering of a data set’s
        cases.</p>

    <h3>First Differences</h3>

    <p>This operation takes a tabular data set and outputs the first
        differences of the data (i.e., if X is a variable in the original data
        set and X’ is its equivalent in the first differences data set, X’1 = X2
        – X1). The resulting data set will have one fewer row than the
        original.</p>

    <h3>Concatenate Datasets</h3>

    <p>This operation takes two or more datasets and concatenates. The
        parent datasets must have the same number of variables.</p>

    <h3>Copy Continuous Variables</h3>

    <p>This operation takes as input a data set and creates a new data
        set containing only the continuous variables present in the original.</p>

    <h3>Copy Discrete Variables</h3>

    <p>This operation takes as input a data set and creates a new data
        set containing only the discrete variables present in the original.</p>

    <h3>Remove Selected Variables</h3>

    <h3>Copy Selected Variables</h3>

    <p>As explained above, you can select an entire column in a data set
        by clicking on the C1, C2, C3, etc… cell above the column. To select
        multiple columns, press and hold the “control” key while clicking on the
        cells. Once you have done so, you can use the Copy Selected Variables
        tool to create a data set in which only those columns appear.</p>

    <h3>Remove Constant Columns</h3>

    <p>This operation takes a data set as input, and creates a data set
        which contains all columns in the original data set except for those with
        constant values (such as, for example, a column containing nothing but
        2’s).</p>

    <h3>Randomly Reorder Columns</h3>

    <p>This operation randomly reassigns the ordering of a data set’s
        variables.</p>

    <h2>Manually Editing Data</h2>

    <p>Under the Edit tab, there are several options to manipulate data.
        If you select a number of cells and click “Clear Cells,” Tetrad will
        replace the data values in the selected cells with a missing data marker.
        If you select an entire row or column and click “Delete selected rows or
        columns,” Tetrad will delete all data values in the row or column, and
        the name of the row or column. (To select an entire column, click on the
        category number above it, labeled C1, C2, C3, and so on. To select an
        entire row, click on the row number to the left of it, labeled 1, 2, 3,
        and so on.) You can also copy, cut, and paste data values to and from
        selected cells. You can choose to show or hide category names, and if you
        click on “Set Constants Col to Missing,” then in any column in which the
        variable takes on only one value (for example, a column in which every
        cell contains the number 2) Tetrad will set every cell to the missing
        data marker.</p>

    <p>Under the Tools tab, the Calculator tool allows you to add or edit
        relationships between variables in the graph. For more information on how
        the Calculator tool works, see “Manipulating Data” section above.</p>

    <h2>Data Information</h2>

    <p>Under the Tools tab, there are options to view information about your data in several
        formats.</p>

    <p>The Plot Matrix tool shows a grid of scatter plots and histograms for selected variables.
        This may be used for continuous, discrete, or mixtures of continuous and discrete data.
        To select which variables to include in the rows and columns of the grid, click the variable
        lists to the right of the tool. To select multiple variables in these lists, use the shift
        or control keys when clicking; shift-click select ranges, whereas control-click will select
        additional single variables.</p>

    <p>Histograms show the data distribution for a variable, with the width of each bar
        representing a range of values and the height of each bar representing how many data
        points fall into that range.</p>

    <p>Scatter plots show a plot of variables taken two at a time. They plot values of one
        variable's values against another variable's values, point by point, and allow one
        to see the distribution of points for the pair of variables.</p>

    <p>If viewing a grid of plots, one wishes to view a single plot in this grid, double-click on
        the desired plot, and it will be magnified so that it is in the only plot viewed.
        Double-click on the magnified plot to return to the grid.</p>

    <p>The “Settings” menu contains some tools to control the output. One may add regression lines
        to the scatter plots or select the number of bins to include in the histograms.</p>

    <p>Finally, one may condition on ranges of variables or particular discrete values by
        selecting “Edit Conditioning Variables and Ranges.” This brings up a dialog that lets one
        add conditioning variables with particular ranges for continuous variables or values for
        discrete values. For continuous ranges, one may pick “Above Average,” “Below Average,” or
        “In n-tile” (where n is specified) or give a particular range manually. One may add as many
        conditions as one prefers; when one clicks “OK,” all plots will be updated to reflect these
        conditioning choices.</p>

    <img alt="" src="images/data_box_8b.png" width="650">
    <img alt="" src="images/data_box_8a.png" width="650">

    <p>The Q-Q Plot tool is a test for normality of distribution. </p>

    <img alt="" src="images/data_box_10.png" width="650">

    <p>If a variable has a distribution which is approximately Normal,
        its Q-Q plot should appear as a straight line with a positive slope. You
        can select the variable whose Q-Q plot you wish to view from the
        drop-down menu on the right.</p>

    <p>The Normality Tests tool gives a text box with the results of the
        Kolmogorov and Anderson Darling Tests for normality for each variable.
        The Descriptive Statistics tool gives a text box with statistical
        information such as the mean, median, and variance of each variable.</p>


    <h1 id="estimator_box"><span class="section_heading">Estimator
    Box</span></h1>

    <p>The estimator box takes as input a data box (or simulation box)
        and a parametric model box and estimates, tests, and outputs an
        instantiated model for the data. Except for the EM Bayes
        estimator, Tetrad estimators do not accept missing values. If your data
        set contains missing values, the missing values can be interpolated or
        removed using the data box. (Note that missing values are allowed in
        various Tetrad search procedures; see the section on the search box.)</p>

    <h2>Possible Parent Boxes of the Estimator Box:</h2>

    <ul class="ul">
        <li>A parametric model box</li>
    </ul>


    <h2>Possible Child Boxes of the Estimator Box:</h2>

    <ul class="ul">
        <li>A graph box</li>
        <li>A simulation box</li>
        <li>An
            updater box
        </li>
    </ul>

    <h2>ML Bayes Estimations</h2>

    <p>Bayes nets are acyclic graphical models parameterized by the
        conditional probability distribution of each variable on its parents'
        values, as in the instantiated model box. When the model contains no
        latent variables, the joint distribution of the variables equals the
        product of the distributions of the variables conditional on their
        respective parents. The maximum likelihood (ML) estimate of the joint
        probability distribution under a model is the product of the
        corresponding frequencies in the sample. </p>

    <p>The ML Bayes estimator, because it estimates Bayes IMs, works only
        on models with discrete variables. The model estimated must not include
        latent variables, and the input data set must not include missing data
        values. A sample estimate looks like this:</p>

    <img alt="" src="images/estimator_box_1.png" width="650">

    <p>The Model tab works exactly as it does in a Bayes instantiated
        model. The Model Statistics tab provides the p-value for a chi square
        test of the model, degrees of freedom, the chi square value, and the
        Bayes Information Criterion (BIC) score of the model. Note that BIC
        is calculated as 2L -</p>

    <h2>Dirichlet Estimations</h2>

    <p>A Dirichlet estimate estimates a Bayes instantiated model using a
        Dirichlet distribution for each category. In a Dirichlet estimate, the
        probability of each value of a variable (conditional on the values of the
        variable’s parents) is estimated by adding together a prior pseudo count
        (which is 1, by default, of cases and the number of cases in which the
        variable takes that value in the data, and then dividing by the total
        number of cases in the pseudocounts and in the data with that
        configuration of values of parent variables. The default prior
        pseudo-count can be changed inside the box. (For a full explanation of
        pseudocounts and Dirichlet estimate, see the section on Dirichlet
        instantiated models.) </p>

    <p>The Dirichlet estimator in TETRAD does not work if the input data
        set contains missing data values.</p>

    <h2>EM Bayes Estimations</h2>

    <p>The EM Bayes estimator takes the same input and gives the same
        output as the ML Bayes estimator, but is designed to handle data sets
        with missing data values, and input models with latent variables.</p>

    <h2>SEM Estimates</h2>

    <p>A SEM estimator estimates the values of parameters for a SEM
        parametric model. SEM estimates do not work if the input data set
        contains missing data values. A sample output looks like this: </p>

    <img alt="" src="images/estimator_box_2.png" width="650">

    <p>Tetrad provides five parameter optimizers: RICF,( Drton, M., &amp;
        Richardson, T. S. (2004, July). Iterative conditional fitting for
        Gaussian ancestral graph models. <i>In Proceedings of the 20th conference
            on Uncertainty in artificial intelligence</i> (pp. 130-137). AUAI Press).
        expectation­-maximization (EM), regression, Powell Journal of
        Econometrics 25 (1984) 303-325) and random search. Accurate regression
        estimates assume that the input parametric model is a DAG, and that its
        associated statistics are based on a linear, Gaussian model. The EM
        optimizer has the same input constraints as regression, but can handle
        latent variables. </p>

    <p>Tetrad also provides two scores that can be used in estimation:
        feasible generalized the least squares (FGLS) and Full Information Maximum
        Likelihood (FML). </p>

    <p>If the graph for the SEM is a DAG, and we may assume that the SEM
        is linear with Gaussian error terms, we use multilinear regression to
        estimate coefficients and residual variances. Otherwise, we use a
        standard maximum likelihood fitting function (see Bollen, Structural
        Equations with Latent Variables, Wiley, 1989, pg. 107) to minimize the
        distance between (a) the covariance over the variables as implied by the
        coefficient and error covariance parameter values of the model and (b)
        the sample covariance matrix. Following Bollen, we denote this function
        Fml; it maps points in parameter values space to real numbers, and, when
        minimized, yields the maximum likelihood estimation point in parameter
        space.</p>

    <p>In either case, a Fml value may be obtained for the maximum
        likelihood point in parameter space, either by regression or by direct
        minimization of the Fml function itself. The value of Fml at this minimum
        (maximum likelihood) point, multiplied by N - 1 (where N is the sample
        size), yields a chi square statistics (ch^2) for the model, which when
        referred to the chi square table with appropriate degrees of freedom,
        yields a model p value. The degrees of freedom (dof) in this case is
        equal to the m(m-1)/2 - f, where m is the number of measured variables,
        and f is the number of free parameters, equal to the number of
        coefficient parameters plus the number of covariance parameters. (Note
        that the degrees of freedom many be negative, in which case estimation
        should not be done.) The BIC score is calculated as ch^2 - dof *
        log(N), so "higher is better.".</p>

    <p>You can change which score optimizer Tetrad uses by choosing them
        from the drop-down menus at the bottom of the window and clicking
        “Estimate Again.”</p>

    <p>The Tabular Editor and Implied Matrices tabs function exactly as
        they do in the instantiated model box, but in the estimator box, the last
        three columns of the table in the Tabular Editor tab are filled in. The
        SE, T, and P columns provide the standard errors, t statistics, and p
        values of the estimation.</p>

    <p>The Model Statistics tab provides the degrees of freedom, chi
        square, p value, comparative fit index (CFI), root-mean-square error of
        approximation (RMSEA) and BIC score of a test of the model. It should be
        noted that while these test statistics are standard, they are not in
        general correct. See Mathias Drton, 2009, Likelihood ratio tests and
        singularities. Annals of Statistics 37(2):979-1012.
        arXiv:math.ST/0703360. Note also that BIC is calculated as 2L - k ln N,
        so "higher is better." </p>

    <p>When the EM algorithm is used with latent variable models, we
        recommend multiple random restarts. The number of restarts can be set in
        the lower right hand corner of the Estimator Box.

    <h2>Generalized Estimator</h2>

    <p>A generalized graphical model may have non-linear relations and
        non-Gaussian distributions. These models are automatically estimated by
        the Powell method, which seeks a maximum likelihood solution.</p>


    <h1 id="updater_box"><span class="section_heading">Updater
    Box</span></h1>

    <p>The updater box takes an instantiated model as input, and, given
        information about the values of parameters in that model, updates the
        information about the values and relationships of other parameters.</p>

    <p>The Updater allows the user to specify values of variables as
        “Evidence.” The default is that the conditional probabilities (Bayes net
        models; categorical variables) or conditional means (SEM models;
        continuous variables) are computed. For any variable for which evidence
        is specified, the user can click on “Manipulated,” in which case the
        Updater will calculate the conditional probabilities or conditional means
        for other variables when the evidence variables are forced to have their
        specified values. In manipulated calculations, all connections into a
        measured variable are discarded, the manipulated variables are treated as
        independent of their causes in the graph, and probabilities for variables
        that are causes of the manipulated variables are unchanged. </p>

    <p>There are four available updater algorithms in Tetrad: the
        approximate updater, the row summing exact updater, and the Junction Tree Updater,
        and the SEM updater. All except for
        the SEM updater function only when given Bayes instantiated models as
        input; the SEM updater functions when given a SEM instantiated model as
        input. None of the updaters work on cyclic models.</p>

    <h2>Possible Parent Boxes of the Updater Box:</h2>

    <ul class="ul">
        <li>An instantiated model box</li>
        <li>An estimator
            box
        </li>
    </ul>


    <h2>Possible Child Boxes of the Updater Box:</h2>

    <ul class="ul">
        <li>An instantiated model box (Note that the
            instantiated model will have the updated parameters)
        </li>
    </ul>

    <h2>Approximate Updater</h2>

    <p>The approximated updater is a fast but inexact algorithm. It
        randomly draws a sample data set from the instantiated model and
        calculates the conditional frequency of the variable to be estimated.</p>

    <p>Take, for example, the following instantiated model: </p>

    <img alt="" src="images/updater_box_1.png" width="650">

    <p>When it is input into the approximate updater, the following
        window results:</p>

    <img alt="" src="images/updater_box_2.png" width="650">

    <p>If we click “Do Update Now” now, without giving the updater any
        evidence, the right side of the screen changes to show us the marginal
        probabilities of the variables.</p>

    <img alt="" src="images/updater_box_3.png" width="360">

    <p>The blue lines, and the values listed across from them, indicate
        the probability that the variable takes on the given value in the input
        instantiated model. The red lines indicate the probability that the
        variable takes on the given value, given the evidence we’ve added to the
        updater. </p>

    <p>Since we have added no evidence to the updater, the red and blue
        lines are very similar in length. To view the marginal probabilities for
        a variable, either click on the variable in the graph to the left, or
        choose it from the scrolling menu at the top of the window. At the
        moment, they should all be very close to the marginal probabilities taken
        from the instantiated model.</p>

    <p>Now, we’ll return to the original window. We can do so by clicking
        “Edit Evidence” under the Evidence tab. Suppose we know that X1 takes on
        the value 1 in our model, or suppose we merely want to see how X1 taking
        that value affects the values of the other variables. We can click on the
        box that says “1” next to X1. When we click “Do Update Now,” we again get
        a list of the marginal probabilities for X1.</p>

    <img alt="" src="images/updater_box_4.png" width="360">

    <p>Now that we have added evidence, the “red line” marginal
        probabilities have changed; for X1, the probability that X1=1 is 1,
        because we’ve told Tetrad that that is the case. Likewise, the
        probabilities that X1=0 and X1=2 are both 0.</p>

    <p>Now, let’s look at the updated marginal probabilities for X2, a
        parent of X1.</p>

    <img alt="" src="images/updater_box_5.png" width="360">

    <img alt="" src="images/updater_box_6.png" width="360">

    <p>The first image is the marginal probabilities before we added the
        evidence that X1=1. The second image is the updated marginal
        probabilities. They have changed; in particular, it has become much more
        likely that X2=0.</p>

    <p>Under the Mode tab, we can change the type of information that the
        updater box gives us. The mode we have been using so far is “Marginals
        Only (Multiple Variables).” We can switch the mode to “In-Depth
        Information (Single Variable).” Under this mode, when we perform the
        update, we receive more information (such as log odds and joints, when
        supported; joint probabilities are not supported by the approximate
        updater), but only about the variable which was selected in the graph
        when we performed the update. To view information about a different
        variable, we must re-edit the evidence with that variable selected.</p>

    <p>If the variable can take one of several values, or if we know the
        values of more than one variable, we can select multiple values by
        pressing and holding the Shift key and then making our selections. For
        instance, in the model above, suppose that we know that X1 can be 1 or 2,
        but not 0. We can hold the Shift key and select the boxes for 1 and 2,
        and when we click “Do Update Now,” the marginal probabilities for X2 look
        like this: </p>

    <img alt="" src="images/updater_box_7.png" width="650">

    <p>Since X1 must be 1 or 2, the updated probability that it is 0 is
        now 0. The marginal probabilities of X2 also change: </p>

    <img alt="" src="images/updater_box_8.png" width="650">

    <p>The updated marginal probabilities are much closer to their
        original values than they were when we knew that X1 was 1.</p>

    <p>Finally, if we are arbitrarily setting the value of a
        variable—that is, the values of its parents have no effect on its
        value—we can check the “Manipulated” box next to it while we are we
        editing evidence, and the update will reflect this information.</p>

    <p>Note that multiple values cannot be selected for evidence for SEM
        models.</p>

    <h2>Row Summing Exact Updater</h2>

    <p>The row summing exact updater is a slower but more accurate
        updater than the approximate updater. The complexity of the algorithm
        depends on the number of variables and the number of categories each
        variable has. It creates a full exact conditional probability table and
        updates from that. Its window functions exactly as the approximate
        updater does, with two exceptions: in “Multiple Variables” mode, you can
        see conditional as well as marginal probabilities, and in “Single
        Variable” mode, you can see joint values. </p>

    <h2>Junction Tree Exact Updater</h2>

    <p>The Junction Tree exact updater is another exact learning
        algorithm. Its window functions exactly as the approximate updater down,
        with one exception: in “Multiple Variables” mode, you can see conditional
        as well as marginal probabilities.</p>

    <h2>SEM Updater</h2>

    <p>The SEM updater does not deal with marginal probabilities;
        instead, it estimates means.</p>


    <img alt="" src="images/updater_box_9.png" width="360">

    <p>When it is input to the SEM updater, the following window results:
    </p>

    <img alt="" src="images/updater_box_10.png" width="650">

    <p>Suppose we know that the mean of X1 is .5. When we enter that
        value into the text box on the left and click “Do Update Now,” the model
        on the right updates to reflect that mean, changing the means of both X1
        and several other variables. In the new model, the means of X2, X4, and
        X5 will all have changed. If we click the “Manipulated” check box as
        well, it means that we have arbitrarily set the mean of X1 to .5, and
        that the value of its parent variable, X4, has no effect on it. The
        graph, as well as the updated means, changes to reflect this.</p>

    <p>The rest of the window has the same functionality as a SEM
        instantiated model window, except as noted above.</p>

    <h1 id="knowledge_box"><span class="section_heading">Knowledge
    Box</span></h1>

    <p>The knowledge box takes as input a graph or a data set and imposes
        additional constraints onto it, to aid with search.</p>

    <h2>Possible Parent Boxes of the Knowledge Box:</h2>

    <ul class="ul">
        <li>A graph box</li>
        <li>A parametric model box</li>
        <li>An instantiated model box</li>
        <li>A data box</li>
        <li>A simulation
            box
        </li>
        <li>A search box</li>
        <li>Another knowledge box</li>
    </ul>

    <h2>Possible Child Boxes of the Knowledge Box:</h2>

    <ul class="ul">
        <li>A search box</li>
        <li>Another knowledge box</li>
    </ul>

    <h2>Tiers and Edges</h2>

    <p>The tiers and edges option allows you to sort variables into
        groupings that can or cannot affect each other. It also allows you to
        manually add forbidden and required edges one at a time.</p>

    <h3>Tiers</h3>

    <p>The tiers tab for a graph with ten variables looks like this: </p>

    <img alt="" src="images/knowledge_box_1.png" width="650">

    <p>Tiers separate your variables into a timeline. Variables in
        higher-numbered tiers occur later than variables in lower-numbered tiers,
        which gives Tetrad information about causation. For example, a variable
        in Tier 3 could not possibly be a cause of a variable in Tier 1.</p>

    <p>To place a variable in a tier, click on the variable in the “Not
        in tier” box, and then click on the box of the tier. If you check the
        “Forbid Within Tier” box for a tier, variables in that tier will not be
        allowed to be causes of each other. To increase or decrease the number of
        tiers, use the scrolling box in the upper right corner of the window.</p>

    <p>You can quickly search, select and place variables in a tier using
        the Find button associated with each tier. Enter a search string into the
        Find dialogue box using asterisks as wildcard indicators. E.g., "X1*"
        would find and select variables X1 and X10.</p>

    <p>You can also limit the search such that edges from one tier only
        are added to the next immediate tier e.g., if Tier 1 "Can cause only next
        tier" is checked then edges from variables in Tier 1 to variables in Tier
        3 are forbidden.</p>

    <h3>Handling of Interventional Variables in Tiers</h3>

    <p>If you have annotated your variables with interventional status
        and interventional value tags using a metadata JSON file (see Data Box
        section) the Tiers and Edges panel will automatically place these
        variables in Tier 1. If you have information about the effects of the
        intervention variables you can use the groups tab to indicate this.</p>

    <h3>Groups</h3>

    <p>The groups tab for a graph with four variables looks like this:
    </p>

    <img alt="" src="images/knowledge_box_2.png" width="650">

    <p>In the groups tab, you can specify certain groups of variables
        which are forbidden or required to cause other groups of variables. To
        add a variable to the “cause” section of a group, click on the variable
        in the box at the top, and then click on the box to the left of the
        group’s arrow. To add a variable to the “effect” section of a group,
        click on the variable in the box at the top, and then click on the box to
        the right of the group’s arrow. You can add a group by clicking on one of
        the buttons at the top of the window, and remove one by clicking the
        “remove” button above the group’s boxes.</p>

    <h3>Edges</h3>

    <p>The edges tab for a graph with four variables looks like this:
    </p>

    <img alt="" src="images/knowledge_box_3.png" width="650">

    <p>In the edges tab, you can require or forbid individual causal
        edges between variables. To add an edge, click the type of edge you’d
        like to create, and then click and drag from the “cause” variable to the
        “effect” variable.</p>

    <p>You can also use this tab to see the effects of the knowledge you
        created in the other tabs by checking and unchecking the boxes at the
        bottom of the window. You can adjust the layout to mimic the layout of
        the source (by clicking “source layout”) or to see the variables in their
        timeline tiers (by clicking “knowledge layout”).</p>

    <h2>Forbidden Graph</h2>

    <p>If you use a graph as input to a knowledge box with the “Forbidden
        Graph” operation, the box will immediately add all edges in the parent
        graph as forbidden edges. It will otherwise work like a Tiers and Edges
        box.</p>

    <h2>Required Graph</h2>

    <p>If you use a graph as input to a knowledge box with the “Required
        Graph” operation, the box will immediately add all edges in the parent
        graph as required edges. It will otherwise work like a Tiers and Edges
        box.</p>

    <h2>Measurement Model</h2>

    <p>This option allows you to build clusters for a measurement model.
        When first opened, the window looks like this:</p>

    <img alt="" src="images/knowledge_box_4.png" width="650">

    <p>You can change the number of clusters using the text box in the
        upper right hand corner. To place a variable in a cluster, click and drag
        the box with its name into the cluster pane. To move multiple variables
        at once, shift- or command-click on the variables, and (without releasing
        the shift/command button or the mouse after the final click) drag. In the
        search boxes, these variables will be assumed to be children of a common
        latent cause.</p>


    <h1 id="simulation_box"><span class="section_heading">Simulation
    Box</span></h1>

    <p>The simulation box takes a graph, parametric model, or
        instantiated model and uses it to simulate a data set.</p>

    <h2>Possible Parent Boxes of the Simulation Box</h2>

    <ul class="ul">
        <li>A graph box</li>
        <li>A parametric model box</li>
        <li>An instantiated model box</li>
        <li>An estimator box</li>
        <li>A data
            box
        </li>
        <li>Another simulation box</li>
        <li>A search box</li>
        <li>An
            updater box
        </li>
        <li>A regression box</li>
    </ul>


    <h2>Possible Child Boxes of the Simulation Box</h2>

    <ul class="ul">
        <li>A graph box</li>
        <li>A compare box</li>
        <li>A
            parametric model box
        </li>
        <li>An instantiated model box</li>
        <li>An
            estimator box
        </li>
        <li>A data box</li>
        <li>Another simulation box</li>
        <li>A search box</li>
        <li>A classify box</li>
        <li>A regression box</li>
        <li>A knowledge box</li>
    </ul>


    <h2>Using the Simulator Box</h2>

    <p>When you first open the simulation box, you will see some
        variation on this window:</p>

    <img alt="" src="images/simulation_box_1.png" width="650">

    <p>The “True Graph” tab contains the graph from which data is
        simulated. </p>


    <h3>The Simulation Box with no Input</h3>

    <p>Because it has no input box to create constraints, a parentless
        simulation box offers the greatest freedom for setting the graph type,
        model type, and parameters of your simulated data. In particular, it is
        the only way that the simulation box will allow you to create a random
        graph or graphs within the box. (If you are simulating multiple data
        sets, and want to use a different random graph for each one, you can
        select “Yes” under “Yes if a different graph should be used for each
        run.”) You can choose the type of graph you want Tetrad to create from
        the “Type of Graph” drop-down list.</p>

    <h5>Random Forward DAG</h5>

    <p> This option creates a DAG by randomly adding forward edges (edges
        that do not point to a variable’s ancestors) one at a time. You can
        specify graph parameters such as number of variables, maximum and minimum
        degrees, and connectedness.</p>

    <h5>Erdos Renyi DAG</h5>

    <p> This option creates a DAG by randomly adding edges with a given edge
        probability. The graph is then oriented as a DAG by choosing a
        causal order.</p>

    <h5>Scale Free DAG</h5>

    <p> This option creates a DAG whose variable’s degrees obey a power
        law. You can specify graph parameters such as number of variables, alpha,
        beta, and delta values.</p>

    <h5>Cyclic, constructed from small loops</h5>

    <p> This option creates a cyclic graph. You can specify graph
        parameters such as number of variables, maximum and average degrees, and
        the probability of the graph containing at least one cycle.</p>

    <p> It is very important when dealing with cyclic models to realize
        that the potential exists always to instantiate these models with
        coefficients that are too large. Always, to keep simulations from
        "exploding" ("diverging"--i.e., having simulation values that
        tend to infinity over time), it is necessary to make sure that
        coefficient values are relatively small, usually less than 1.
        One can tell whether a model will produce simulations that diverge
        in value by testing the eigenvalues of the covariance matrix
        of the data. If any of these eigenvalues are greater than 1,
        the potential exists for the simulation to "explode" toward
        infinity over time.</p>

    <h5>Random One Factor MIM</h5>

    <p> This option creates a one-factor multiple indicator model. You
        can specify graph parameters such as number of latent nodes, number of
        measurements per latent, and number of impure edges.</p>

    <h5>Random Two Factor MIM</h5>

    <p> This option creates a two-factor multiple indicator model. You
        can specify graph parameters such as number of latent nodes, number of
        measurements per latent, and number of impure edges.</p>

    <p>In addition to the graph type, you can also specify the type of
        model you would like Tetrad to simulate.</p>

    <h5>Bayes net</h5>

    <p> Simulates a Bayes instantiated model. You can specify model
        parameters including maximum and minimum number of categories for each
        variable.</p>

    <h5>Structural Equation Model</h5>

    <p> Simulates a SEM instantiated model. You can specify model
        parameters including coefficient, variance, and covariance ranges.</p>

    <h5>Linear Fisher Model</h5>

    <p>Simulates data using a linear Markov 1 DBN without concurrent
        edges. The Fisher model suggests that shocks should be applied at
        intervals and the time series be allowed to move to convergence between
        shocks. This simulation has many parameters that can be adjusted, as
        indicated in the interface. The ones that require some explanation are as
        follows.</p>

    <ul class="ul">
        <li>Low end of coefficient range, high end of
            coefficient range, low end of variance range, high end of variance range.
            Each variable is a linear function of the parents of the variable (in the
            previous time lag) plus Gaussian noise. The coefficients are drawn
            randomly from U(a, b) where a is the low end of the coefficient range and
            b is the high end of the coefficient range. Here, a < b. The Gaussian
            noise is drawn uniformly from U(c, d), where c is the low end of the
            variance range and d is the high end of the variance range. Here, c < d.
        </li>
        <li>Yes, if negative values should be considered. If no, only
            positive values will be recorded. This should not be used for large
            numbers of variables, since it is more difficult to find cases with all
            positive values when the number of variables is large.
        </li>
        <li>Percentage of discrete variables. The model generates continuous
            data, but some or all of the variables may be discretized at random. The
            user needs to indicate the percentage of variables (randomly chosen that
            one wishes to have discretized. The default is zero—i.e., all continuous
            variables.
        </li>
        <li>Number of categories of discrete variables. For the
            variables that are discretized, the number of categories to use to
            discretize each of these variables.
        </li>
        <li>Sample size. The number of
            records to be simulated.
        </li>
        <li>Interval between shocks. The number of
            time steps between shocks in the model.
        </li>
        <li>Interval between data
            recordings. The data are recorded every so many steps. If one wishes to
            allow to completely converge between steps (i.e., produce equilibrium
            data), set this interval to some large number like 20 and set the
            interval between shocks likewise to 20 Other values can be used, however.
        </li>
        <li>Epsilon for convergence. Even if you set the interval between
            data recordings to a large number, you can specify an epsilon such that
            if all values of variables differ from their values one time step back by
            less than epsilon, the series will be taken to have converged, and the
            remaining steps between data recordings will be skipped, the data point
            being recorded at convergence.
        </li>
    </ul>

    <h5>Lee &amp; Hastie</h5>

    <p> This is a model for simulating mixed data (data with both
        continuous and discrete variables. The model is given in Lee J, Hastie T.
        2013, Structure Learning of Mixed Graphical Models, Journal of Machine
        Learning Research 31: 388-396. Here, mixtures of continuous and discrete
        variables are treated as log-linear.</p>

    <ul class="ul">
        <li>Percentage of discrete variables. The model
            generates continuous data, but some or all of the variables may be
            discretized at random. The user needs to indicate the percentage of
            variables (randomly chosen that one wishes to have discretized. The
            default is zero—i.e., all continuous variables.
        </li>
        <li>Number of
            categories of discrete variables. For the variables that are discretized,
            the number of categories to use to discretize each of these variables.
        </li>
        <li>Sample size. The number of records to be simulated.</li>
    </ul>

    <h5>Time Series</h5>

    <p> This is a special simulation for representing time series.
        Concurrent edges are allowed. This can take a Time Series Graph as input,
        in which variables in the current lag are written as functions of the
        parents in the current and previous lags.</p>

    <ul class="ul">
        <li>Sample size. The number of records to be
            simulated.
        </li>
    </ul>

    <h5>Boolean Glass</h5>

    <p> The instantiated model used to simulate the data will be
        re-parameterized for each run of the simulation.</p>


    <h3>The Simulation Box with a Graph Input</h3>

    <p>If you input a graph, you will be able to simulate any kind of
        model, with any parameters. But the model will be constrained by the
        graph you have input (or the subgraph you choose in the “True Graph”
        tab.) Because of this, if you create a simulation box with a graph as a
        parent, you will not see the “Type of Graph” option.</p>

    <h3>The Simulation Box with a Parametric Model Input</h3>

    <p>At the time of writing, a simulation box with a parametric model
        input acts as though the PM’s underlying graph had been input into the
        box.</p>


    <h3>The Simulation Box with an Instantiated Model Input</h3>

    <p>If you input an instantiated model, your only options will be the
        sample size of your simulation and the number of data sets you want to
        simulate; Tetrad will simulate every one of them based on the parameters
        of the IM. The model will not be re-parameterized for each run of the
        simulation.</p>


    <h1 id="search_box"><span class="section_heading">Search
    Box</span></h1>

    <p>The search box takes as input a data set (in either a data or
        simulation box) and optionally a knowledge box, and searches for causal
        explanations represented by directed graphs. The result of a search is
        not necessarily—and not usually—a unique graph, but an object such as a
        CPDAG that represents a set of graphs, usually a Markov Equivalence
        class. More alternatives can be found by varying the parameters of search
        algorithms.</p>

    <h2>Possible Parent Boxes of the Search Box</h2>

    <ul class="ul">
        <li>A graph box</li>
        <li>A parametric model box</li>
        <li>An instantiated model box</li>
        <li>An estimator box</li>
        <li>A data
            box
        </li>
        <li>A simulation box</li>
        <li>Another search box</li>
        <li>A
            regression box
        </li>
        <li>A knowledge box</li>
    </ul>


    <h2>Possible Child Boxes of the Simulation Box</h2>

    <ul class="ul">
        <li>A graph box</li>
        <li>A compare box</li>
        <li>A
            parametric model box
        </li>
        <li>A simulation box</li>
        <li>Another search
            box
        </li>
        <li>A knowledge box</li>
    </ul>

    <h2>Using the Search Box</h2>

    <p><b>For more information that in included about the search algorithms than
        is included in the text below, please see our
        <a href="https://www.phil.cmu.edu/tetrad-javadocs/7.4.0/edu/cmu/tetrad/search/package-summary.html">
            Javadocs for the Search package</a>.</b></p>

    <p>Using the search box requires you to select an algorithm
        (optionally select a test/score), confirm/change search parameters and
        finally run the search.</p>

    <img alt="" src="images/search_box_1.png" width="650">

    <p>The search box first asks what algorithm, statistical tests and/or
        scoring functions you would like to use in the search. The upper left
        panel allows you to filter for different types of search algorithms with
        the results of filtering appearing in the middle panel. Selecting a
        particular algorithm will update the algorithm description on the right
        panel.</p>

    <p>Choosing the correct algorithm for your needs is an important
        consideration. Tetrad provides over 30 search algorithms (and more are
        added all the time) each of which makes different assumptions about
        the input data, uses different parameters, and produces different kinds
        of output. For instance, some algorithms produce Markov blankets or
        CPDAGs, and some produce full graphs; some algorithms work best with
        Gaussian or non-Gaussian data; some algorithms require an alpha value,
        some require a penalty discount, and some require both or neither. You
        can narrow down the list using the “Algorithm filter" panel, which allows
        you to limit the provided algorithms according to whichever factor is
        important to you.</p>

    <p>Depending on the datatype used as input for the search (i.e.,
        continuous, discrete, or mixed data) and algorithm selected, the lower
        left panel will display available statistical tests (i.e., tests of
        independence) and Bayesian scoring functions.</p>

    <p>After selecting the algorithm and desired test/score, click on
        "Set parameters" which will allow you to confirm/change the parameters of
        the search. </p>

    <p>After optionally changing any search parameters, click on "Run
        Search and Generate Graph" which will execute the search.</p>

    <p>Notably there are some experimental algorithms available in this box.
        To see these, select File->Settings->Enable Experimental.</p>


    <h2>Search Algorithms</h2>

    <h3>PC</h3>

    <h4>Description</h4>

    <div id="pc">

        <p>PC algorithm (Spirtes and Glymour, Social Science Computer
            Review, 1991) is a CPDAG search which assumes that the underlying
            causal structure of the input data is acyclic, and that no two
            variables are caused by the same latent (unmeasured) variable. In
            addition, it is assumed that the input data set is either entirely
            continuous or entirely discrete; if the data set is continuous, it is
            assumed that the causal relation between any two variables is linear,
            and that the distribution of each variable is Normal. Finally, the
            sample should ideally be i.i.d.. Simulations show that PC and several
            of the other algorithms described here often succeed when these
            assumptions, needed to prove their correctness, do not strictly hold.
            The PC algorithm will sometimes output double-headed edges. In the
            large sample limit, double-headed edges in the output indicate that
            the adjacent variables have an unrecorded common cause, but PC tends
            to produce false positive double-headed edges on small samples.</p>

        <p>The PC algorithm is correct whenever decision procedures for
            independence and conditional independence are available. The
            procedure conducts a sequence of independence and conditional
            independence tests, and efficiently builds a CPDAG from the results
            of those tests. As implemented in TETRAD, PC is intended for
            multinomial and approximately Normal distributions with i.i.d. data.
            The tests have an alpha value for rejecting the null hypothesis,
            which is always a hypothesis of independence or conditional
            independence. For continuous variables, PC uses tests of zero
            correlation or zero partial correlation for independence or
            conditional independence respectively. For discrete or categorical
            variables, PC uses either a chi square or a g square test of
            independence or conditional independence (see Causation, Prediction,
            and Search for details on tests). In either case, the tests require
            an alpha value for rejecting the null hypothesis, which can be
            adjusted by the user. The procedures make no adjustment for multiple
            testing. (For PC, CPC, FCI, all testing searches.) </p>

        <p>The PC algorithm as given in Causation, Prediction and Search (Spirtes,
            Glymour, and Scheines, 2000) comes with three heuristics designed
            to reduce dependence on the order of the variables. The heuristic PC-1
            simple sorts the variables in alphabetical order. The heuristic PC-2
            and PC-3 sort edges by their p-values in the search. PP-3 further sorts
            parents of nodes in reverse order by the p-values of the conditional
            independence facts used to removed edges in the search. Please see
            Causation, Prediction, and Search for more details for these
            heuristics.</p>

        <p>Note: If one wants to analyze time series data using this algorithm,
            one may set the time lag parameter to a value greater than 0, which
            will automatically apply the time lag transform. The same goes for any
            algorithm that has this parameter available in the interface.</p>

    </div>

    <h4>Input Assumptions</h4>

    <p>The algorithm effectively takes conditional independence facts as
        input. Thus, it will work for any type of data for which a conditional
        independence facts are known. In the interface, it will work for linear,
        Gaussian data (the Fisher Z test), discrete multinomial data the Chi
        Square test) and mixed multinomial/Gaussian data (the Conditional
        Gaussian test).</p>

    <h4>Output Format</h4>

    <p>The graph outputs a CPDAG. This is an equivalence class of
        directed acyclic graphs (DAGs). Each DAG in the equivalence class has all
        the adjacencies (and no more) of the CPDAG. Each oriented edge in the
        CPDAG is so oriented in each of the DAG in the equivalence class.
        Unoriented edges in the equivalence class cannot be oriented by
        conditional independence facts. For example, if the model is X->Y->Z, the
        output will be X—Y—Z. There are no collider in this model, so the
        algorithm will not detect one. Since there are no colliders, the Meek
        cannot orient additional edges. If the model were X<-Y<-Z, the output
        would also be X—Y—Z; this model is in the same equivalence class as
        X->Y->Z. The model X->Y<-Z would be its own equivalence class, since the
        collider in this model can be oriented. See Spirtes et al. (2000) for
        more details.</p>

    <h4>Parameters</h4>

    <p><a href="#alpha">alpha</a>, <a href="#depth">depth</a></p>

    <h3>The CPC Algorithm</h3>

    <h4>Description</h4>

    <div id="cpc">

        <p>The CPC (Conservative PC) algorithm (Ramsey et al., ??)
            modifies the collider orientation step of PC to make it more
            conservative—that is, to increase the precision of collider
            orientations at the expense of recall. It does this as follows. Say
            you want to orient X—Y—Z as a collider or a noncollider; the PC
            algorithm looks at variables adjacent to X or variables adjacent to Z
            to find a subset S such that X is independent of Z conditional on S.
            The CPC algorithm considers all possible such sets and records the
            set on which X is conditionally independent of Z. If all of these
            sets contain Y, it orients X—Y—Z as a noncollider. If none of them
            contains Z, if orient X—Y—Z as a collider. If some contain Z but
            other don’t, it marks it as ambiguous, with an underline. Thus, the
            output is ambiguous between CPDAGs; in order to get a specific CPDAG
            out of the output, one needs first to decide whether the underlined
            triples are colliders or noncolliders and then to apply the
            orientation rules in Meek (1997).</p>

        <p>The PC algorithm is correct whenever decision procedures for
            independence and conditional independence are available. The
            procedure conducts a sequence of independence and conditional
            independence tests, and efficiently builds a CPDAG from the results
            of those tests. As implemented in TETRAD, PC is intended for
            multinomial and approximately Normal distributions with i.i.d. data.
            The tests have an alpha value for rejecting the null hypothesis,
            which is always a hypothesis of independence or conditional
            independence. For continuous variables, PC uses tests of zero
            correlation or zero partial correlation for independence or
            conditional independence respectively. For discrete or categorical
            variables, PC uses either a chi square or a g square test of
            independence or conditional independence (see Causation, Prediction,
            and Search for details on tests). In either case, the tests require
            an alpha value for rejecting the null hypothesis, which can be
            adjusted by the user. The procedures make no adjustment for multiple
            testing. (For PC, CPC, FCI, all testing searches.) </p>

        <p>Note: If one wants to analyze time series data using this algorithm,
            one may set the time lag parameter to a value greater than 0, which
            will automatically apply the time lag transform. The same goes for any
            algorithm that has this parameter available in the interface.</p>


    </div>

    <h4>Input Assumptions</h4>

    <p>Same as for PC.</p>

    <h4>Output Format</h4>

    <p>An e-CPDAG (extended CPDAG), consistent of directed and undirected
        edges where some of the triple may have been marked with underlines to
        indicate ambiguity, as above. It may be that bidirected edges are
        oriented as X->Y<->X<-W if two adjacent colliders are oriented; this is
        not ruled out.</p>

    <h4>Parameters</h4>

    <p><a href="#alpha">alpha</a>, <a href="#depth">depth</a></p>

    <h3>The PcMax Algorithm</h3>

    <h4>Description</h4>

    <div id="pcmax">

        <p>Similar in spirit to CPC but orients all unshielded triples
            using maximum likelihood conditioning sets. The idea is as follows.
            The adjacency search is the same as for PC, but colliders are
            oriented differently. Let X—Y—Z be an unshielded triple (X not
            adjacent to Z) and find all subsets S from among the adjacents of X
            or the adjacents of Z such that X is independent of Z conditional on
            S. However, instead of using the CPC rule to orient the triple,
            instead just list the p-values for each of these conditional
            independence judgments and pick the set S’ that yields the highest
            such p-value. Then orient X->Y<-Z if S does not contain Y and X—Y—Z
            otherwise. This orients all unshielded triples. It’s possible (though
            rare) that adjacent triples both be oriented as 2-cycles,
            X->Y<->Z<-W. If this happens, pick one of the other of these triples
            or orient as a collider, arbitrarily. This guarantees that the
            resulting graph will be a CPDAG.</p>

        <p>Note: If one wants to analyze time series data using this algorithm,
            one may set the time lag parameter to a value greater than 0, which
            will automatically apply the time lag transform. The same goes for any
            algorithm that has this parameter available in the interface.</p>


    </div>

    <h4>Input Assumptions</h4>

    <p>Same as for PC.</p>

    <h4>Output Format</h4>

    <p>Same as PC, a CPDAG.</p>

    <h4>Parameters</h4>

    <p><a href="#alpha">alpha</a>, <a href="#depth">depth</a>, <a
            href="#useMaxPOrientationHeuristic">useMaxPOrientationHeuristic</a>, <a
            href="#maxPOrientationMaxPathLength">maxPOrientationMaxPathLength</a></p>

    <h3>The FGES Algorithm</h3>

    <h4>Description</h4>

    <div id="fges">

        <p> FGES is an optimized and parallelized version of an algorithm
            developed by Meek [Meek, 1997] called the Greedy Equivalence Search
            (GES). The algorithm was further developed and studied by Chickering
            [Chickering, 2002]. GES is a Bayesian algorithm that heuristically
            searches the space of CBNs and returns the model with the highest
            Bayesian score it finds. In particular, GES starts its search with
            the empty graph. It then performs a forward stepping search in which
            edges are added between nodes in order to increase the Bayesian
            score. This process continues until no single edge addition increases
            the score. Finally, it performs a backward stepping search that
            removes edges until no single edge removal can increase the score.
            More information is available <a
                    href="https://www.ccd.pitt.edu//wp-content/uploads/2018/10/FGES1c-
        user-documentation-5_21_2016-sample-size.pdf">here</a> and <a
                    href="https://www.ccd.pitt.edu//wp-content/uploads/2018/10/FGES1d-
        user-documentation-7_20_2016-sample-size.pdf">here</a>. The reference
            is Ramsey et al., 2017. </p>

        <p> The algorithm requires a decomposable score—that is, a score
            that for the entire DAG model is a sum of logged scores of each
            variables given its parents in the model. The algorithms can take all
            continuous data (using the SEM BIC score), all discrete data (using
            the BDeu score) or a mixture of continuous and discrete data (using
            the Conditional Gaussian score); these are all decomposable scores.
            Note that in all case, BIC is calculated as 2L - k ln N, so "higher
            is better."
        </p>

        <p>Note: If one wants to analyze time series data using this algorithm,
            one may set the time lag parameter to a value greater than 0, which
            will automatically apply the time lag transform. The same goes for any
            algorithm that has this parameter available in the interface.</p>

        <p> Note: It is possible to run FGES followed some non-Gaussian
            orientation algorithm like FASK-pairwise or R3 or RSkew. To do this,
            see the FASK algorithm. There one can select an algorithm to
            estimate adjacencies and a pairwise algorithm to estimate orientations.
            This is for the linear, non-Gaussian case, where such pairwise
            algorithms are effective.
        </p>

    </div>

    <h4>Input Assumptions</h4>

    <p>Data that’s all continuous, all discrete, or a mixture of
        continuous and discrete variables. Continuous variables will be assumed
        to be linearly associated; discrete variable will be assumed to be
        associated by multinomial conditional probability tables. Continuous
        variables for the mixed case will be assumed to be jointly Gaussian.</p>

    <h4>Output Format</h4>

    <p>A CPDAG, same as PC.</p>

    <h3>The IMaGES Algorithm</h3>

    <h4>Description</h4>

    <div id="images">

        <p>
            Adjusts the selected score for FGES to
            allow for multiple datasets as input. The linear, Gaussian BIC scores
            for each data set are averaged at each step of the algorithm,
            producing a model for all data sets that assumes they have the same
            graphical structure across dataset. Note that BIC is calculated
            as 2L - k ln N, so "higher is better."</p>

    </div>

    <h4>Input Assumptions</h4>

    <p>A set of datasets consistent with the chosen score with the same variables and sample
        sizes.</p>

    <h4>Output Format</h4>

    <p>A CPDAG, interpreted as a common model for all datasets.</p>

    <h4>Parameters</h4>

    <p>All the parameters from FGES are available for IMaGES.
        Additionally:</p>

    <p><a href="#numRuns">numRuns</a>, <a
            href="#randomSelectionSize">randomSelectionSize</a></p>

    <h3>The IMaGES-BOSS Algorithm</h3>

    <h4>Description</h4>

    <div id="images-boss">
        <p>Wraps the IMaGES algorithm for continuous variables. This version uses the BOSS algorithm in place of
            FGES.</p>
        <p>Requires that the parameter 'randomSelectionSize' be set to indicate how many datasets should be taken at a
            time (randomly). This cannot be given multiple values.</p>

    </div>

    <h4>Input Assumptions</h4>

    <p>A set of datasets consistent with the chosen score with the same variables and sample
        sizes.</p>

    <h4>Output Format</h4>

    <p>A CPDAG, interpreted as a common model for all datasets.</p>

    <h4>Parameters</h4>

    <p>All the parameters from FGES are available for IMaGES.
        Additionally:</p>

    <p><a href="#numRuns">numRuns</a>, <a
            href="#randomSelectionSize">randomSelectionSize</a></p>


    <h3>The FCI Algorithm</h3>

    <h4>Description</h4>

    <div id="fci">

        <p>The FCI algorithm is a constraint-based algorithm that takes
            as input sample data and optional background knowledge and in the
            large sample limit outputs an equivalence class of CBNs that
            (including those with hidden confounders) that entail the set of
            conditional independence relations judged to hold in the population.
            It is limited to several thousand variables, and on realistic sample
            sizes it is inaccurate in both adjacencies and orientations. FCI has
            two phases: an adjacency phase and an orientation phase. The
            adjacency phase of the algorithm starts with a complete undirected
            graph and then performs a sequence of conditional independence tests
            that lead to the removal of an edge between any two adjacent
            variables that are judged to be independent, conditional on some
            subset of the observed variables; any conditioning set that leads to
            the removal of an adjacency is stored. After the adjacency phase, the
            resulting undirected graph has the correct set of adjacencies, but
            all the edges are unoriented. FCI then enters an orientation phase
            that uses the stored conditioning sets that led to the removal of
            adjacencies to orient as many of the edges as possible. See [Spirtes,
            1993].</p>

        <p>Note: If one wants to analyze time series data using this algorithm,
            one may set the time lag parameter to a value greater than 0, which
            will automatically apply the time lag transform. The same goes for any
            algorithm that has this parameter available in the interface.</p>

    </div>

    <h4>Input Assumptions</h4>

    <p>The data are continuous, discrete, or mixed.</p>

    <h4>Output Format</h4>

    <p>A partial ancestral graph (see Spirtes et al., 2000).</p>

    <h4>Parameters</h4>

    <p>All the parameters from FCI are below.</p>

    <p><a href="#depth">depth</a>, <a
            href="#maxPathLength">maxPathLength</a>, <a
            href="#completeRuleSetUsed">completeRuleSetUsed</a></p>

    <h3>The FCI-Max Algorithm</h3>

    <h4>Description</h4>

    <div id="fci-max">

        <p>The FCI-Max algorithm simply changes the first collider
            orientation rule in FCI to use the PC-Max orientation.</p>

        <p>Note: If one wants to analyze time series data using this algorithm,
            one may set the time lag parameter to a value greater than 0, which
            will automatically apply the time lag transform. The same goes for any
            algorithm that has this parameter available in the interface.</p>


    </div>

    <h4>Input Assumptions</h4>

    <p>The data are continuous, discrete, or mixed.</p>

    <h4>Output Format</h4>

    <p>A partial ancestral graph (see Spirtes et al., 2000).</p>

    <h4>Parameters</h4>

    <p>All the parameters from FCI are below.</p>

    <p><a href="#depth">depth</a>, <a
            href="#maxPathLength">maxPathLength</a>, <a
            href="#completeRuleSetUsed">completeRuleSetUsed</a></p>

    <h3>The CFCI Algorithm</h3>

    <h4>Description</h4>

    <div id="cfci">

        <p>Adjusts FCI (see) to use conservative orientation as in CPC (see). Because the collider orientation is
            conservative,
            there may be ambiguous triples; these may be retrieved using that accessor method.</p>
        <p>This class is configured to respect knowledge of forbidden and required edges, including knowledge of
            temporal
            tiers.</p>

    </div>

    <h4>Input Assumptions</h4>

    <p>Data for which a conditional independence test is available.</p>

    <h4>Output Format</h4>

    <p>An adjustment to a partial ancestral graph (PAG), where ambiguous colliders are marked with underlings. See
        Spirtes et al., 2000. Also, see the CPC algorithm.</p>

    <h4>Parameters</h4>

    <p>All the parameters from FCI are available for RFCI.
        Additionally:</p>

    <p><a href="#depth">depth</a>, <a
            href="#maxPathLength">maxPathLength</a>, <a
            href="#completeRuleSetUsed">completeRuleSetUsed</a></p>

    <h3>The RFCI Algorithm</h3>

    <h4>Description</h4>

    <div id="rfci">

        <p>A modification of the FCI algorithm in which some expensive
            steps are finessed and the output is somewhat differently
            interpreted. In most cases this runs faster than FCI (which can be
            slow in some steps) and is almost as informative. See Colombo et al.,
            2012.</p>

        <p>Note: If one wants to analyze time series data using this algorithm,
            one may set the time lag parameter to a value greater than 0, which
            will automatically apply the time lag transform. The same goes for any
            algorithm that has this parameter available in the interface.</p>


    </div>

    <h4>Input Assumptions</h4>

    <p>Data for which a conditional independence test is available.</p>

    <h4>Output Format</h4>

    <p>A partial ancestral graph (PAG). See Spirtes et al., 2000.</p>

    <h4>Parameters</h4>

    <p>All the parameters from FCI are available for RFCI.
        Additionally:</p>

    <p><a href="#depth">depth</a>, <a
            href="#maxPathLength">maxPathLength</a>, <a
            href="#completeRuleSetUsed">completeRuleSetUsed</a></p>

    <h3>The PAG-Sampling RFCI Algorithm</h3>

    <h4>Description</h4>

    <div id="pag-sampling-rfci">

        <p>A modification of the RFCI algorithm which does probabilistic bootstrap
            sampling with respect to the RFCI PAG output.For discrete data only.
            Parameters are: (a) Number of search probabilistic models, (b) boostrap
            ensemble method to use (see bootstrapping), (c) maximum size of
            conditioning set (depth), (d) maximum length of any discriminating path
            (a property for RFCI). This must use the probabilistic test, which must
            be selected. Parameters for the probabilistic test are (d) independence
            cutoff threshold, default 0.5, (e) prior equivalent sample size, and
            (f) whether the cutoff in (d) is used in the independence test calculation;
            if not, then a coin flip is used (probability 0.5).
        </p>

    </div>

    <h4>Input Assumptions</h4>

    <p>A discrete dataset.</p>

    <h4>Output Format</h4>

    <p>A partial ancestral graph (PAG). See Spirtes et al., 2000.</p>

    <h3>The GFCI Algorithm</h3>

    <h4>Description</h4>

    <div id="gfci">

        <p>GFCI is a combination of the FGES [FGES, 2016] algorithm
            and the FCI algorithm [Spirtes, 1993] that improves upon the accuracy
            and efficiency of FCI. In order to understand the basic methodology
            of GFCI, it is necessary to understand some basic facts about the
            FGES and FCI algorithms. The FGES algorithm is used to improve the
            accuracy of both the adjacency phase and the orientation phase of FCI
            by providing a more accurate initial graph that contains a subset of
            both the non-adjacencies and orientations of the final output of FCI.
            The initial set of nonadjacencies given by FGES is augmented by FCI
            performing a set of conditional independence tests that lead to the
            removal of some further adjacencies whenever a conditioning set is
            found that makes two adjacent variables independent. After the
            adjacency phase of FCI, some of the orientations of FGES are then
            used to provide an initial orientation of the undirected graph that
            is then augmented by the orientation phase of FCI to provide
            additional orientations. A verbose description of GFCI can be found
            <a href="https://www.ccd.pitt.edu//pdfs/GFCId.pdf"> here (discrete
                variables)</a> and <a
                    href="https://www.ccd.pitt.edu//wp-content/uploads/2018/10/GFCIc-
        overview-11_22_2016.pdf">here (continuous variables)</a>.</p>

        <p>Note: If one wants to analyze time series data using this algorithm,
            one may set the time lag parameter to a value greater than 0, which
            will automatically apply the time lag transform. The same goes for any
            algorithm that has this parameter available in the interface.</p>


    </div>

    <h4>Input Assumptions</h4>

    <p>Same as for FCI.</p>

    <h4>Output Format</h4>

    <p>Same as for FCI.</p>

    <h4>Parameters</h4>

    <p>Uses all of the parameters of FCI (see Spirtes et al., 1993) and
        FGES (see FGES, 2016).</p>


    <h3>The GRaSP-FCI Algorithm</h3>

    <h4>Description</h4>

    <div id="grasp-fci">

        <p>GRaSP-FCI is wrapper around the GRaSP algorithm that replaces
            the FGES step in GFCI with the more accurate GRaSP algorithm, which
            reasons by considering permutations of variables. The second collider
            orientation step in GFCI is also done using permutation reasoning,
            leaving the discriminating path rule as the only rule that requires a
            "raw" conditional independence judgment. Ultimately this independence
            judgment can be decided using the same scoring apparatus as the other
            permutation steps, so ultimately GRaSP-FCI can be treated as a scoring
            algorithm.</p>

        <p>Note: If one wants to analyze time series data using this algorithm,
            one may set the time lag parameter to a value greater than 0, which
            will automatically apply the time lag transform. The same goes for any
            algorithm that has this parameter available in the interface.</p>
    </div>


    <h4>Input Assumptions</h4>

    <p>Same as for FCI.</p>

    <h4>Output Format</h4>

    <p>Same as for FCI.</p>

    <h4>Parameters</h4>

    <p>Uses all of the parameters of FCI (see Spirtes et al., 1993) and
        GRaSP.</p>


    <h3>The BFCI Algorithm</h3>

    <h4>Description</h4>

    <div id="bfci">
        <p>Uses BOSS in place of FGES for the initial step in the GFCI algorithm. This tends to produce a accurate PAG
            than GFCI
            as a result, for the latent variables case. This is a simple substitution; the reference for GFCI is
            here:</p>
        <p>J.M. Ogarrio and P. Spirtes and J. Ramsey, "A Hybrid Causal Search Algorithm for Latent Variable Models,"
            JMLR 2016.
            Here, BOSS has been substituted for FGES.</p>
        <p>For BOSS only a score is needed, but there are steps in GFCI that require a test, so for this method, both a
            test and
            a score need to be given.</p>
        <p>This class is configured to respect knowledge of forbidden and required edges, including knowledge of
            temporal
            tiers.</p>

        <p>Note: If one wants to analyze time series data using this algorithm,
            one may set the time lag parameter to a value greater than 0, which
            will automatically apply the time lag transform. The same goes for any
            algorithm that has this parameter available in the interface.</p>
    </div>


    <h4>Input Assumptions</h4>

    <p>Same as for FCI.</p>

    <h4>Output Format</h4>

    <p>Same as for FCI.</p>

    <h4>Parameters</h4>

    <p>Uses all of the parameters of FCI (see Spirtes et al., 1993) and
        GRaSP.</p>

    <h3>The SP-FCI Algorithm</h3>

    <h4>Description</h4>

    <div id="spfci">

        <p>SP-FCI is wrapper around the SP algorithm that replaces
            the FGES step in GFCI with the more accurate SP algorithm, which
            reasons by considering permutations of variables. This uses the
            same method for wrapping SP with an FCI method similar to GFCI
            as GRaSP-FCI. The difference is that SP considers every permutation
            of the variables and so necessarily return a frugal DAG. This
            can only be used for very small models, of up to about 8 or 9
            variables, because of the super-exponential step of considering
            every permutation of the variables. The second collider
            orientation step in GFCI is done using permutation reasoning,
            leaving the discriminating path rule as the only rule that requires a
            "raw" conditional independence judgment. Ultimately this independence
            judgment can be decided using the same scoring apparatus as the other
            permutation steps, so ultimately GRaSP-FCI can be treated as a scoring
            algorithm.</p>
    </div>

    <h4>Input Assumptions</h4>

    <p>Same as for FCI.</p>

    <h4>Output Format</h4>

    <p>Same as for FCI.</p>

    <h4>Parameters</h4>

    <p>Uses all of the parameters of FCI (see Spirtes et al., 1993) and
        SP.</p>


    <h3>The FCI-IOD Algorithm</h3>

    <h4>Description</h4>

    <div id="fci-iod">
        <p>Runs FCI on multiple datasets using the IOD pooled dataset independence test. The reference is here:</p>
        <p>Tillman, R., &amp; Spirtes, P. (2011, June). Learning equivalence classes of acyclic models with latent and
            selection variables from multiple datasets with overlapping variables. In Proceedings of the Fourteenth
            International Conference on Artificial Intelligence and Statistics (pp. 3-15). JMLR Workshop and Conference
            Proceedings.</p>

    </div>

    <h3>The SvarFCI Algorithm</h3>

    <h4>Description</h4>

    <div id="svar-fci">

        <p>The SvarFCI algorithm is a version of FCI for time series
            data. See the FCI documentation for a description of the FCI
            algorithm, which allows for unmeasured (hidden, latent) variables in
            the data-generating process and produces a PAG (partial ancestral
            graph). svarFCI takes as input a “time lag data set,” i.e., a data
            set which includes time series observations of variables X1, X2, X3,
            ..., and their lags X1:1, X2:1, X3:1, ..., X1:2, X2:2,X3:2, ... and
            so on. X1:n is the nth-lag of the variable X1. To create a time lag
            data set from a standard tabular data set (i.e., a matrix of
            observations of X1, X2, X3, ...), use the “create time lag data”
            function in the data manipulation toolbox. The user will be prompted
            to specify the number of lags (n), and a new data set will be created
            with the above naming convention. The new sample size will be the old
            sample size minus n.</p>

        <p>Since this algorithm specifically requires time series data,
            one must set the time lag parameter to a value greater than 0, which
            will automatically apply the time lag transform.</p>


    </div>

    <h4>Input Assumptions</h4>

    <p>The (continuous) data has been generated by a time series, and the
        "Convert to Time Lag" converter in the Data box has been used to format
        the data as a time lag dataset. (Manual formatting of the data will not
        work for this.</p>

    <h4>Output Format</h4>

    <p>A PAG over the input variables with stated number of lags.</p>

    <h4>Parameters</h4>

    <p><a href="#alpha">alpha</a></p>


    <h3>The SvarGFCI Algorithm</h3>

    <h4>Description</h4>

    <div id="svar-gfci">

        <p>SvarGFCI uses a BIC score to search for a skeleton. Thus, the
            only user-specified parameter is an optional “penalty score” to bias
            the search in favor of more sparse models. See the description of the
            GES algorithm for discussion of the penalty score. For the
            traditional definition of the BIC score, set the penalty to 1.0. The
            orientation rules are the same as for FCI. As is the case with
            SvarFCI, SvarFCI will automatically respect the time order of the
            variables and impose a repeating structure. Firstly, it puts lagged
            variables in appropriate tiers so, e.g., X3:2 can cause X3:1 and X3
            but X3:1 cannot cause X3:2 and X3 cannot cause either X3:1 or X3:2.
            Also, it will assume that the causal structure is the same across
            time, so that if the edge between X1 and X2 is removed because this
            increases the BIC score, then also the edge between X1:1 and X2:1 is
            removed, and so on for additional lags if they exist. When some edge
            is removed as the result of a score increase, all similar (or
            “homologous”) edges are also removed. Note that BIC is calculated
            as 2L - k ln N, so "higher is better."</p>

        <p>Since this algorithm specifically requires time series data,
            one must set the time lag parameter to a value greater than 0, which
            will automatically apply the time lag transform.</p>


    </div>

    <h4>Input Assumptions</h4>

    <p>The (continuous) data has been generated by a time series, and the
        "Convert to Time Lag" converter in the Data box has been used to format
        the data as a time lag dataset. (Manual formatting of the data will not
        work for this.</p>

    <h4>Output Format</h4>

    <p>A PAG over the input variables with stated number of lags.</p>

    <h4>Parameters</h4>

    <p>Uses all of the parameters of FCI (see Spirtes et al., 1993) and
        FGES (see FGES, 2016).</p>

    <h4>Input Assumptions</h4>

    <p>The (continuous) data has been generated by a time series.</p>

    <h4>Output Format</h4>

    <p>A PAG over the input variables with stated number of lags.</p>

    <h4>Parameters</h4>

    <p>Uses the parameters of IMaGES.</p>


    <h3>The CCD (Cyclic Causal Discovery) Algorithm</h3>

    <h4>Description</h4>

    <div id="ccd">

        <p>CCD assumes that the data are causally sufficient (no latent variables)
            though possibly with directed cycles. No background knowledge is permitted.
            It generates a "cyclic PAG". See Richardson, T. S. (2013). A discovery
            algorithm for directed cyclic graphs. arXiv preprint arXiv:1302.3599,
            for details. Note that the output graph contains circle endpoints
            as with a latent variable PAG, but these are interpreted differently.
            CCD reasons about cyclic (feedback) models using conditional
            independence facts alone, as with PC or FCI, so is general in this
            sense.</p></div>

    <h4>Input Assumptions</h4>

    <p>Data from a possibly cyclic (feedback) model without latent variables for
        which an independence test is available.</p>

    <h4>Output Format</h4>

    <p>Same as for FCI.</p>

    <p>A cyclic PAG--see reference above.</p>

    <h4>Parameters</h4>

    <p>Cutoff for alpha, maximum size of conditioning set,
        Yes if orient away from arrow rule should be applied,
        Yes if verbose output should be printed.</p>


    <h3>The FGES-MB Algorithm</h3>

    <h4>Description</h4>

    <div id="fges-mb">

        <p>This is a restriction of the FGES algorithm to union of edges
            over the combined Markov blankets of a set of targets, including the
            targets. In the interface, just one target may be specified. See
            Ramsey et al., 2017 for details. In the general case, finding the
            graph over the Markov blanket variables of a target (including the
            target) is far faster than finding the CPDAG for all the
            variables.</p>

    </div>

    <h4>Input Assumptions</h4>

    <p>The same as FGES</p>

    <h4>Output Format</h4>

    <p>A graph over a selected group of nodes that includes the target
        and each node in the Markov blanket of the target. This will be the same
        as if FGES were run and the result restricted to just these variables, so
        some edges may be oriented in the returned graph that may not have been
        oriented in a CPDAG over the selected nodes.</p>

    <h4>Parameters</h4>

    <p>Uses the parameters of FGES (see FGES, 2016). </p>

    <p><a href="#targetName">targetName</a></p>

    <h3>The PC-MB Algorithm</h3>

    <h4>Description</h4>

    <div id="pc-mb">

        <p>PC-MB. Similar to FGES-MB (see FGES,
            2016) but using PC as the basic search instead of FGES. The rules of
            the PC search are restricted to just the variables in the Markov
            blanket of a target T, including T; the result is a graph that is a
            CPDAG over these variables.</p>

    </div>

    <h4>Input Assumptions</h4>

    <p>Same as for PC</p>

    <h4>Output Format</h4>

    <p>A CPDAG over a selected group of nodes that includes the target
        and each node in the Markov blanket of the target.</p>

    <h4>Parameters</h4>

    <p>Uses the parameters of PC.</p>

    <p><a href="#targetName">targetName</a></p>


    <h3>The FAS Algorithm</h3>

    <h4>Description</h4>

    <div id="fas">

        <p>This is just the adjacency search of the PC algorithm,
            included here for times when just the adjacency search is needed, as
            when one is subsequently just going to orient variables pairwise.</p>

    </div>

    <h4>Input Assumptions</h4>

    <p>Same as for PC</p>

    <h4>Output Format</h4>

    <p>An undirected graph over the variables of the input dataset. In
        particular, parents of a variables are not married by FAS, so the
        resulting graph is not a Markov random field. For example, if X->Y<-Z,
        the output will be X—Y—Z with X—Z. The parents of Y will be joined by an
        undirected edge, morally, only if they are joined by a trek in the true
        graph.</p>

    <h4>Parameters</h4>

    <p><a href="#alpha">alpha</a>, <a href="#depth">depth</a></p>

    <h3>The MGM Algorithm</h3>

    <h4>Description</h4>

    <div id="mgm">

        <p>Need reference. Finds a Markov random field (with parents
            married) for a dataset in which continuous and discrete variables are
            mixed together. For example, if X->Y<-Z, the output will be X—Y—Z
            with X—Z. The parents of Y will be joined by an undirected edge,
            morally, even though this edge does not occur in the true model.</p>

    </div>

    <h4>Input Assumptions</h4>

    <p>Data are mixed.</p>

    <h4>Output Format</h4>

    <p>A Markov random field for the data.</p>

    <h4>Parameters</h4>

    <p><a href="#mgmParam1">mgmParam1</a>, <a
            href="#mgmParam2">mgmParam2</a>, <a href="#mgmParam3">mgmParam3</a></p>

    <h3>The SP Algorithm</h3>

    <h4>Description</h4>

    <div id="sp">

        <p> SP (Sparsest Permutation, Raskutti, G., & Uhler, C. (2018). Learning
            directed acyclic graph models based on sparsest permutations.
            Stat, 7(1), e183) searches for model satisfying the SMR (frugality)
            assumption for small models of up to about 9 variables.

        <p> The algorithms works searching over all possible permutations
            of the variables and building DAGs for them in the same way as the
            GRaSP algorithm. Two ways of building DAGs are considered, one
            independence-based, due to Raskutti and Uhler and a score-based
            method, using the Grow-Shrink (GS) method (Margaritis and Thrun, 1999).
            If the Pearl method is selected, an independence test will be used;
            if the GS method is selected, a score will be used, so both a test
            and a score need to be supplied so that this choice can be made.

    </div>

    <h4>Input Assumptions</h4>

    <p>Causal sufficiency</p>

    <h4>Output Format</h4>

    <p>The CPDAG equivalence class of DAGs representing estimated
        possible causal structures over the set of variables.</p>

    <h4>Parameters</h4>

    <p><a href="#graspDepth">graspDepth</a>, <a
            href="#graspNonSingularDepth">graspNonSingularDepth</a> <a
            href="#graspSingularDepth">graspSingularDepth</a> <a
            href="#graspOrderedAlg">graspOrderedAlg</a> <a
            href="#verbose">verbose</a> <a href="#numStarts">numStarts</a>

    </p>

    <h3>The GRaSP Algorithm</h3>

    <h4>Description</h4>

    <div id="grasp">

        <p> GRaSP (Greedy Relations of Sparsest Permutation) is an
            algorithm that generalizes and extends the GSP (Greedy Sparsest
            Permutation) algorithm. Is generalizes specifically the algorithms
            TSP (or which GSP is a bounded and iterated version) and ESP (Solus
            et al., 2017) by allowing those algorithms to equivalently be run by
            selecting particular parameterizations of GRaSP, where ESP enlarges
            the search space of GSP. The implementation given for ESP renders
            that algorithm tractable. By choosing other parameterizations of
            GRaSP, it is possible to further enlarge the search space even over
            and above that of ESP to render the algorithm significantly more
            accurate. In all cases, these algorithms come back quickly enough to
            analyze accurately sparse problems of up to 300 variables and denser
            problems with up to about 100 variables.
        <p> The parameters are as
            follows:
        <p> graspDepth - This controls the overall recursion depth
            for a depth first search.
        <p> graspNonsingularDepth - This controls the
            depth at which nonsingular tucks are explored.
        <p> graspSingularDepth
            - This controls the depth at which singular tucks are considered.
        <p>
            numRestarts - By default 1; if > 1, additional random restarts are
            done, and the best of these results is returned.
        <p> TSP corresponds
            to singular depth 0, nonsingular depth 0. ESP corresponds to singular
            depth > 0, nonsingular depth = 0. GRaSP corresponds to singular depth >
            0, nonsingular depth > 0. In each case, an ordering option is available
            to find the best permutations from lower levels before proceeding to
            higher levels.
        <p> The algorithm works by building DAGs given
            permutations in ways similar to those described in Raskutti and Uhler
            (ref?) and Solus et al. Two ways of building DAGs are considered, one
            independence-based, due to Raskutti and Uhler and a score-based
            method, using the Grow-Shrink (GS) method (Margaritis and Thrun, 1999).
            If the Pearl method is selected, an independence test will be used;
            if the GS method is selected, a score will be used, so both a test
            and a score need to be supplied so that this choice can be made.
        <p> We recommend
            that the user turn on logging to watch the progress of the algorithm;
            this helps with larger searches especially.
        <p> Knowledge of
            forbidden edges may be used with GRaSP; currently knowledge of
            required edges is not implemented.
        <p> Dimitris Margaritis and
            Sebastian Thrun. Bayesian network induction via local neighborhoods.
            Advances in neural information processing systems, 12, 1999.
        <p>
            Raskutti, G., & Uhler, C. (2018). Learning directed acyclic graph
            models based on sparsest permutations. Stat, 7(1),
        <p> Solus,
            L., Wang, Y., Matejovicova, L., & Uhler, C. (2017). Consistency
            guarantees for permutation-based causal inference algorithms. arXiv
            preprint arXiv:1702.03530. </p>
        <p> Lam, W. Y., Andrews, B., & Ramsey, J. (2022, August). Greedy relaxations
            of the sparsest permutation algorithm. In Uncertainty in Artificial
            Intelligence (pp. 1052-1062). PMLR.</p>

    </div>

    <h4>Input Assumptions</h4>

    <p>Causal sufficiency</p>

    <h4>Output Format</h4>

    <p>The CPDAG equivalence class of DAGs representing estimated
        possible causal structures over the set of variables.</p>

    <h4>Parameters</h4>

    <p><a href="#graspDepth">graspDepth</a>, <a
            href="#graspNonSingularDepth">graspNonSingularDepth</a> <a
            href="#graspSingularDepth">graspSingularDepth</a> <a
            href="#graspOrderedAlg">graspOrderedAlg</a> <a
            href="#verbose">verbose</a> <a href="#numStarts">numStarts</a>

    </p>

    <h3>The BOSS Algorithm</h3>

    <h4>Description</h4>

    <div id="boss">

        <p> BOSS (Best Order Score Search) is an algorithm that, like GRaSP,
            generalizes and extends the GSP (Greedy Sparsest Permutation) algorithm.
            It has been tested to 1000 variables with an average degree of 20
            and gives near perfect precisions and recalls for N = 10,000 (with
            recall that drop to 0.9 for N = 1000). The algorithm works by building DAGs given
            permutations in ways similar to those described in Raskutti and Uhler
            (ref?) and Solus et al.
        <p> The parameters are as
            follows:
        <p> useBes - True if the final BES (Backward Equivalence Search)
            step is used from the GES (Greedy Equivalence Search) algorithm.
            This step is needed for correctness but for large models, since usually
            nearly all edges are oriented in the CPDAG, it is heuristically not needed.</p>
        <p> numStarts - The number of times the algorithm should be re-run from different
            random starting permutations. The model with the most optimal BIC score will
            be selected.</p>
        <p> allowInternalRandomness - If true, the algorithm allow the algorithm to
            use certain heuristic random steps. This can improve performance, but
            may make the algorithm non-deterministic.</p>
        <p> timeLag - This creates a time-series model automatically with a certain
            number of lags.
        <p> Knowledge of forbidden edges and required edges may be used with this
            algorithm. Also, knowledge of tiers may be used. If tiered knowledge is
            supplied, the algorithm will analyze the tiers in order, so that the
            time required for the algorithm is linear in the number of tiers.
        <p> Dimitris Margaritis and
            Sebastian Thrun. Bayesian network induction via local neighborhoods.
            Advances in neural information processing systems, 12, 1999.
        <p>
            Raskutti, G., & Uhler, C. (2018). Learning directed acyclic graph
            models based on sparsest permutations. Stat, 7(1), e183.
        <p> Solus,
            L., Wang, Y., Matejovicova, L., & Uhler, C. (2017). Consistency
            guarantees for permutation-based causal inference algorithms. arXiv
            preprint arXiv:1702.03530. </p>
        <p> Lam, W. Y., Andrews, B., & Ramsey, J. (2022, August). Greedy relaxations
            of the sparsest permutation algorithm. In Uncertainty in Artificial
            Intelligence (pp. 1052-1062). PMLR.</p>

    </div>

    <h4>Input Assumptions</h4>

    <p>Causal sufficiency</p>

    <h4>Output Format</h4>

    <p>The CPDAG equivalence class of DAGs representing estimated
        possible causal structures over the set of variables.</p>

    <h4>Parameters</h4>

    <p><a href="#graspDepth">graspDepth</a>, <a
            href="#graspNonSingularDepth">graspNonSingularDepth</a> <a
            href="#graspSingularDepth">graspSingularDepth</a> <a
            href="#graspOrderedAlg">graspOrderedAlg</a> <a
            href="#verbose">verbose</a> <a href="#numStarts">numStarts</a>

    </p>

    <h3>The BPC/Mimbuild Algorithm</h3>

    <h4>Description</h4>

    <div id="bpc">

        <p>Searches for causal structure over latent variables, where the
            true models are Multiple Indicator Models (MIM’s) as described in the
            Graphs section. The idea is this. There is a set of latent
            (unmeasured) variables over which a directed acyclic model has been
            defined. Then for each of these latent L there are 3 (preferably 4)
            or more measures of that variable—that is, measured variables that
            are all children of L. Under these conditions, one may define tetrad
            constraints (see Spirtes et al., 2000). There is a theorem to the
            effect that if certain CPDAGs of these tetrad constraints hold, there
            must be a latent common cause of all of them (the Tetrad
            Representation Theorem, see Silva et al., 2003, where the BPC (“Build
            Pure Clusters”) algorithm is defined and discussed.) Moreover, once
            one has such a “measurement model,” once can estimate a covariance
            matrix over the latent variables that are parents of the measures and
            use some algorithm such as PC or GES to estimate a CPDAG over the
            latents. The algorithm to run PC or GES on this covariance matrix is
            called MimBuild (“MIM” is the graph, Multiple Indicator Model;
            “Build” means build). In this way, one may recover causal structure
            over the latents. The more measures one has for each latent, the
            better the result is, generally. The larger the sample size the
            better. One important issue is that the algorithm is sensitive to
            so-called “impurities”—that is, causal edges among the measured
            variables, or between measured variables and unintended latent. The
            algorithm will in effect remove one measure in each impure pair from
            consideration.

            The algorithm to run PC or GES on this covariance matrix is
            called MimBuild (“MIM” is the graph, Multiple Indicator Model;
            “Build” means build). MimBUILD is an optional choice inside FOFC
            In this way, one may recover causal structure over the latents.
            The more measures one has for each latent the better the result
            is, generally.

            A reference for the Wishart and Delta Tetrad tests is: Bollen,
            K. A., & Ting, K. F. (1993). Confirmatory tetrad analysis.
            Sociological methodology, 147-175. The original reference for
            the Delta Tetrad test is Bollen, K. A. (1990). Outlier screening
            and a distribution-free test for vanishing tetrads. Sociological
            Methods & Research, 19(1), 80-92.

        </p>

    </div>

    <h4>Input Assumptions</h4>

    <p>Continuous data, a collection of measurements in the above sense,
        excluding the latent variables (which are to be learned).</p>

    <h4>Output Format</h4>

    <p>For BPC, a measurement model, in the above sense. This is
        represented as a clustering of variables; it may be inferred that there
        is a single latent for each output cluster. For MimBuild, a CPDAG over
        the latent variables, one for each cluster.</p>

    <h4>Parameters</h4>

    <p><a href="#maxit">alpha</a>, <a
            href="#useWishart">useWishart</a></p>


    <h3>The FOFC/MIMBUILD Algorithm</h3>

    <h4>Description</h4>

    <div id="fofc">

        <p>Searches for causal structure over latent variables, where the
            true models are Multiple Indicator Models (MIM’s) as described in the
            Graphs section. The idea is this. There is a set of latent
            (unmeasured) variables over which a directed acyclic model has been
            defined, Then for each of these latent L there are 3 (preferably 4)
            or more measures of that variable—that is, measured variables that
            are all children of L. Under these conditions, one may define tetrad
            constraints (see Spirtes et al., 2000). There is a theorem to the
            effect that if certain CPDAGs of these tetrad constraints hold, there
            must be a latent common cause of all of them (the Tetrad
            Representation Theorem). The FOFC (Find One Factor Clusters) takes
            advantage of this fact. The basic idea is to build up clusters one at
            a time by adding variables that keep them pure in the sense that all
            relevant tetrad constraints still hold. There are different ways of
            going about this. One could try to build one cluster up as far as
            possible, then remove all of those variables from the set, and try to
            make another cluster using the remaining variables (SAG, Seed and
            Grow). Or one can try in parallel to grow all possible clusters and
            then choose among the grown clusters using some criterion such as
            cluster size (GAP, Grow and Pick). In general, GAP is more accurate.
            The result is a clustering of variables. Once one has such a
            “measurement model, one can estimate (using the ESTIMATOR box) a
            covariance matrix over the latent variables that are parents of the
            measures and use some algorithm such as PC or GES to estimate a CPDAG
            over the latent variables. The algorithm to run PC or GES on this
            covariance matrix is called MimBuild (“MIM” is the graph, Multiple
            Indicator Model; “Build” means build). MimBUILD is an optional choice
            inside FOFC In this way, one may recover causal structure over the
            latents. The more measures one has for each latent the better the
            result is, generally. At least 3 measured indicator variables are
            needed for each latent variable. The larger the sample size the
            better. One important issue is that the algorithm is sensitive to
            so-called “impurities”—that is,causal edges among the measured
            variables, or between measured variables and multiple latent
            variables. The algorithm will in effect remove one measure in each
            impure pair from consideration.

            Note that for FOFC, a test is done for each final cluster to see
            whether the variables in the cluster are all mutually
            dependent. In the interface, in order to see teh results of this
            test, one needs to open the logging window. See the Logging menu.
        </p>

    </div>

    <h3>The FTFC Algorithm</h3>

    <h4>Description</h4>

    <div id="ftfc">

        <p>FTFC (Find Two Factor Clusters) is similar to FOFC, but
            instead of each cluster having one latent that is the parent of all
            the measure in the cluster, it instead has two such latents. So
            each measure has two latent parents; these are two “factors.”
            Similarly to FOFC, constraints are checked for, but in this case, the
            constraints must be sextad constraints, and more of them must be
            satisfied for each pure cluster (see Kummerfeld et al., 2014). Thus,
            the number of measures in each cluster, once impure edges have been
            taken into account, must be at least six, preferably more.</p>

    </div>

    <h4>Input Assumptions</h4>

    <p>Continuous data over the measures with at least six variable
        variables in each cluster once variables involve in impure edges have
        been removed.</p>

    <h4>Output Format</h4>

    <p>A clustering of measures. It may be assumed that each cluster has
        at least two factors and that the clusters are pure.</p>

    <h4>Parameters</h4>

    <p><a href="#alpha">alpha</a>, <a href="#useWishart">useWishart</a>,
        <a href="#useGap">useGap</a></p>

    <h3>The ICA LiNGAM Algorithm</h3>

    <h4>Description</h4>

    <div id="ica-lingam"><p>ICA LiNGAM (Shimizu et al., 2006) was one of the
        first of the algorithms that assumed linearity among the variables and
        non-Gaussianity of error term, and still one of the best for smaller
        models, for the basic algorithm, implemented here. The idea is to use the
        Independent Components Analysis (ICA) algorithm to check all permutations
        of the variables to find one that is a causal order—that is, one in which
        earlier variables can cause later variables but not vice-versa. The
        method is clever. First, since we assume the model is a directed acyclic
        graph (DAG), there must be some permutation of the variables for which
        the main diagonal of the inverse of the weight matrix contains no zeros.
        This gives us a permuted estimate of the weight matrix. Then we look for
        a permutation of this weight matrix that is lower triangular. There must
        be one, since the model is assumed to be a DAG. But a lower triangular
        weight matrix just gives a causal order, so we’re done. </p>
        <p> In the
            referenced paper, we implement Algorithm A, which is described above.
            Once one has a causal order the only thing one needs to do is to
            eliminate the extra edges. For this, we use the causal order to define
            knowledge of tiers and run FGES. </p>

        <p> Our implementation of LiNGAM has one parameter, penalty
            discount, used for the FGES adjacency search. The method as
            implemented does not scale much beyond 10 variables, because it is
            checking every permutation of all the variables (twice). The
            implementation of ICA we use is FastIca (Hyvärinen et al., 2004).
        </p>

        <p> Shimizu, S., Hoyer, P. O., Hyvärinen, A., & Kerminen, A.
            (2006). A linear non-Gaussian acyclic model for causal discovery.
            Journal of Machine Learning Research, 7(Oct), 2003-2030. </p>

        <p> Hyvärinen, A., Karhunen, J., & Oja, E. (2004). Independent
            component analysis (Vol. 46). John Wiley & Sons. </p></div>

    <p>Direct LiNGAM is an implementation of said algorithms as specified in this reference: </p>

    <p> Shimizu, S., Inazumi, T., Sogawa, Y., Hyvarinen, A., Kawahara, Y., Washio, T., ... & Hoyer, P. (2011).
        DirectLiNGAM: A direct method for learning a linear non-Gaussian structural equation model. Journal of
        Machine Learning Research-JMLR, 12(Apr), 1225-1248. </p>

    <p> This requires no parameters. This algorithm is applicable to data generated by linear, non-Gaussian
        models.</p>

    <h3>The ICA LiNG-D Algorithm</h3>

    <h4>Description</h4>

    <div id="ica-ling-d">
        <p>Implements the ICA-LiNG-D algorithm as well as a number of ancillary methods for LiNG-D and LiNGAM. The
            reference is here:</p>
        <p>Lacerda, G., Spirtes, P. L., Ramsey, J., &amp; Hoyer, P. O. (2012). Discovering cyclic causal models by
            independent components analysis. arXiv preprint arXiv:1206.3273.</p>
        <p>ICA-LING-D is a method for estimating a possible cyclic linear models graph from a dataset. It is based on
            the assumption that the data are generated by a linear model with non-Gaussian noise. The method is based on
            the following assumptions:</p>
        <ol>
            <li>The data are generated by a linear model with non-Gaussian noise.</li>
            <li>The noise is independent across variables.</li>
            <li>The noises for all but possibly one variable are non-Gaussian.</li>
            <li>There is no unobserved confounding.</li>
        </ol>
        <p> lower bound of the absolute value of the coefficients in the W matrix.</p>
        <p> Under these assumptions, the method estimates a matrix W such that WX = e, where X is the data matrix, e is
            a matrix of noise, and W is a matrix of coefficients. The matrix W is then used to estimate a matrix B Hat,
            where B Hat is the matrix of coefficients in the linear model that generated the data. The graph is then
            estimated by finding edges in B Hat.</p>
        <p>We use the N Rooks algorithm to find alternative diagonals for permutations of the W matrix. The parameter
            that N Rooks requires is a threshold for entries in W to be included in possible diagonals, which is the
            lowest number in absolute value that a W matrix entry can take to be part of a diagonal; the implied
            permutations is the permutations that permutes rows so that these combination lies along the their
            respective diagonals in W, which are then scaled, and the separate satisfactory B Hat matrices reported.</p>
        <p> ICA-LiNG-D, which takes this W as an impute, is a method for estimating a directed graph (DG) from a
            dataset. The graph is estimated by finding a
            permutation of the columns of the dataset so that the resulting matrix has a strong diagonal. This
            permutation is then used to estimate a DG. The method is an relaxation of LiNGAM, which estimates a DAG from
            a dataset using independent components analysis (ICA). LiNG-D is particularly useful when the underlying
            data may have multiple consistent cyclic models.</p>
        <p> This class is not configured to respect knowledge of forbidden and required edges.</p>
    </div>

    <h3>The FASK Algorithm</h3>

    <h4>Description</h4>

    <div id="fask"><p>FASK learns a linear model in which all the
        variables are skewed. </p>

        <p>The idea is as follows. First, FAS-stable is run on the data,
            producing an undirected graph. We use the BIC score as a conditional
            independence test with a specified penalty discount c. This yields
            undirected graph G0 . The reason FAS-stable works for sparse cyclic
            models where the linear coefficients are all less than 1 is that
            correlations induced by long cyclic paths are statistically judged as
            zero, since they are products of multiple coefficients less than 1.
            Then, each of the X − Y adjacencies in G0 is oriented as a 2-cycle X
            += Y , or X → Y , or X ← Y . Taking up each adjacency in turn, one
            tests to see whether the adjacency is a 2-cycle by testing if the
            difference between corr(X, Y ) and corr(X, Y |X > 0), and corr(X, Y )
            and corr(X, Y |Y > 0), are both significantly not zero. If so, the
            edges X → Y and X ← Y are added to the output graph G1 . If not, the
            Left-Right orientation is rule is applied: Orient X → Y in G1, if
            (E(X Y |X > 0)/ E(X 2|X > 0)E(Y 2 |X > 0) − E(X Y |Y > 0)/ E(X 2 |Y >
            0)E(Y 2|Y > 0)) > 0; otherwise orient X ← Y . G1 will be a fully
            oriented graph. For some models, where the true coefficients of a
            2-cycle between X and Y are more or less equal in magnitude but
            opposite in sign, FAS-stable may fail to detect an edge between X and
            Y when in fact a 2-cycle exists. In this case, we check explicitly
            whether corr(X, Y |X > 0) and corr(X, Y |Y > 0) differ by more than a
            set amount of 0.3. If so, the adjacency is added to the graph and
            oriented using the aforementioned rules. </p>

        <p> We include pairwise orientation rule RSkew, Skew, and Tanh
            from Hyvärinen, A., & Smith, S. M. (2013). Pairwise likelihood ratios
            for estimation of non-Gaussian structural equation models. Journal of
            Machine Learning Research, 14(Jan), 111-152, so in some
            configurations FASK can be made to implement an algorithm that has
            been called in the literature "Pairwise LiNGAM"--this is intentional;
            we do this for ease of comparison. You'll get this configuration if
            you choose one of these pairwise orientation rules, together with the
            FAS with orientation alpha and two-cycle threshold set to zero and
            skewness threshold set to 1, for instance. </p>

        <p>See Sanchez-Romero R, Ramsey JD, Zhang K, Glymour MR, Huang B,
            Glymour C. Causal discovery of feedback networks with functional
            magnetic resonance imaging. <em>Network Neuroscience</em> 2018.</p>
    </div>

    <h4>Input Assumptions</h4>

    <p>Continuous, linear data in which all the variables are
        skewed.</p>

    <h4>Output Format</h4>

    <p>A fully directed, potentially cyclic, causal graph.</p>

    <h3>The DirectLiNGAM Algorithm</h3>

    <h4>Description</h4>

    <div id="direct-lingam">
        <p>Implements the Direct-LiNGAM algorithm. The reference is here:</p>
        <p>S. Shimizu, T. Inazumi, Y. Sogawa, A. Hyvärinen, Y. Kawahara, T. Washio, P. O. Hoyer and K. Bollen.
            DirectLiNGAM: A direct method for learning a linear non-Gaussian structural equation model. Journal of
            Machine Learning Research,
            12(Apr): 1225–1248, 2011.</p>
        <p>A. Hyvärinen and S. M. Smith. Pairwise likelihood ratios for estimation of non-Gaussian structural
            evaluation models.
            Journal of Machine Learning Research 14:111-152, 2013.</p>
    </div>

    <h3>The DAGMA Algorithm</h3>

    <h4>Description</h4>

    <div id="dagma">
        <p>Implements the DAGMA algorithm. The reference is here:</p>
        <p>Bello, K., Aragam, B., & Ravikumar, P. (2022). Dagma: Learning dags via m-matrices and a log-determinant
            acyclicity characterization. Advances in Neural Information Processing Systems, 35, 8226-8239.</p>
    </div>

    <h4>Input Assumptions</h4>

    <p>Same as FASK.</p>

    <h4>Output Format</h4>

    <p>Same as FASK.</p>

    <h3>The FASK-Vote Algorithm</h3>

    <h4>Description</h4>

    <div id="fask-vote"><p>FASK-Vote is a metascript that learns a
        model from a list of datasets in a method similar to IMaGES (see). For
        adjacencies, it uses FAS-Stable with the voting-based score from IMaGES
        used as a test (using all the datasets, standardized), producing a
        single undirected graph G. It then orients each edge X--Y in G for each
        dataset using the FASK (see) left-right rule and orient X->Y if that rule
        orients X--Y as such in at least half of the datasets. The final graph is
        returned. </p>

        <p>For FASK, See Sanchez-Romero R, Ramsey JD, Zhang K, Glymour
            MR, Huang B, Glymour C. Causal discovery of feedback networks with
            functional magnetic resonance imaging. Network Neuroscience 2018.</p>
    </div>

    <h4>Input Assumptions</h4>

    <p>Same as FASK.</p>

    <h4>Output Format</h4>

    <p>Same as FASK.</p>

    <h3>Orientation Algorithms (R3, RSkew, Skew)</h3>

    <h4>Description</h4>

    <div id="r3">

        <p>This is an algorithm that orients an edge X--Y for continuous
            variables based on non-Gaussian information. This rule in particular
            uses an entropy calculation to make the orientation. Note that if the
            variables X and Y are both Gaussian, and the model is linear, it is
            not possible to orient the edge X--Y pairwise; any attempt to do so
            would result in random orientation. But if X and Y are non-Gaussian,
            the orientation is fairly easy. This rule is similar to Hyvarinen and
            Smith's (2013) EB rule, but using Anderson Darling for the measure of
            non-Gaussianity, to somewhat better effect. See Ramsey et al. (2012).
        </p></div>


    <div id="skew">

        <p>This is an algorithm that orients an edge X--Y for continuous
            variables based on non-Gaussian information. This rule in particular
            uses a skewness to make the orientation. Note that if the variables X
            and Y are both Gaussian, and the model is linear, it is not possible
            to orient the edge X--Y pairwise; any attempt to do so would result
            in random orientation. But if X and Y are non-Gaussian, in particular
            in this case, if X and Y are skewed, the orientation is relatively
            straightforward. See Hyvarinen and Smith (2013) for details. </p>

        <p>The Skew rule is differently motivated from the RSkew rule
            (see), though they both appeal to the skewness of the variables.</p>

    </div>

    <div id="r-skew">

        <p>This is an algorithm that orients an edge X--Y for continuous
            variables based on non-Gaussian information. This rule in particular
            uses a skewness to make the orientation. Note that if the variables X
            and Y are both Gaussian, and the model is linear, it is not possible
            to orient the edge X--Y pairwise; any attempt to do so would result
            in random orientation. But if X and Y are non-Gaussian, in particular
            in this case, if X and Y are skewed, the orientation is relatively
            straightforward. See Hyvarinen and Smith (2013) for details. </p>

        <p>The RSkew rule is differently motivated from the Skew rule
            (see), though they both appeal to the skewness of the variables.</p>

    </div>

    <div id="fask-pw">

        <p>This is an algorithm that orients an edge X--Y for continuous
            variables based on non-Gaussian information. This rule in particular
            uses the FASK pairwise rule to make the orientation. Note that if the
            variables X and Y are both Gaussian, and the model is linear, it is
            not possible to orient the edge X--Y pairwise; any attempt to do so
            would result in random orientation. But if X and Y are non-Gaussian,
            in particular in this case, if X and Y are skewed, the orientation is
            relatively straightforward. See Hyvarinen and Smith (2013) for
            details. </p>

        <p>The FASK-PW rule appeals to skewness in a different way than
            Skew and RSkew.</p>

    </div>


    <h4>Input Assumptions</h4>

    <p>Continuous data in which the variables are non-Gaussian.
        Non-Gaussianity can be assessed using the Anderson-Darling score, which
        is available in the Data box.</p>

    <h4>Output Format</h4>

    <p>Orients all the edges in the input graph using the selected
        score.</p>

    <h4>Parameters</h4>

    <p><a href="#maxit">alpha</a>, <a href="#depth">depth</a></p>

    <h3>The BOSS-LiNGAM Algorithm</h3>

    <h4>Description</h4>

    <div id="boss-lingam">
        <p> Implements the BOSS-LiNGAM algorithm which first finds a CPDAG for the variables and then uses a
            non-Gaussian orientation method to orient the undirected edges. The reference is as follows:</p>
        <p>Hoyer et al., "Causal discovery of linear acyclic models with arbitrary distributions," UAI 2008.</p>
        <p>The test for normality used for residuals is Anderson-Darling, following 'ad.test' in the nortest package of
            R. The default alpha level is 0.05--that is, p values from AD below 0.05 are taken to indicate
            nongaussianity.</p>
        <p>It is assumed that the CPDAG is the result of a CPDAG search such as PC or GES. In any case, it is important
            that the residuals be independent for ICA to work.</p>
        <p>This may be replaced by a more general algorithm that allows alternatives for the CPDAG search and for the
            the non-Gaussian orientation method.</p>
        <p>This class is not configured to respect knowledge of forbidden and required edges.</p>
        <p>Note: If one wants to analyze time series data using this algorithm,
            one may set the time lag parameter to a value greater than 0, which
            will automatically apply the time lag transform. The same goes for any
            algorithm that has this parameter available in the interface.</p>
    </div>

    <h3>The CStaR Algorithm</h3>

    <h4>Description</h4>

    <div id="cstar">

        <p>The CStaR algorithm (Causal Stability Ranking, Stekhoven, D. J., Moraes, I., Sveinbjörnsson, G., Hennig,
            L.,
            Maathuis, M. H., & Bühlmann, P. 2012. Causal stability ranking. Bioinformatics, 28(21), 2819-2823)
            calculates lower bounds on estimated parameters for the causally sufficient case. It first runs a CPDAG
            algorithm and then for X->Y locally, about Y, finds all possible orientations of the edges in the CPDAG
            and
            does an estimation for each of these, and finds their lower bound. In the interface, all nodes that are
            found in the top bracket more than 50% of the time are marked as into that target node.</p>
        <p>The procedure is best used, however, as a command line procedure, in py-causal, rpy-causal, or Causal
            Command. Upon running the algorithm (even in the interface), a directory of result files will be
            produced as
            a record, including the dataset used, the possible causes and effects used, all the CPDAGs used and
            the
            tables of their IDA effects, and the CStaR output table itself.</p>
        <p></p>
        <p>Parameters.</p>
        <p>Algorithm. This is the algorithm to use to calculate bootstrapped CPDAGs. Current options are PC Stable,
            FGES, BOSS, or Restricted BOSS. For large datasets, we recommend Restricted BOSS, which calculates
            variables
            with marginal effect on one of the targets and then runs BOSS over this restricted set.</p>
        <p>Results Output Path. A default is “cstar-out”, which will place result-files in a subdirectory of the
            current
            directory named path = “cstar-out”.[n], where n is the first index for which no such directory exists.
            If a
            directory already exists at the path, then any information available in path directory will be used to
            generate results in the path-.[n] directory.</p>
        <p>Number of Sub-samples. CStaR finds CPDAGs over sub-sampled data of size n / 2; this specifies how many
            sub-samples to use.</p>
        <p>Minimum effect size. This allows a shorter table to be produced. It this is set to a value m > 0, then
            only
            records with PI > m will be displayed.</p>
        <p>Target Names. A list of names of variables (comma or space separated) can be given that are considered
            possible effects. These will be excluded from the list of possible causes, which will be all other
            variables
            in the dataset.</p>
        <p>Top Bracket. The CStaR algorithm tries to find possible causes that regularly sort into the top set of
            variables by minimum IDA effect. This gives the number q of variables to include in the top bracket,
            where 1
            <= q <= # possible causes.</p>
        <p>Parallelized. Yes, if the search should be parallelized, no if not. Default no.</p>
        <p>The main results of the algorithm is table in the format of Table 1 in Stekhoven et al. here is the
            beginning
            of one such table.</p>
        <pre>
        # Potential Causes = 19
        # Potential Effects = 1
        Top Bracket ('q') = 10

        Index  Cause  Effect      PI  Effect    PCER
        1    X15     X20  0.9000  0.0691  0.0035
        2     X4     X20  0.8800  0.0888  0.0146
        3    X18     X20  0.7200  0.0451  0.0567
        4    X17     X20  0.7000  0.0765  0.1108
        5    X19     X20  0.6800  0.0559  0.1924
        6     X1     X20  0.6600  0.0635  0.3116
        7     X3     X20  0.6600  0.0438  0.4242
        </pre>
        <p>Here, the number of possible causes and the number of possible effects is listed, as well as the top
            bracket
            (‘q’) used to generate the table. For each record considered, its cause and effect (e.g., X15 to X20).
            The
            percentage of times this cause/effect pair ended up in the top bracket is given as PI, and the minimum
            IDA
            effect size for it is given in Effect. The Per Comparison Error Rate (which can only be calculated for
            PI >
            0.5) is given in PCER. See the Stekhoven paper for details.</p>
    </div>

    <h4>Input Assumptions</h4>

    <p>Same as for PC.</p>


    <h2>Statistical Tests</h2>

    <p>All the below tests do testwise deletion as a default way of
        dealing with missing values. For testwise deletion, if a test, say, I(X,
        Y | Z), is done, columns for X, Y, and Z are scanned for missing values.
        If any row occurs in which X, Y, or Z is missing, that row is deleted
        from the data for those three variables. So if a different test, I(R, W |
        Q, T) is done, different rows may be stricken from the data. That is, the
        deletion is done testwise. For a useful discussion of the testwise
        deletion condition, see for instance Tu, R., Zhang, C., Ackermann, P.,
        Mohan, K., Kjellström, H., & Zhang, K. (2019, April). Causal discovery in
        the presence of missing data. In The 22nd International Conference on
        Artificial Intelligence and Statistics (pp. 1762-1770). PMLR. For all of
        these tests, if no data are missing, the behavior will be as if testwise
        deletion were not being done.</p>

    <h3>BDeu Test</h3>

    <div id="bdeu-test"><p> This is a test based on the BDeu score given
        in Heckerman, D., Geiger, D., & Chickering, D. M. (1995). Learning
        Bayesian networks: The combination of knowledge and statistical data.
        <i>Machine learning, 20</i>(3), 197-243, used as a test. This gives a
        score for any two variables conditioned on any list of others which is
        more positive for distributions which are more strongly dependent. The
        test for X _||_ Y | Z compares two different models, X conditional on Y,
        and X conditional on Y and Z; the scores for the two models are
        subtracted, in that order. If the difference is negative, independence is
        inferred. </p></div>

    <h3>Fisher Z Test</h3>

    <div id="fisher-z-test"><p> Fisher Z judges independence if the
        conditional correlation is cannot statistically be distinguished from
        zero. Primarily for the linear, Gaussian case. </p></div>

    <h4>Parameters</h4>

    <p><a href="#alpha">alpha</a></p>

    <h3>SEM BIC Test</h3>

    <div id="sem-bic-test"><p> This uses the SEM BIC Score to create a
        test for the linear, Gaussian case, where we include an additional
        penalty term, which is commonly used. We call this the <i>penalty
            discount</i>. So our formulas has BIC = 2L - ck log N,where L is the
        likelihood, c the penalty discount (usually greater than or equal to 1),
        and N the sample size. Since the assumption is that the data are
        distributed as Gaussian, this reduces to BIC = -n log sigma - ck ln N,
        where sigma is the standard deviation of the linear residual obtained by
        regressing a child variable onto all of its parents in the model. </p>
    </div>

    <h3>Mixed Variable Polynomial Likelihood Ratio Test</h3>

    <div id="mvplr-test">
        <p>Performs a test of conditional independence X _||_ Y | Z1...Zn where all variables are either continuous or
            discrete.
            This test is valid for both ordinal and non-ordinal discrete searchVariables.</p>
        <p>Andrews, B., Ramsey, J., &amp; Cooper, G. F. (2018). Scoring Bayesian networks of mixed variables.
            International
            journal of data science and analytics, 6, 3-18.</p>
    </div>

    <h4>Parameters</h4>d

    <p><a href="#penaltyDiscount">penaltyDiscount</a></p>

    <h3>Generalized Information Criterion Scores</h3>

    <div id="gic-bic-tests"><p>
        This is a set of generalized information criterion (GIC) scores, used as tests,
        based on the paper, Kim, Y., Kwon, S., & Choi, H. (2012). Consistent model selection
        criteria on high dimensions. The Journal 0of Machine Learning Research,
        13(1), 1037-1057. One needs to select which lambda to use in place of the
        usual lambda for the linear, Gaussian BIC score. A penalty discount parameter
        may also be specified, though this is by default for these scores equal
        to 1 (since the lambda choice is essentially picking a penalty discount
        for you).
    </p>
    </div>

    <h3>MAG SEM BIC Test</h3>

    <div id="mag-sem-bic-test"><p>
        This gives a BIC score (used as a test here) for a Mixed Ancestral Graph (MAG).
        Note that BIC is calculated as 2L - k ln N, so "higher is better."
    </p>
    </div>

    <h3>Probabilistic Test</h3>

    <div id="prob-test"><p> The Probabilistic Test applies a Bayesian
        method to derive the posterior probability of an independence constraint
        R = (X⊥Y|Z) given a dataset D. This is intended for use with datasets
        with discrete variables. It can be used with constraint-based algorithms
        (e.g., PC and FCI). Since this test provides a probability for each
        independence constraint, it can be used stochastically by sampling based
        on the probabilities of the queried independence constraints to obtain
        several output graphs. It can also be used deterministically by using a
        fixed decision threshold on the probabilities of the queried independence
        constraints to generate a single output graph. </p></div>

    <h4>Parameters</h4>

    <p><a
            href="#noRandomlyDeterminedIndependence">noRandomlyDeterminedIndependence
    </a> <a href="#cutoffIndTest">cutoffIndTest</a> <a
            href="#priorEquivalentSampleSize">priorEquivalentSampleSize</a></p>


    <h3>Conditional Correlation Independence (CCI) Test</h3>

    <div id="cci-test"><p>CCI ("Conditional Correlation Independence")
        is a fairly general independence test—not completely general, but general
        for additive noise models—that is, model in which each variable is equal
        to a (possibly nonlinear) function of its parents, plus some additive
        noise, where the noise may be arbitrarily distributed. That is, X =
        f(parent(X)) + E, where f is any function and E is noise however
        distributed; the only requirement is that there be the “+” in the formula
        separating the function from the noise. The noise can’t for instance, be
        multiplicative, e.g., X = f(parent(X)) x E. The goal of the method is to
        estimate whether X is independent of Y given variables Z, for some X, Y,
        and Z. It works by calculating the residual of X given Z and the residual
        of Y given Z and looking to see whether those two residuals are
        independent. This test may be used with any constraint-based algorithm
        (PC, FCI, etc.).</p></div>

    <h4>Parameters</h4>

    <p><a href="#alpha">alpha</a>, <a
            href="#numBasisFunctions">numBasisFunctions</a>, <a
            href="#kernelType">kernelType</a>, <a
            href="#kernelMultiplier">kernelMultiplier</a>, <a
            href="#basisType">basisType</a>, <a
            href="#kernelRegressionSampleSize">kernelRegressionSampleSize</a></p>

    <h3>Chi Square Test</h3>

    <div id="chi-square-test"><p> This is the usual Chi-Square test for
        discrete variables; consult an introductory statistics book for details
        for the unconditional case, where you're just trying, e.g., to determine
        if X and Y are independent. For the conditional case, the test proceeds
        as in Fienberg, S. E. (2007). <i>The analysis of cross-classified
            categorical data</i>, Springer Science & Business Media, by identifying
        and removing from consideration zero rows or columns in the conditional
        tables and judging dependence based on the remaining rows and columns.
    </p></div>

    <h4>Parameters</h4>

    <p><a href="#alpha">alpha</a></p>

    <h3>M-Separation Test</h3>

    <div id="m-sep-test"><p> This is the usual test of m-separation, a
        property of graphs, not distributions. It's not really a test, but it can
        be used in place of a test of the true graph is known. This is a way to
        find out, for constraint-based algorithms, or even for some score-based
        algorithms like FGES, what answer the algorithm would give if all the
        statistical decisions made are correct. Just draw an edge from the true
        graph to the algorithm--the m-separation option will appear, and you can
        then just run the search as usual. Note that D-Separation and M-separation
        use the same algorithm; we uniformly call the algorithm "M-Separation" for
        clarity. D-Separation is M-Separation applied to DAGs.
    </p></div>

    <h3>Discrete BIC Test</h3>

    <div id="disc-bic-test"><p> This is a BIC score for the discrete
        case, used as a test. The likelihood is judged by the multinomial tables
        directly, and this is penalized as is usual for a BIC score. The only
        surprising thing perhaps is that we use the formula BIC = 2L - k ln N,
        where L is the likelihood, k the number of parameters, and N the sample
        size, so "higher is better." In the case of independence, the BIC
        score will be negative, since the likelihood will be zero, and this will
        be penalized. The test yields a p-value; we simply use alpha - p as the
        score, where alpha is the cutoff for rejecting the null hypothesis of
        independence. This is a number that is positive for dependent cases and
        negative for independent cases.</div>

    <h4>Parameters</h4>

    <p><a href="#penaltyDiscount">penaltyDiscount</a>, <a
            href="#structurePrior">structurePrior</a></p>

    <h3>G Square Test</h3>

    <div id="g-square-test"><p> This is completely parallel to the
        Chi-Square statistic, using a slightly different method for estimating
        the statistic. The alternative statistic is still distributed as
        chi-square in the limit. In practice, this statistic is more or less
        indistinguishable in most cases from Chi-Square. For an explanation, see
        Spirtes, P., Glymour, C. N., Scheines, R., Heckerman, D., Meek, C.,
        Cooper, G., & Richardson, T. (2000). <i>Causation, prediction, and
            search</i>. MIT press. </p></div>

    <h4>Parameters</h4>

    <p><a href="#alpha">alpha</a></p>

    <h3>Kernel Conditional Independence (KCI) Test</h3>

    <div id="kci-test"><p>KCI ("Kernel Conditional Independence") is a
        general independence test for model in which X = f(parents(X), eY); here,
        eY does not need to be additive; it can stand in any functional
        relationships to the other variables. The variables may even be discrete.
        The goal of the method is to estimate whether X is independent of Y given
        Z, completely generally. It uses the kernel trick to estimate this. As a
        result of using the kernel trick, the method is complex in the direction
        of sample size, meaning that it may be very slow for large samples. Since
        it’s slow, individual independence results are always printed to the
        console so the user knows how far a procedure has gotten. This test may
        be used with any constraint-based algorithm (PC, FCI, etc.)</p></div>

    <h4>Parameters</h4>

    <p><a href="#alpha">alpha</a>, <a
            href="#kciUseApproximation">kciUseApproximation</a>, <a
            href="#kernelMultiplier">kernelMultiplier</a>, <a
            href="#kciNumBootstraps">kciNumBootstraps</a>, <a
            href="#thresholdForNumEigenvalues">thresholdForNumEigenvalues</a>, <a
            href="#kciEpsilon">kciEpsilon</a></p>

    <h3>Conditional Gaussian Likelihood Ratio Test</h3>

    <div id="cg-lr-test"><p> Conditional Gaussian Test is a likelihood
        ratio test based on the conditional Gaussian likelihood function. This is
        intended for use with datasets where there is a mixture of continuous and
        discrete variables. It is assumed that the continuous variables are
        Gaussian conditional on each combination of values for the discrete
        variables, though it will work fairly well even if that assumption does
        not hold strictly. This test may be used with any constraint-based
        algorithm (PC, FCI, etc.). See Andrews, B., Ramsey, J., & Cooper, G.
        F. (2018). Scoring Bayesian networks of mixed variables. International
        journal of data science and analytics, 6(1), 3-18. </p></div>

    <div id="dg-lr-test"><p> Degenerate Gaussian Likelihood Ratio Test
        may be used for the case where there is a mixture of discrete and
        Gaussian variables. Calculates a likelihood ratio based on likelihood
        that is calculated using a conditional Gaussian assumption. See Andrews,
        B., Ramsey, J., & Cooper, G. F. (2019). Learning high-dimensional
        directed acyclic graphs with mixed data-types. Proceedings of machine
        learning research, 104, 4. </p></div>

    <h4>Parameters</h4>

    <p><a href="#structurePrior">structurePrior</a></p>

    <h4>Parameters</h4>

    <p><a href="#alpha">alpha</a>, <a
            href="#discretize">discretize</a></p>

    <h3>Resampling</h3>

    <p>Most TETRAD searches can be performed with resampling. This option
        is available on the Set Parameters screen. When it is selected, the
        search will be performed multiple times on randomly selected subsets of
        the data, and the final output graph will be the result of a voting
        procedure among all the graphs. These subsets may be selected with
        replacement (bootstrapping) or without. There are also options for the
        user to set the size of the subset, and the number of resampling runs.
        The default number of resampling runs is zero, in which case no
        resampling will be performed.</p>

    <p>For each potential edge in the final output graph, the individual
        sampled graphs may contain a directed edge in one direction, the other
        direction, a bidirected edge, an uncertain edge, or no edge at all. The
        voting procedure reconciles all of these possible answers into a single
        final graph, and the "ensemble method," which can be set by the user in
        the parameter settings screen, determines how it will do that.</p>

    <p>The four available ensemble methods are Preserved, Highest, and
        Majority. Preserved tends to return the densest graphs, then Highest, and
        finally Majority returns the sparsest. The Preserved ensemble method
        ensures that an edge that has been found by some portion of the
        individual sample graphs is preserved in the final graph, even if the
        majority of sample graphs returned [no edge] as their answer for that
        edge. So the voting procedure for Preserved is to return the edge
        orientation that the highest percentage of sample graphs returned, other
        than [no edge]. The Highest ensemble method, on the other hand, simply
        returns the edge orientation which the highest proportion of sample
        graphs returned, even if that means returning [no edge]. And the Majority
        method requires that at least 50 percent of the sample graphs agree on an
        edge orientation in order to return any edge at all. If the highest
        proportion of sample graphs agree on, for instance, a bidirected edge,
        but only 40 percent of them do so, then the Majority ensemble method will
        return [no edge] for that edge.</p>

    <p>One small point of clarification. In the bootstrapping, for a --> edge,
        there are three columns. These are to capture various types of --> edges
        that may be found in estimated PAGs--whether the --> edge is visible and/or
        definitely direct. For estimated CPDAGs, these three columns may be summed.
        Similarly, for <-- edges.
    </p>

    <h2>Scoring Functions</h2>

    <p>Like the tests, above, all the below tests do testwise deletion
        as a default way of dealing with missing values. For testwise deletion,
        if a score, say, score(X | Y, Z), is done, columns for X, Y, and Z are
        scanned for missing values. If any row occurs in which X, Y, or Z is
        missing, that row is deleted from the data for those three variables. So
        if a different test, score(R | W, Q, T) is done, different rows may be
        stricken from the data. That is, the deletion is done testwise. For a
        useful discussion of the testwise deletion condition, see for instance
        Tu, R., Zhang, C., Ackermann, P., Mohan, K., Kjellström, H., & Zhang, K.
        (2019, April). Causal discovery in the presence of missing data. In The
        22nd International Conference on Artificial Intelligence and Statistics
        (pp. 1762-1770). PMLR. For all of these tests, if no data are missing,
        the behavior will be as if testwise deletion were not being done.</p>

    <h3>BDeu Score</h3>

    <div id="bdeu-score"><p> This is the BDeu score given in Heckerman,
        D., Geiger, D., & Chickering, D. M. (1995). Learning Bayesian networks:
        The combination of knowledge and statistical data. <i>Machine learning,
            20</i>(3), 197-243. This gives a score for any two variables conditioned
        on any list of others which is more positive for distributions which are
        more strongly dependent. </p></div>

    <h4>Parameters</h4>

    <h3>Conditional Gaussian BIC Score</h3>

    <div id="cg-bic-score"><p> Conditional Gaussian BIC Score may be
        used for the case where there is a mixture of discrete and Gaussian
        variables. Calculates a BIC score based on likelihood that is calculated
        using a conditional Gaussian assumption. See Andrews, B., Ramsey, J., &
        Cooper, G. F. (2018). Scoring Bayesian networks of mixed variables.
        International journal of data science and analytics, 6(1), 3-18.
        Note that BIC is calculated as 2L - k ln N, so "higher is better."</p>
    </div>

    <h4>Parameters</h4>

    <p><a href="#structurePrior">structurePrior</a>, <a
            href="#discretize">discretize</a></p>

    <div id="dg-bic-score"><p> Degenerate Gaussian BIC Score may be used
        for the case where there is a mixture of discrete and Gaussian variables.
        Calculates a BIC score based on likelihood that is calculated using a
        conditional Gaussian assumption. See Andrews, B., Ramsey, J., & Cooper,
        G. F. (2019). Learning high-dimensional directed acyclic graphs with
        mixed data-types. Proceedings of machine learning research, 104, 4.
        Note that BIC is calculated as 2L - k ln N, so "higher is better."</p>
    </div>

    <h4>Parameters</h4>

    <p><a href="#structurePrior">structurePrior</a></p>

    <h3>M-separation Score</h3>

    <div id="m-sep-score"><p> This uses m-separation to make something
        that acts as a score if you know the true graph. A score in Tetrad, for
        FGES, say, is a function that for X and Y conditional on Z, returns a
        negative number if X _||_ Y | Z and a positive number otherwise. So to
        get this behavior in no u certain terms, we simply return -1 for
        independent cases and +1 for dependent cases. Works like a charm. This
        can be used for FGES to check what the ideal behavior of the algorithm
        should be. Simply draw an edge from the true graph to the search box,
        select FGES, and search as usual. </p></div>

    <h3>Discrete BIC Score</h3>

    <div id="disc-bic-score"><p> This is a BIC score for the discrete
        case. The likelihood is judged by the multinomial tables directly, and
        this is penalized as is usual for a BIC score. The only surprising thing
        perhaps is that we use the formula BIC = 2L - k ln N, where L is the
        likelihood, k the number of parameters, and N the sample size, instead of
        the usual L + k / 2 ln N. So higher BIC scores will correspond to greater
        dependence. In the case of independence, the BIC score will be negative,
        since the likelihood will be zero, and this will be penalized. </p>
    </div>

    <h3>SEM BIC Score</h3>

    <div id="sem-bic-score"><p> This is specifically a BIC score for the
        linear, Gaussian case, where we include an additional penalty term, which
        is commonly used. We call this the <i>penalty discount</i>. So our
        formulas has BIC = 2L - ck log N, where L is the likelihood, c the
        penalty discount (usually greater than or equal to 1), and N the sample
        size. Since the assumption is that the data are distributed as Gaussian,
        this reduces to BIC = -n log sigma - ck ln N, where sigma is the standard
        deviation of the linear residual obtained by regressing a child variable
        onto all of its parents in the model. </p></div>

    <h4>Parameters</h4>

    <p><a href="#penaltyDiscount">penaltyDiscount</a></p>

    <h3>EBIC Score</h3>

    <div id="ebic-score"><p> This is the Extended BIC (EBIC) score of
        Chen and Chen (Chen, J., & Chen, Z. (2008). Extended Bayesian information
        criteria for model selection with large model spaces. Biometrika, 95(3),
        759-771.). This score is adapted to score-based search in high
        dimensions. There is one parameter, gamma, which takes a value between 0
        and 1; if it's 0, the score is standard BIC. A value of 0.5 or 1 is
        recommended depending on how many variables there are per sample. </p>
    </div>

    <h3>GIC Scores</h3>

    <div id="gic-scores"><p>
        This is a set of generalized information criterion (GIC) scores based on
        the paper, Kim, Y., Kwon, S., & Choi, H. (2012). Consistent model selection
        criteria on high dimensions. The Journal 0of Machine Learning Research,
        13(1), 1037-1057. One needs to select which lambda to use in place of the
        usual lambda for the linear, Gaussian BIC score. A penalty discount parameter
        may also be specified, though this is by default for these scores equal
        to 1 (since the lambda choice is essentially picking a penalty discount
        for you).
    </p>
    </div>

    <h3>Mixed Variable Polynomial Scores</h3>

    <div id="mvp-bic-score"><p>
        <p>Implements a mixed variable polynomial BIC score. The reference is here:</p>
        <p>Andrews, B., Ramsey, J., &amp; Cooper, G. F. (2018). Scoring Bayesian networks of mixed variables.
            International journal of data science and analytics, 6, 3-18.</p>
    </div>

    <h3>Poisson Prior Score</h3>

    <div id="poisson-prior-score"><p>
        This is likelihood score attenuated by the log
        of the Poisson distribution. It has one parameter, lambda, from the Poisson
        distribution, which acts as a structure prior.
    </p>
    </div>

    <h3>Zhang-Shen Bound Score</h3>

    <div id="zsbound-score"><p>
        Uses Theorem 1 from Zhang, Y., & Shen, X. (2010). Model selection procedure for
        high‐dimensional data. Statistical Analysis and Data Mining: The ASA Data
        Science Journal, 3(5), 350-358, to make a score that controls false positives.
        The is one parameter, the "risk bound", a number between 0 and 1 (a bound on
        false positive risk probability).
    </p>
    </div>

    <div id="parameters"><h2>Search Parameters</h2>

        <h3 class="parameter_description"
            id="numThreads">numThreads</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="numThreads_short_desc">The number of threads (>= 1) to use for the search</span></li>
            <li>Long Description: <span
                    id="numThreads_long_desc">The number of threads to use for the search.</span>
            </li>
            <li>Default Value: <span
                    id="numThreads_default_value">1</span></li>
            <li>Lower
                Bound: <span id="numThreads_lower_bound">1</span></li>
            <li>Upper Bound: <span
                    id="numThreads_upper_bound">1000000</span></li>
            <li>Value Type:
                <span id="numThreads_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description"
            id="bootstrappingNumThreads">bootstrappingNumThreads</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="bootstrappingNumThreads_short_desc">The number of threads (>= 1) to use for the bootstrapping</span>
            </li>
            <li>Long Description: <span
                    id="bootstrappingNumThreads_long_desc">
                    This is the number of threads for the bootstrapping itself. The number
                    of threads that each algorithm uses is set by the individual algorithm.
                    </span>
            </li>
            <li>Default Value: <span
                    id="bootstrappingNumThreads_default_value">1</span></li>
            <li>Lower
                Bound: <span id="bootstrappingNumThreads_lower_bound">1</span></li>
            <li>Upper Bound: <span
                    id="bootstrappingNumThreads_upper_bound">1000000</span></li>
            <li>Value Type:
                <span id="bootstrappingNumThreads_value_type">Integer</span></li>
        </ul>

        <p>Note: You must specify the "Value Type" of each parameter, and
            the value type must be one of the following: Integer, Long, Double, String,
            Boolean.</p>

        <h3 class="parameter_description"
            id="sampleStyle">sampleStyle</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="sampleStyle_short_desc">Sample style: 1 = Subsample, 2 = Bootstrap</span></li>
            <li>Long Description: <span
                    id="sampleStyle_long_desc"> Sample style: 1 = Subsample, 2 = Bootstrap </span>
            </li>
            <li>Default Value: <span
                    id="sampleStyle_default_value">1</span></li>
            <li>Lower
                Bound: <span id="sampleStyle_lower_bound">1</span></li>
            <li>Upper Bound: <span
                    id="sampleStyle_upper_bound">2</span></li>
            <li>Value Type:
                <span id="sampleStyle_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description"
            id="removeEffectNodes">removeEffectNodes</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="removeEffectNodes_short_desc">True if effect nodes should bre removed from possible causes </span>
            </li>
            <li>Long Description: <span
                    id="removeEffectNodes_long_desc">True if effect nodes should be removed from possible causes </span>
            </li>
            <li>Default Value: <span
                    id="removeEffectNodes_default_value">True</span></li>
            <li>Lower
                Bound: <span id="removeEffectNodes_lower_bound"></span></li>
            <li>Upper Bound: <span
                    id="removeEffectNodes_upper_bound"></span></li>
            <li>Value Type:
                <span id="removeEffectNodes_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description"
            id="piThr">piThr</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="piThr_short_desc">A fixed threshold for calculating E[V] and PCER</span></li>
            <li>Long Description: <span
                    id="piThr_long_desc"> A fixed threshold, default 0.5 </span>
            </li>
            <li>Default Value: <span
                    id="piThr_default_value">0.6</span></li>
            <li>Lower
                Bound: <span id="piThr_lower_bound">0</span></li>
            <li>Upper Bound: <span
                    id="piThr_upper_bound">1</span></li>
            <li>Value Type:
                <span id="piThr_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description"
            id="cstarCpdagAlgorithm">cstarCpdagAlgorithm</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="cstarCpdagAlgorithm_short_desc">Algorithm: 1 = PC Stable, 2 = FGES, 3 = BOSS, 4 = Restricted BOSS </span>
            </li>
            <li>Long Description: <span
                    id="cstarCpdagAlgorithm_long_desc">The CPDAG algorithm to use: 1 = PC Stable, 2 = FGES, 3 = BOSS, 4 = Restricted BOSS </span>
            </li>
            <li>Default Value: <span
                    id="cstarCpdagAlgorithm_default_value">4</span></li>
            <li>Lower
                Bound: <span id="cstarCpdagAlgorithm_lower_bound">1</span></li>
            <li>Upper Bound: <span
                    id="cstarCpdagAlgorithm_upper_bound">4</span></li>
            <li>Value Type:
                <span id="cstarCpdagAlgorithm_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description"
            id="trimmingStyle">trimmingStyle</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="trimmingStyle_short_desc">Trimming Style: 1 = None, 2 = Adjacencies, 3 = MB DAG, 4 = Semidirected paths</span>
            </li>
            <li>Long Description: <span
                    id="trimmingStyle_long_desc">'Adjacencies' trims to the adjacencies the targets, MB DAGs to the Union(MB(targets)) U targets,
                semidirected trims to nodes with semidirected paths to the targets. </span>
            </li>
            <li>Default Value: <span
                    id="trimmingStyle_default_value">3</span></li>
            <li>Lower
                Bound: <span id="trimmingStyle_lower_bound">1</span></li>
            <li>Upper Bound: <span
                    id="trimmingStyle_upper_bound">4</span></li>
            <li>Value Type:
                <span id="trimmingStyle_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description"
            id="numberOfExpansions">numberOfExpansions</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="numberOfExpansions_short_desc">Number of expansions of the algorithm away from the target</span>
            </li>
            <li>Long Description: <span
                    id="numberOfExpansions_long_desc">Each expansion iterates to concentrically more variables </span>
            </li>
            <li>Default Value: <span
                    id="numberOfExpansions_default_value">2</span></li>
            <li>Lower
                Bound: <span id="numberOfExpansions_lower_bound">1</span></li>
            <li>Upper Bound: <span
                    id="numberOfExpansions_upper_bound">1000</span></li>
            <li>Value Type:
                <span id="numberOfExpansions_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description"
            id="lambda1">lambda1</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="lambda1_short_desc">lambda1</span></li>
            <li>Long Description: <span
                    id="lambda1_long_desc">Tuning parameter for DAGMA</span>
            </li>
            <li>Default Value: <span
                    id="lambda1_default_value">0.05</span></li>
            <li>Lower
                Bound: <span id="lambda1_lower_bound">0</span></li>
            <li>Upper Bound: <span
                    id="lambda1_upper_bound">Infinity</span></li>
            <li>Value Type:
                <span id="lambda1_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description"
            id="cpdag">cpdag</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="cpdag_short_desc">True if a CPDAG should be returned, false if a DAG</span></li>
            <li>Long Description: <span
                    id="cpdag_long_desc">The algorithm returns a DAG; if this is
                    set to True, this DAG is converted to a CPDAG</span>
            </li>
            <li>Default Value: <span
                    id="cpdag_default_value">true</span></li>
            <li>Lower
                Bound: <span id="cpdag_lower_bound"></span></li>
            <li>Upper Bound: <span
                    id="cpdag_upper_bound"></span></li>
            <li>Value Type:
                <span id="cpdag_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description"
            id="wThreshold">wThreshold</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="wThreshold_short_desc">wThreshold</span></li>
            <li>Long Description: <span
                    id="wThreshold_long_desc">Tuning parameter for DAGMA</span>
            </li>
            <li>Default Value: <span
                    id="wThreshold_default_value">0.1</span></li>
            <li>Lower
                Bound: <span id="wThreshold_lower_bound">0</span></li>
            <li>Upper Bound: <span
                    id="wThreshold_upper_bound">Infinity</span></li>
            <li>Value Type:
                <span id="wThreshold_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description"
            id="addOriginalDataset">addOriginalDataset</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="addOriginalDataset_short_desc">Yes, if adding the original dataset
        as another bootstrapping</span></li>
            <li>Long Description: <span
                    id="addOriginalDataset_long_desc"> Select “Yes” here to include an
        extra run using the original dataset for improved accuracy.</span>
            </li>
            <li>Default Value: <span
                    id="addOriginalDataset_default_value">false</span></li>
            <li>Lower
                Bound: <span id="addOriginalDataset_lower_bound"></span></li>
            <li>Upper Bound: <span
                    id="addOriginalDataset_upper_bound"></span></li>
            <li>Value Type:
                <span id="addOriginalDataset_value_type">Boolean</span></li>
        </ul>


        <h3 class="parameter_description"
            id="saveBootstrapGraphs">saveBootstrapGraphs</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="saveBootstrapGraphs_short_desc">Yes if individual bootstrapping
                    graphs should be saved</span></li>
            <li>Long Description: <span
                    id="saveBootstrapGraphs_long_desc"> Bootstrapping provides a summary
                    over individual search graphs; select Yes here if these individual
                    graphs should be saved</span>
            </li>
            <li>Default Value: <span
                    id="saveBootstrapGraphs_default_value">false</span></li>
            <li>Lower
                Bound: <span id="saveBootstrapGraphs_lower_bound"></span></li>
            <li>Upper Bound: <span
                    id="saveBootstrapGraphs_upper_bound"></span></li>
            <li>Value Type:
                <span id="saveBootstrapGraphs_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description" id="alpha">alpha</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="alpha_short_desc">Cutoff for p values (alpha) (min =
        0.0)</span></li>
            <li>Long Description: <span id="alpha_long_desc">
        The cutoff, beyond which test results are judged as dependent, for a
        statistical test of independence. Default 0.05. Higher alpha yields a
        sparser graph.</span></li>
            <li>Default Value: <span
                    id="alpha_default_value">0.01</span></li>
            <li>Lower Bound: <span
                    id="alpha_lower_bound">0.0</span></li>
            <li>Upper Bound: <span
                    id="alpha_upper_bound">1.0</span></li>
            <li>Value Type: <span
                    id="alpha_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description" id="applyR1">applyR1</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="applyR1_short_desc"> Yes if the orient away from arrow rule
        should be applied</span></li>
            <li>Long Description: <span
                    id="applyR1_long_desc"> Set this parameter to “No” if a chain of
        directed edges pointing in the same direction when only the first few
        such orientations are justified based on the data.</span></li>
            <li>Default Value: <span id="applyR1_default_value">true</span></li>
            <li>Lower Bound: <span id="applyR1_lower_bound"></span></li>
            <li>Upper Bound: <span id="applyR1_upper_bound"></span></li>
            <li>Value Type: <span id="applyR1_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description" id="avgDegree">avgDegree</h3>
        <ul class="parameter_description_list">
            <li>Short Description: <span
                    id="avgDegree_short_desc">Average degree of graph (min =
        1)</span></li>
            <li>Long Description: <span id="avgDegree_long_desc">
        The average degree of a graph is equal to 2E / V, where E is the
        number of edges in the graph and V the number of variables (vertices)
        in the graph, since each edge has two endpoints.</span></li>
            <li>Default Value: <span id="avgDegree_default_value">2</span></li>
            <li>Lower Bound: <span id="avgDegree_lower_bound">1</span></li>
            <li>Upper Bound: <span
                    id="avgDegree_upper_bound">2147483647</span></li>
            <li>Value Type:
                <span id="avgDegree_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description"
            id="probabilityOfEdge">probabilityOfEdge</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="probabilityOfEdge_short_desc"> Probability of an adjacency being
        included in the graph</span></li>
            <li>Long Description: <span
                    id="probabilityOfEdge_long_desc"> Every possible adjacency in the
        graph is included it the graph with this probability. </span></li>
            <li>Default Value: <span
                    id="probabilityOfEdge_default_value">0.05</span></li>
            <li>Lower
                Bound: <span id="probabilityOfEdge_lower_bound">0.0</span></li>
            <li>Upper Bound: <span
                    id="probabilityOfEdge_upper_bound">1.0</span></li>
            <li>Value Type:
                <span id="probabilityOfEdge_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description" id="basisType">basisType</h3>
        <ul class="parameter_description_list">
            <li>Short Description: <span
                    id="basisType_short_desc"> Basis type (1 = Polynomial, 2 =
        Cosine)</span></li>
            <li>Long Description: <span
                    id="basisType_long_desc"> For CCI, this determines which basis type
        will be used (1 = Polynomial, 2 = Cosine)</span></li>
            <li>Default
                Value: <span id="basisType_default_value">2</span></li>
            <li>Lower
                Bound: <span id="basisType_lower_bound">1</span></li>
            <li>Upper
                Bound: <span id="basisType_upper_bound">2</span></li>
            <li>Value Type:
                <span id="basisType_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description"
            id="cciScoreAlpha">cciScoreAlpha</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="cciScoreAlpha_short_desc">Cutoff for p values (alpha) (min =
        0.0)</span></li>
            <li>Long Description: <span
                    id="cciScoreAlpha_long_desc">Alpha level (0 to 1)</span></li>
            <li>Default Value: <span
                    id="cciScoreAlpha_default_value">0.01</span></li>
            <li>Lower Bound:
                <span id="cciScoreAlpha_lower_bound">0.0</span></li>
            <li>Upper Bound:
                <span id="cciScoreAlpha_upper_bound">1.0</span></li>
            <li>Value Type:
                <span id="cciScoreAlpha_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description" id="cgExact">cgExact</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="cgExact_short_desc"> Yes if the exact algorithm should be used
        for continuous parents and discrete children</span></li>
            <li>Long
                Description: <span id="cgExact_long_desc"> For the conditional
        Gaussian likelihood, if the exact algorithm is desired for discrete
        children and continuous parents, set this parameter to “Yes”.</span>
            </li>
            <li>Default Value: <span
                    id="cgExact_default_value">false</span></li>
            <li>Lower Bound: <span
                    id="cgExact_lower_bound"></span></li>
            <li>Upper Bound: <span
                    id="cgExact_upper_bound"></span></li>
            <li>Value Type: <span
                    id="cgExact_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description" id="coefHigh">coefHigh</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="coefHigh_short_desc"> High end of coefficient range (min =
        0.0)</span></li>
            <li>Long Description: <span id="coefHigh_long_desc">
        Value m2 for coefficients drawn from U(-m2, -m1) U U(m1, m2).</span>
            </li>
            <li>Default Value: <span
                    id="coefHigh_default_value">1.0</span></li>
            <li>Lower Bound: <span
                    id="coefHigh_lower_bound">0.0</span></li>
            <li>Upper Bound: <span
                    id="coefHigh_upper_bound">1.7976931348623157E308</span></li>
            <li>Value Type: <span id="coefHigh_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description" id="coefLow">coefLow</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="coefLow_short_desc"> Low end of coefficient range (min =
        0.0)</span></li>
            <li>Long Description: <span id="coefLow_long_desc">
        The parameter m1 for coefficients drawn from U(-m2, -m1) U U(m1,
        m2).</span></li>
            <li>Default Value: <span
                    id="coefLow_default_value">0.0</span></li>
            <li>Lower Bound: <span
                    id="coefLow_lower_bound">0.0</span></li>
            <li>Upper Bound: <span
                    id="coefLow_upper_bound">1.7976931348623157E308</span></li>
            <li>Value
                Type: <span id="coefLow_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description"
            id="coefSymmetric">coefSymmetric</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="coefSymmetric_short_desc">Yes if negative coefficient values
        should be considered</span></li>
            <li>Long Description: <span
                    id="coefSymmetric_long_desc"> Yes if coefficients should be drawn
        from +/-(a, b); No if from +(a, b).</span></li>
            <li>Default Value:
                <span id="coefSymmetric_default_value">true</span></li>
            <li>Lower
                Bound: <span id="coefSymmetric_lower_bound"></span></li>
            <li>Upper
                Bound: <span id="coefSymmetric_upper_bound"></span></li>
            <li>Value
                Type: <span id="coefSymmetric_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description"
            id="colliderDiscoveryRule">colliderDiscoveryRule</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="colliderDiscoveryRule_short_desc"> Collider discovery: 1 = Lookup
        from adjacency sepsets, 2 = Conservative (CPC), 3 = Max-P</span>
            </li>
            <li>Long Description: <span
                    id="colliderDiscoveryRule_long_desc"> One may look them up from
        sepsets, as in the original PC, or estimate them conservatively, as
        from the Conservative PC algorithm, or by choosing the sepsets with
        the maximum p-value, as in PC-Max. </span></li>
            <li>Default Value:
                <span id="colliderDiscoveryRule_default_value">1</span></li>
            <li>Lower Bound: <span
                    id="colliderDiscoveryRule_lower_bound">1</span></li>
            <li>Upper Bound:
                <span id="colliderDiscoveryRule_upper_bound">3</span></li>
            <li>Value
                Type: <span id="colliderDiscoveryRule_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description"
            id="completeRuleSetUsed">completeRuleSetUsed</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="completeRuleSetUsed_short_desc"> Yes if the complete FCI rule set
        should be used</span></li>
            <li>Long Description: <span
                    id="completeRuleSetUsed_long_desc"> No if the (simpler) final
        orientation rules set due to P. Spirtes, guaranteeing arrow
        completeness, should be used; yes if the (fuller) set due to J. Zhang,
        should be used guaranteeing additional tail completeness. </span>
            </li>
            <li>Default Value: <span
                    id="completeRuleSetUsed_default_value">true</span></li>
            <li>Lower
                Bound: <span id="completeRuleSetUsed_lower_bound"></span></li>
            <li>Upper Bound: <span
                    id="completeRuleSetUsed_upper_bound"></span></li>
            <li>Value Type:
                <span id="completeRuleSetUsed_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description"
            id="doDiscriminatingPathRule">doDiscriminatingPathRule</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="doDiscriminatingPathRule_short_desc">Yes if the discriminating path rule
                should be done, No if not</span></li>
            <li>Long Description: <span
                    id="doDiscriminatingPathRule_long_desc">Yes if the discriminating path
                    FCI rule (part of the final orientation, requiring an additional test)
                    should be done, No if not </span>
            </li>
            <li>Default Value: <span
                    id="doDiscriminatingPathRule_default_value">true</span></li>
            <li>Lower
                Bound: <span id="doDiscriminatingPathRule_lower_bound"></span></li>
            <li>Upper Bound: <span
                    id="doDiscriminatingPathRule_upper_bound"></span></li>
            <li>Value Type:
                <span id="doDiscriminatingPathRule_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description"
            id="doDiscriminatingPathColliderRule">doDiscriminatingPathColliderRule</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="doDiscriminatingPathColliderRule_short_desc">Yes if the discriminating path collider rule
                should be done, No if not</span></li>
            <li>Long Description: <span
                    id="doDiscriminatingPathColliderRule_long_desc">Yes if the discriminating path collider
                    FCI rule (part of the final orientation, requiring an additional test)
                    should be done, No if not </span>
            </li>
            <li>Default Value: <span
                    id="doDiscriminatingPathColliderRule_default_value">false</span></li>
            <li>Lower
                Bound: <span id="doDiscriminatingPathColliderRule_lower_bound"></span></li>
            <li>Upper Bound: <span
                    id="doDiscriminatingPathColliderRule_upper_bound"></span></li>
            <li>Value Type:
                <span id="doDiscriminatingPathColliderRule_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description"
            id="doDiscriminatingPathTailRule">doDiscriminatingPathTailRule</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="doDiscriminatingPathTailRule_short_desc">Yes if the discriminating path tail rule
                should be done, No if not</span></li>
            <li>Long Description: <span
                    id="doDiscriminatingPathTailRule_long_desc">Yes if the discriminating path tail
                    FCI rule (part of the final orientation, requiring an additional test)
                    should be done, No if not </span>
            </li>
            <li>Default Value: <span
                    id="doDiscriminatingPathTailRule_default_value">true</span></li>
            <li>Lower
                Bound: <span id="doDiscriminatingPathTailRule_lower_bound"></span></li>
            <li>Upper Bound: <span
                    id="doDiscriminatingPathTailRule_upper_bound"></span></li>
            <li>Value Type:
                <span id="doDiscriminatingPathTailRule_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description"
            id="concurrentFAS">concurrentFAS</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="concurrentFAS_short_desc">Yes if a concurrent FAS should be
        done</span></li>
            <li>Long Description: <span
                    id="concurrentFAS_long_desc"> Yes if the version of the PC adjacency
        search that uses concurrent processing should be used, no if
        not.</span></li>
            <li>Default Value: <span
                    id="concurrentFAS_default_value">false</span></li>
            <li>Lower Bound:
                <span id="concurrentFAS_lower_bound"></span></li>
            <li>Upper Bound:
                <span id="concurrentFAS_upper_bound"></span></li>
            <li>Value Type:
                <span id="concurrentFAS_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description"
            id="conflictRule">conflictRule</h3>
        <ul class="parameter_description_list">
            <li>Short Description: <span
                    id="conflictRule_short_desc">Collider conflicts: 1 = Prioritize existing
                colliders, 2 =
        Orient bidirected, 3 = Overwrite existing colliders</span></li>
            <li>Long Description: <span id="conflictRule_long_desc"> 1 if the
        “overwrite” rule as introduced in the PCALG R package, 2 if all
        collider conflicts using bidirected edges, or 3 if existing colliders
        should be prioritized, ignoring subsequent conflicting
        information.</span></li>
            <li>Default Value: <span
                    id="conflictRule_default_value">1</span></li>
            <li>Lower Bound: <span
                    id="conflictRule_lower_bound">1</span></li>
            <li>Upper Bound: <span
                    id="conflictRule_upper_bound">3</span></li>
            <li>Value Type: <span
                    id="conflictRule_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description"
            id="meekPreventCycles">meekPreventCycles</h3>
        <ul class="parameter_description_list">
            <li>Short Description: <span
                    id="meekPreventCycles_short_desc">
                    Yes if cycles should be prevented in the application of the Meek rules</span></li>
            <li>Long Description: <span id="meekPreventCycles_long_desc">
            	It is possible due to unfaithfulness for the Meek rules to orient
            	cycles; this does a cycle check before each orientation to
            	prevent this.</span></li>
            <li>Default Value: <span
                    id="meekPreventCycles_default_value">true</span></li>
            <li>Lower Bound: <span
                    id="meekPreventCycles_lower_bound"></span></li>
            <li>Upper Bound: <span
                    id="meekPreventCycles_upper_bound"></span></li>
            <li>Value Type: <span
                    id="meekPreventCycles_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description" id="connected">connected</h3>
        <ul class="parameter_description_list">
            <li>Short Description: <span
                    id="connected_short_desc">Yes if graph should be
        connected</span></li>
            <li>Long Description: <span
                    id="connected_long_desc"> Yes if a random graph should be generated
        in which paths exists from every node to every other, no if
        not.</span></li>
            <li>Default Value: <span
                    id="connected_default_value">false</span></li>
            <li>Lower Bound: <span
                    id="connected_lower_bound"></span></li>
            <li>Upper Bound: <span
                    id="connected_upper_bound"></span></li>
            <li>Value Type: <span
                    id="connected_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description" id="topBracket">topBracket</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="topBracket_short_desc">Top bracket to look for causes in</span></li>
            <li>Long
                Description: <span id="topBracket_long_desc">Top bracket, 'q'</span></li>
            <li>Default
                Value: <span id="topBracket_default_value">5</span></li>
            <li>Lower Bound:
                <span id="topBracket_lower_bound">1</span></li>
            <li>Upper Bound: <span
                    id="topBracket_upper_bound">500000</span></li>
            <li>Value Type: <span
                    id="topBracket_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description"
            id="targets">targets</h3>
        <ul class="targets_list">
            <li>Short Description: <span id="targets_short_desc">Target names
        (comma or space separated)</span></li>
            <li>Long Description: <span
                    id="targets_long_desc">Target names (comma or space separated).</span>
            </li>
            <li>Default Value: <span
                    id="targets_default_value"></span></li>
            <li>Lower Bound: <span
                    id="targets_lower_bound"></span></li>
            <li>Upper Bound: <span
                    id="targets_upper_bound"></span></li>
            <li>Value Type: <span
                    id="targets_value_type">String</span></li>
        </ul>

        <h3 class="parameter_description"
            id="fileOutPath">fileOutPath</h3>
        <ul class="fileOutPath_list">
            <li>Short Description: <span id="fileOutPath_short_desc">Results output path</span></li>
            <li>Long Description: <span
                    id="fileOutPath_long_desc">Path to a directory in which results can be stored</span>
            </li>
            <li>Default Value: <span
                    id="fileOutPath_default_value">cstar-out</span></li>
            <li>Lower Bound: <span
                    id="fileOutPath_lower_bound"></span></li>
            <li>Upper Bound: <span
                    id="fileOutPath_upper_bound"></span></li>
            <li>Value Type: <span
                    id="fileOutPath_value_type">String</span></li>
        </ul>

        <h3 class="parameter_description"
            id="selectionMinEffect">selectionMinEffect</h3>
        <ul
                class="selectionMinEffect_list">
            <li>Short Description: <span
                    id="selectionMinEffect_short_desc"> Minimum effect size for listing
        effects in the CStaR table </span></li>
            <li>Long Description: <span
                    id="selectionMinEffect_long_desc"> Minimum effect size for listing
        effects in the CStaR table </span></li>
            <li>Default Value: <span
                    id="selectionMinEffect_default_value">0.0</span></li>
            <li>Lower
                Bound: <span id="selectionMinEffect_lower_bound">0.0</span></li>
            <li>Upper Bound: <span
                    id="selectionMinEffect_upper_bound">1.0</span></li>
            <li>Value Type:
                <span id="selectionMinEffect_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description"
            id="numSubsamples">numSubsamples</h3>
        <ul class="numSubsamples_list">
            <li>Short Description: <span id="numSubsamples_short_desc">
                The number of subsamples to generate.
            </span></li>
            <li>Long Description: <span id="numSubsamples_long_desc">
           		CStaR works by generating subsamples and summarizing across them; this
           		specified the number of subsamples to generate. Must be >= 1.
                effects in the CStaR table </span></li>
            <li>Default Value: <span
                    id="numSubsamples_default_value">10</span></li>
            <li>Lower
                Bound: <span id="numSubsamples_lower_bound">1</span></li>
            <li>Upper Bound: <span
                    id="numSubsamples_upper_bound">100000</span></li>
            <li>Value Type:
                <span id="numSubsamples_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description"
            id="numSub-samples">numSub-samples</h3>
        <ul class="numSub-samples_list">
            <li>Short Description: <span id="numSub-samples_short_desc">Number of
        sub-samples</span></li>
            <li>Long Description: <span
                    id="numSub-samples_long_desc">Number of sub-samples</span></li>
            <li>Default Value: <span
                    id="numSub-samples_default_value">50</span></li>
            <li>Lower Bound:
                <span id="numSub-samples_lower_bound">1</span></li>
            <li>Upper Bound:
                <span id="numSub-samples_upper_bound">500000</span></li>
            <li>Value
                Type: <span id="numSub-samples_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description" id="covHigh">covHigh</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="covHigh_short_desc">High end of covariance range (min =
        0.0)</span></li>
            <li>Long Description: <span id="covHigh_long_desc">
        The parameter c2 for range +/-U(c1, c2) for covariance values, c1 >=
        0.0</span></li>
            <li>Default Value: <span
                    id="covHigh_default_value">0.0</span></li>
            <li>Lower Bound: <span
                    id="covHigh_lower_bound">0.0</span></li>
            <li>Upper Bound: <span
                    id="covHigh_upper_bound">1.7976931348623157E308</span></li>
            <li>Value
                Type: <span id="covHigh_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description" id="covLow">covLow</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="covLow_short_desc">Low end of covariance range (min =
        0.0)</span></li>
            <li>Long Description: <span id="covLow_long_desc">
        The parameter c1 for range +/-U(c1, c2) for covariance values, c2 >=
        c1</span></li>
            <li>Default Value: <span
                    id="covLow_default_value">0.0</span></li>
            <li>Lower Bound: <span
                    id="covLow_lower_bound">0.0</span></li>
            <li>Upper Bound: <span
                    id="covLow_upper_bound">1.7976931348623157E308</span></li>
            <li>Value
                Type: <span id="covLow_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description"
            id="covSymmetric">covSymmetric</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="covSymmetric_short_desc">Yes if negative covariance values should
        be considered</span></li>
            <li>Long Description: <span
                    id="covSymmetric_long_desc"> Usually covariance values are chosen
        from +/-U(a, b) for some a, b, no if from +U(a, b). </span></li>
            <li>Default Value: <span
                    id="covSymmetric_default_value">true</span></li>
            <li>Lower Bound:
                <span id="covSymmetric_lower_bound"></span></li>
            <li>Upper Bound:
                <span id="covSymmetric_upper_bound"></span></li>
            <li>Value Type:
                <span id="covSymmetric_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description"
            id="cutoffConstrainSearch">cutoffConstrainSearch</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="cutoffConstrainSearch_short_desc">Constraint-independence cutoff
        threshold</span></li>
            <li>Long Description: <span
                    id="cutoffConstrainSearch_long_desc">null</span></li>
            <li>Default
                Value: <span id="cutoffConstrainSearch_default_value">0.5</span></li>
            <li>Lower Bound: <span
                    id="cutoffConstrainSearch_lower_bound">0.0</span></li>
            <li>Upper
                Bound: <span id="cutoffConstrainSearch_upper_bound">1.0</span></li>
            <li>Value Type: <span
                    id="cutoffConstrainSearch_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description"
            id="cutoffDataSearch">cutoffDataSearch</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="cutoffDataSearch_short_desc">Independence cutoff
        threshold</span></li>
            <li>Long Description: <span
                    id="cutoffDataSearch_long_desc">null</span></li>
            <li>Default Value:
                <span id="cutoffDataSearch_default_value">0.5</span></li>
            <li>Lower
                Bound: <span id="cutoffDataSearch_lower_bound">0.0</span></li>
            <li>Upper Bound: <span
                    id="cutoffDataSearch_upper_bound">1.0</span></li>
            <li>Value Type:
                <span id="cutoffDataSearch_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description"
            id="cutoffIndTest">cutoffIndTest</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="cutoffIndTest_short_desc">Independence cutoff
        threshold</span></li>
            <li>Long Description: <span
                    id="cutoffIndTest_long_desc">null</span></li>
            <li>Default Value:
                <span id="cutoffIndTest_default_value">0.5</span></li>
            <li>Lower
                Bound: <span id="cutoffIndTest_lower_bound">0.0</span></li>
            <li>Upper
                Bound: <span id="cutoffIndTest_upper_bound">1.0</span></li>
            <li>Value
                Type: <span id="cutoffIndTest_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description" id="dataType">dataType</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="dataType_short_desc">"continuous" or "discrete"</span></li>
            <li>Long Description: <span id="dataType_long_desc"> For a mixed data
        type simulation, if this is set to “continuous” or “discrete”, all
        variables are taken to be of that sort. This is used as a
        double-check to make sure the percent discrete is set
        appropriately.</span></li>
            <li>Default Value: <span
                    id="dataType_default_value">categorical</span></li>
            <li>Lower Bound:
                <span id="dataType_lower_bound"></span></li>
            <li>Upper Bound: <span
                    id="dataType_upper_bound"></span></li>
            <li>Value Type: <span
                    id="dataType_value_type">String</span></li>
        </ul>

        <h3 class="parameter_description" id="depth">depth</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="depth_short_desc">Maximum size of conditioning set ('depth', unlimited =-1)
            </span></li>
            <li>Long Description: <span id="depth_long_desc">
        The depth of search for algorithms like the PC adjacency search,
        which is the maximum size of any conditioning set considered. In
        order to express that no limit should be imposed, use the value
        -1.</span></li>
            <li>Default Value: <span
                    id="depth_default_value">-1</span></li>
            <li>Lower Bound: <span
                    id="depth_lower_bound">-1</span></li>
            <li>Upper Bound: <span
                    id="depth_upper_bound">2147483647</span></li>
            <li>Value Type: <span
                    id="depth_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description"
            id="determinismThreshold">determinismThreshold</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="determinismThreshold_short_desc"> Threshold for judging a
        regression of a variable onto its parents to be deterministic (min =
        0.0)</span></li>
            <li>Long Description: <span
                    id="determinismThreshold_long_desc"> When regressing a child variable
        onto a set of parent variables, one way to test for determinism is to
        test how close to singular the data is; this gives a threshold for
        this. The default value is 0.1.</span></li>
            <li>Default Value: <span
                    id="determinismThreshold_default_value">0.1</span></li>
            <li>Lower
                Bound: <span id="determinismThreshold_lower_bound">0.0</span></li>
            <li>Upper Bound: <span
                    id="determinismThreshold_upper_bound">Infinity</span></li>
            <li>Value
                Type: <span id="determinismThreshold_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description"
            id="differentGraphs">differentGraphs</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="differentGraphs_short_desc">Yes if a different graph should be
        used for each run</span></li>
            <li>Long Description: <span
                    id="differentGraphs_long_desc"> If ‘Yes’ a new random graph is chosen
        for each run; if ‘No’, the same graph is always used.</span></li>
            <li>Default Value: <span
                    id="differentGraphs_default_value">false</span></li>
            <li>Lower Bound:
                <span id="differentGraphs_lower_bound"></span></li>
            <li>Upper Bound:
                <span id="differentGraphs_upper_bound"></span></li>
            <li>Value Type:
                <span id="differentGraphs_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description"
            id="mb">mb</h3>
        <ul class="mb_list">
            <li>Short Description: <span id="mb_short_desc">Find Markov blanket(s)</span></li>
            <li>Long Description: <span
                    id="mb_long_desc">Looks for the graph over the Markov blanket(s) and target(s) if true</span>
            </li>
            <li>Default Value: <span
                    id="mb_default_value">false</span></li>
            <li>Lower Bound: <span
                    id="mb_lower_bound"></span></li>
            <li>Upper Bound: <span
                    id="mb_upper_bound"></span></li>
            <li>Value Type: <span
                    id="mb_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description" id="discretize">discretize</h3>
        <ul class="parameter_description_list">
            <li>Short Description: <span
                    id="discretize_short_desc">Yes if continuous variables should be
        discretized when child is discrete</span></li>
            <li>Long Description:
                <span id="discretize_long_desc"> Yes if for the conditional Gaussian
        likelihood, when scoring X->D where X is continuous and D discrete,
        one should to simply discretize X for just those cases. If no, the
        integration will be exact.</span></li>
            <li>Default Value: <span
                    id="discretize_default_value">true</span></li>
            <li>Lower Bound: <span
                    id="discretize_lower_bound"></span></li>
            <li>Upper Bound: <span
                    id="discretize_upper_bound"></span></li>
            <li>Value Type: <span
                    id="discretize_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description"
            id="calculateEuclidean">calculateEuclidean</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="calculateEuclidean_short_desc">Yes if the Euclidean norm squared
        should be calculated (slow), No if not</span></li>
            <li>Long
                Description: <span id="calculateEuclidean_long_desc"> The generalized
        information criterion is defined with an information term that take a
        Euclidean norm squares; there can be calculated directly. </span></li>
            <li>Default Value: <span
                    id="calculateEuclidean_default_value">false</span></li>
            <li>Lower
                Bound: <span id="calculateEuclidean_lower_bound"></span></li>
            <li>Upper Bound: <span
                    id="calculateEuclidean_upper_bound"></span></li>
            <li>Value Type:
                <span id="calculateEuclidean_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description" id="takeLogs">takeLogs</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="takeLogs_short_desc">Yes logs should be taken, No if not</span>
            </li>
            <li>Long Description: <span id="takeLogs_long_desc"> The
        formula for the score allows a log to be taken optionally in the
        information term.</span></li>
            <li>Default Value: <span
                    id="takeLogs_default_value">true</span></li>
            <li>Lower Bound: <span
                    id="takeLogs_lower_bound"></span></li>
            <li>Upper Bound: <span
                    id="takeLogs_upper_bound"></span></li>
            <li>Value Type: <span
                    id="takeLogs_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description"
            id="doColliderOrientation">doColliderOrientation</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="doColliderOrientation_short_desc">Yes if unshielded collider
        orientation should be done</span></li>
            <li>Long Description: <span
                    id="doColliderOrientation_long_desc"> Please see the description of
        this algorithm in Thomas Richardson and Peter Spirtes in Chapter 7 of
        Computation, Causation, & Discovery by Glymour and Cooper eds.</span>
            </li>
            <li>Default Value: <span
                    id="doColliderOrientation_default_value">true</span></li>
            <li>Lower
                Bound: <span id="doColliderOrientation_lower_bound"></span></li>
            <li>Upper Bound: <span
                    id="doColliderOrientation_upper_bound"></span></li>
            <li>Value Type:
                <span id="doColliderOrientation_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description"
            id="doFgesFirst">doFgesFirst</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="doFgesFirst_short_desc"> Yes if FGES should be done as an initial
        step</span></li>
            <li>Long Description: <span
                    id="doFgesFirst_long_desc"> For BOSS, for some cases, doing FGES as
        an initial step can reduce the maximum permutation size needed to
        solve a problem. </span></li>
            <li>Default Value: <span
                    id="doFgesFirst_default_value">false</span></li>
            <li>Lower Bound:
                <span id="doFgesFirst_lower_bound"></span></li>
            <li>Upper Bound:
                <span id="doFgesFirst_upper_bound"></span></li>
            <li>Value Type: <span
                    id="doFgesFirst_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description"
            id="errorsNormal">errorsNormal</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="errorsNormal_short_desc">Yes if errors should be Normal; No if
        they should be abs(Normal) (i.e., non-Gaussian)</span></li>
            <li>Long
                Description: <span id="errorsNormal_long_desc"> A “quick and dirty”
        way to generate linear, non-Gaussian data is to set this parameter to
        “No”; then the errors will be sampled from a Beta
        distribution.</span></li>
            <li>Default Value: <span
                    id="errorsNormal_default_value">true</span></li>
            <li>Lower Bound:
                <span id="errorsNormal_lower_bound"></span></li>
            <li>Upper Bound:
                <span id="errorsNormal_upper_bound"></span></li>
            <li>Value Type:
                <span id="errorsNormal_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description"
            id="skewEdgeThreshold">skewEdgeThreshold</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="skewEdgeThreshold_short_desc">Threshold for including additional
        edges detectable by skewness</span></li>
            <li>Long Description: <span
                    id="skewEdgeThreshold_long_desc"> For FASK, this includes an
        adjacency X—Y in the model if |corr(X, Y | X > 0) – corr(X, Y | Y >
        0)| exceeds some threshold. The default for this threshold is
        0.3.</span></li>
            <li>Default Value: <span
                    id="skewEdgeThreshold_default_value">0.3</span></li>
            <li>Lower Bound:
                <span id="skewEdgeThreshold_lower_bound">0.0</span></li>
            <li>Upper
                Bound: <span id="skewEdgeThreshold_upper_bound">Infinity</span></li>
            <li>Value Type: <span
                    id="skewEdgeThreshold_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description"
            id="twoCycleScreeningThreshold">twoCycleScreeningThreshold</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="twoCycleScreeningThreshold_short_desc"> Upper bound for
        |left-right| to count as 2-cycle. (Set to zero to turn off
        pre-screening.)</span></li>
            <li>Long Description: <span
                    id="twoCycleScreeningThreshold_long_desc"> 2-cycles are screened by
        looking to see if the left-right rule returns a difference smaller
        than this threshold. To turn off the screening, set this to
        zero.</span></li>
            <li>Default Value: <span
                    id="twoCycleScreeningThreshold_default_value">0.0</span></li>
            <li>Lower Bound: <span
                    id="twoCycleScreeningThreshold_lower_bound">0.0</span></li>
            <li>Upper
                Bound: <span
                        id="twoCycleScreeningThreshold_upper_bound">Infinity</span></li>
            <li>Value Type: <span
                    id="twoCycleScreeningThreshold_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description"
            id="orientationAlpha">orientationAlpha</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="orientationAlpha_short_desc"> Alpha threshold used for
        orientation (where necessary). ('0' turns this off.)</span></li>
            <li>Long Description: <span id="orientationAlpha_long_desc">Used for
        orienting 2-cycles and testing for zero edges.</span></li>
            <li>Default Value: <span
                    id="orientationAlpha_default_value">0.0</span></li>
            <li>Lower Bound:
                <span id="orientationAlpha_lower_bound">0.0</span></li>
            <li>Upper
                Bound: <span id="orientationAlpha_upper_bound">1.0</span></li>
            <li>Value Type: <span
                    id="orientationAlpha_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description" id="faskDelta">faskDelta</h3>
        <ul class="parameter_description_list">
            <li>Short Description: <span
                    id="faskDelta_short_desc"> For FASK v1 and v2, the bias for orienting
        with negative coefficients ('0' means no bias.)</span></li>
            <li>Long
                Description: <span id="faskDelta_long_desc">The bias procedure for v1
        is given in the published description.</span></li>
            <li>Default
                Value: <span id="faskDelta_default_value">0.0</span></li>
            <li>Lower
                Bound: <span id="faskDelta_lower_bound">-Infinity</span></li>
            <li>Upper Bound: <span
                    id="faskDelta_upper_bound">Infinity</span></li>
            <li>Value Type: <span
                    id="faskDelta_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description"
            id="faskLeftRightRule">faskLeftRightRule</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="faskLeftRightRule_short_desc">The left right rule: 1 = FASK v1, 2
        = FASK v2, 3 = RSkew, 4 = Skew, 5 = Tanh</span></li>
            <li>Long
                Description: <span id="faskLeftRightRule_long_desc"> The FASK left
        right rule v2 is default, but two other (related) left-right rules
        are given for relation to the literature, and the v1 FASK rule is
        included for backward compatibility.</span></li>
            <li>Default Value:
                <span id="faskLeftRightRule_default_value">2</span></li>
            <li>Lower
                Bound: <span id="faskLeftRightRule_lower_bound">1</span></li>
            <li>Upper Bound: <span
                    id="faskLeftRightRule_upper_bound">5</span></li>
            <li>Value Type:
                <span id="faskLeftRightRule_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description"
            id="faskAssumeLinearity">faskAssumeLinearity</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="faskAssumeLinearity_short_desc">Linearity assumed</span></li>
            <li>Long Description: <span id="faskAssumeLinearity_long_desc"> True
        if a linear, non-Gaussian, additive model is assume; false if a
        nonlinear, non-Gaussian, additive model is assumed.</span></li>
            <li>Default Value: <span
                    id="faskAssumeLinearity_default_value">true</span></li>
            <li>Lower
                Bound: <span id="faskAssumeLinearity_lower_bound"></span></li>
            <li>Upper Bound: <span
                    id="faskAssumeLinearity_upper_bound"></span></li>
            <li>Value Type:
                <span id="faskAssumeLinearity_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description"
            id="faskNonempirical">faskNonempirical</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="faskNonempirical_short_desc">Variables should be assumed to have
        positive skewness</span></li>
            <li>Long Description: <span
                    id="faskNonempirical_long_desc"> If false (default), each variable is
        multiplied by the sign of its skewness in the left-right rule.</span>
            </li>
            <li>Default Value: <span
                    id="faskNonempirical_default_value">false</span></li>
            <li>Lower
                Bound: <span id="faskNonempirical_lower_bound"></span></li>
            <li>Upper
                Bound: <span id="faskNonempirical_upper_bound"></span></li>
            <li>Value
                Type: <span id="faskNonempirical_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description"
            id="acceptanceProportion">acceptanceProportion</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="acceptanceProportion_short_desc">Acceptance Proportion</span>
            </li>
            <li>Long Description: <span
                    id="acceptanceProportion_long_desc"> An edge occurring in this
        proportion of individual FASK graphs will appear in the final
        graph.</span></li>
            <li>Default Value: <span
                    id="acceptanceProportion_default_value">0.5</span></li>
            ,.
            <li>Lower
                Bound: <span id="acceptanceProportion_lower_bound">0.0</span></li>
            <li>Upper Bound: <span
                    id="acceptanceProportion_upper_bound">1.0</span></li>
            <li>Value Type:
                <span id="acceptanceProportion_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description"
            id="faskAdjacencyMethod">faskAdjacencyMethod</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="faskAdjacencyMethod_short_desc">Non-skewness Adjacencies: 1 = FAS
        Stable, 2 = FGES, 3 = External Graph, 4 = None</span></li>
            <li>Long
                Description: <span id="faskAdjacencyMethod_long_desc"> This is  the
        method FASK will use to find non-skewness adjacencies. For External
        graph, an external graph must be supplied.</span></li>
            <li>Default
                Value: <span id="faskAdjacencyMethod_default_value">1</span></li>
            <li>Lower Bound: <span
                    id="faskAdjacencyMethod_lower_bound">1</span></li>
            <li>Upper Bound:
                <span id="faskAdjacencyMethod_upper_bound">4</span></li>
            <li>Value
                Type: <span id="faskAdjacencyMethod_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description"
            id="faithfulnessAssumed">faithfulnessAssumed</h3>
        <ul class="parameter_description_list">
            <li>Short Description: <span
                    id="faithfulnessAssumed_short_desc">Yes if (one edge) faithfulness
        should be assumed</span></li>
            <li>Long Description: <span
                    id="faithfulnessAssumed_long_desc"> Assumes that if X _||_ Y, by an
        independence test, then X _||_ Y | Z for nonempty Z.</span></li>
            <li>Default Value: <span
                    id="faithfulnessAssumed_default_value">false</span></li>
            <li>Lower
                Bound: <span id="faithfulnessAssumed_lower_bound"></span></li>
            <li>Upper Bound: <span
                    id="faithfulnessAssumed_upper_bound"></span></li>
            <li>Value Type:
                <span id="faithfulnessAssumed_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description"
            id="pcHeuristic">pcHeuristic</h3>
        <ul class="parameter_description_list">
            <li>Short Description: <span id="pcHeuristic_short_desc">
                Heuristics to stabilize skeleton: 0 = None, 1 = Heuristic 1, 2 = Heuristic 2, 3 = Heuristic 3
            </span></li>
            <li>Long Description: <span
                    id="pcHeuristic_long_desc">
                NONE = no heuristic, PC-1 = sort nodes alphabetically;
                PC-1 = sort edges by p-value; PC-3 = additionally sort edges in reverse order
                using p-values of associated independence facts. See CPS.
            </span></li>
            <li>Default Value: <span
                    id="pcHeuristic_default_value">0</span></li>
            <li>Lower Bound: <span
                    id="pcHeuristic_lower_bound">0</span></li>
            <li>Upper Bound: <span
                    id="pcHeuristic_upper_bound">3</span></li>
            <li>Value Type: <span
                    id="pcHeuristic_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description" id="fasRule">fasRule</h3>
        <ul class="parameter_description_list">
            <li>Short Description: <span
                    id="fasRule_short_desc">Adjacency search: 1 = PC, 2 = PC-Stable, 3 =f
        Concurrent PC-Stable</span></li>
            <li>Long Description: <span
                    id="fasRule_long_desc"> For variants of PC, one may select either to
        use the usual PC adjacency search, or the procedure from the
        PC-Stable algorithm (Diego and Maathuis), or the latter using a
        concurrent algorithm.</span></li>
            <li>Default Value: <span
                    id="fasRule_default_value">1</span></li>
            <li>Lower Bound: <span
                    id="fasRule_lower_bound">1</span></li>
            <li>Upper Bound: <span
                    id="fasRule_upper_bound">3</span></li>
            <li>Value Type: <span
                    id="fasRule_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description" id="fastIcaA">fastIcaA</h3>
        <ul class="parameter_description_list">
            <li>Short Description: <span
                    id="fastIcaA_short_desc">Fast ICA 'a' parameter. </span></li>
            <li>Long Description: <span id="fastIcaA_long_desc"> This is the 'a'
        parameter of Fast ICA. (See Hyvarinen, A. (2001); it ranges between 1
        and 2; we use a default of 1.1.</span></li>
            <li>Default Value: <span
                    id="fastIcaA_default_value">1.1</span></li>
            <li>Lower Bound: <span
                    id="fastIcaA_lower_bound">1.0</span></li>
            <li>Upper Bound: <span
                    id="fastIcaA_upper_bound">2.0</span></li>
            <li>Value Type: <span
                    id="fastIcaA_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description"
            id="fastIcaMaxIter">fastIcaMaxIter</h3>
        <ul class="parameter_description_list">
            <li>Short Description: <span
                    id="fastIcaMaxIter_short_desc">The maximum number of optimization
        iterations. </span></li>
            <li>Long Description: <span
                    id="fastIcaMaxIter_long_desc"> This is the maximum number if
        iterations of the optimization procedure of ICA. (See Hyvarinen, A.
        (2001). It's an integer greater than 0; we use a default of
        2000.</span></li>
            <li>Default Value: <span
                    id="fastIcaMaxIter_default_value">2000</span></li>
            <li>Lower Bound:
                <span id="fastIcaMaxIter_lower_bound">1</span></li>
            <li>Upper Bound:
                <span id="fastIcaMaxIter_upper_bound">500000</span></li>
            <li>Value
                Type: <span id="fastIcaMaxIter_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description"
            id="fastIcaTolerance">fastIcaTolerance</h3>
        <ul class="parameter_description_list">
            <li>Short Description: <span
                    id="fastIcaTolerance_short_desc">Fast ICA tolerance parameter.
        </span></li>
            <li>Long Description: <span
                    id="fastIcaTolerance_long_desc"> This is the tolerance parameter of
        Fast ICA. (See Hyvarinen, A. (2001); we use a default of 1e-6.</span>
            </li>
            <li>Default Value: <span
                    id="fastIcaTolerance_default_value">1e-6</span></li>
            <li>Lower Bound:
                <span id="fastIcaTolerance_lower_bound">0.0</span></li>
            <li>Upper
                Bound: <span id="fastIcaTolerance_upper_bound">1000.0</span></li>
            <li>Value Type: <span
                    id="fastIcaTolerance_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description"
            id="thresholdBHat">thresholdBHat</h3>
        <ul class="parameter_description_list">
            <li>Short Description: <span
                    id="thresholdBHat_short_desc">Threshold on the B Hat matrix.
        </span></li>
            <li>Long Description: <span
                    id="thresholdBHat_long_desc">The estimated B matrix
                    is thresholded by setting small entries less than this threshold
                    to zero.</span>
            </li>
            <li>Default Value: <span
                    id="thresholdBHat_default_value">0.1</span></li>
            <li>Lower Bound:
                <span id="thresholdBHat_lower_bound">0.0</span></li>
            <li>Upper
                Bound: <span id="thresholdBHat_upper_bound">Infinity</span></li>
            <li>Value Type: <span
                    id="thresholdBHat_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description"
            id="guaranteeAcyclic">guaranteeAcyclic</h3>
        <ul class="parameter_description_list">
            <li>Short Description: <span
                    id="guaranteeAcyclic_short_desc">True if the output should be
                    guaranteed to be acyclic
        </span></li>
            <li>Long Description: <span
                    id="guaranteeAcyclic_long_desc">The estimated B matrix
                    is further thresholded by setting small coefficients to zero
                    until an acyclic model is produced.</span>
            </li>
            <li>Default Value: <span
                    id="guaranteeAcyclic_default_value">true</span></li>
            <li>Lower Bound:
                <span id="guaranteeAcyclic_lower_bound"></span></li>
            <li>Upper
                Bound: <span id="guaranteeAcyclic_upper_bound"></span></li>
            <li>Value Type: <span
                    id="guaranteeAcyclic_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description"
            id="thresholdW">thresholdW</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="thresholdW_short_desc">Threshold on the W matrix.
        </span></li>
            <li>Long Description: <span
                    id="thresholdW_long_desc">The estimated W matrix
                    is thresholded by setting small entries less than this threshold
                    to zero.
                    </span>
            </li>
            <li>Default Value: <span
                    id="thresholdW_default_value">0.1</span></li>
            <li>Lower Bound:
                <span id="thresholdW_lower_bound">0.0</span></li>
            <li>Upper
                Bound: <span id="thresholdW_upper_bound">Infinity</span></li>
            <li>Value Type: <span
                    id="thresholdW_value_type">Double</span></li>
        </ul>


        <h3 class="parameter_description"
            id="fisherEpsilon">fisherEpsilon</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="fisherEpsilon_short_desc">Epsilon where |xi.t - xi.t-1| <
        epsilon, criterion for convergence</span></li>
            <li>Long Description:
                <span id="fisherEpsilon_long_desc"> This is a parameter for the
        linear Fisher option. The idea of Fisher model (for the linear case)
        is to shock the system every so often and let it converge by applying
        the rules of transformation (that is, the linear model) repeatedly
        until convergence.</span></li>
            <li>Default Value: <span
                    id="fisherEpsilon_default_value">0.001</span></li>
            <li>Lower Bound:
                <span id="fisherEpsilon_lower_bound">4.9E-324</span></li>
            <li>Upper
                Bound: <span
                        id="fisherEpsilon_upper_bound">1.7976931348623157E308</span></li>
            <li>Value Type: <span
                    id="fisherEpsilon_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description"
            id="generalSemErrorTemplate">generalSemErrorTemplate</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="generalSemErrorTemplate_short_desc">General function for error
        terms</span></li>
            <li>Long Description: <span
                    id="generalSemErrorTemplate_long_desc"> This template specifies how
        distributions for error terms are to be generated. For help in
        constructing such templates, see the Generalized SEM PM model.</span>
            </li>
            <li>Default Value: <span
                    id="generalSemErrorTemplate_default_value">Beta(2, 5)</span></li>
            <li>Lower Bound: <span
                    id="generalSemErrorTemplate_lower_bound"></span></li>
            <li>Upper
                Bound: <span id="generalSemErrorTemplate_upper_bound"></span></li>
            <li>Value Type: <span
                    id="generalSemErrorTemplate_value_type">String</span></li>
        </ul>

        <h3 class="parameter_description"
            id="generalSemFunctionTemplateLatent">
            generalSemFunctionTemplateLatent</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="generalSemFunctionTemplateLatent_short_desc">General function
        template for latent variables</span></li>
            <li>Long Description:
                <span id="generalSemFunctionTemplateLatent_long_desc"> This template
        specifies how equations for latent variables are to be generated. For
        help in constructing such templates, see the Generalized SEM PM
        model.</span>
            </li>
            <li>Default Value:

                <span
                        id="generalSemFunctionTemplateLatent_default_value">TSUM(NEW(B)*$)/>
        </span></li>
            <li>Lower Bound: <span
                    id="generalSemFunctionTemplateLatent_lower_bound"></span></li>
            <li>Upper Bound: <span
                    id="generalSemFunctionTemplateLatent_upper_bound"></span></li>
            <li>Value Type: <span
                    id="generalSemFunctionTemplateLatent_value_type">String</span></li>
        </ul>

        <h3 class="parameter_description"
            id="generalSemFunctionTemplateMeasured">
            generalSemFunctionTemplateMeasured</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="generalSemFunctionTemplateMeasured_short_desc">General function
        template for measured variables</span></li>
            <li>Long Description:
                <span id="generalSemFunctionTemplateMeasured_long_desc"> This
        template specifies how equations for measured variables are to be
        generated. For help in constructing such templates, see the
        Generalized SEM PM model.</span></li>
            <li>Default Value: <span
                    id="generalSemFunctionTemplateMeasured_default_value">TSUM(NEW(B)*$>
            </span></li>
            <li>Lower Bound: <span
                    id="generalSemFunctionTemplateMeasured_lower_bound"></span></li>
            <li>Upper Bound: <span
                    id="generalSemFunctionTemplateMeasured_upper_bound"></span></li>
            <li>Value Type: <span
                    id="generalSemFunctionTemplateMeasured_value_type">String</span></li>
        </ul>

        <h3 class="parameter_description"
            id="generalSemParameterTemplate">generalSemParameterTemplate</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="generalSemParameterTemplate_short_desc">General function for
        parameters</span></li>
            <li>Long Description: <span
                    id="generalSemParameterTemplate_long_desc"> This template specifies
        how distributions for parameter terms are to be generated. For help
        in constructing such templates, see the Generalized SEM PM
        model.</span></li>
            <li>Default Value: <span
                    id="generalSemParameterTemplate_default_value">Split(-1.0, -0.5, 0.5,
        1.0)</span></li>
            <li>Lower Bound: <span
                    id="generalSemParameterTemplate_lower_bound"></span></li>
            <li>Upper
                Bound: <span
                        id="generalSemParameterTemplate_upper_bound"></span></li>
            <li>Value
                Type: <span
                        id="generalSemParameterTemplate_value_type">String</span></li>
        </ul>

        <h3 class="parameter_description" id="imagesMetaAlg">imagesMetaAlg</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="imagesMetaAlg_short_desc">IMaGES "meta" algorithm. 1 = FGES, 2 = BOSS-Tuck</span></li>
            <li>Long
                Description: <span id="imagesMetaAlg_long_desc"> Sets the meta algorithm to be optimized using the IMaGES (average BIC) score.</span>
            </li>
            <li>Default Value:
                <span id="imagesMetaAlg_default_value">1</span></li>
            <li>Lower Bound: <span
                    id="imagesMetaAlg_lower_bound">1</span></li>
            <li>Upper Bound: <span
                    id="imagesMetaAlg_upper_bound">5</span></li>
            <li>Value Type: <span
                    id="imagesMetaAlg_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description" id="ia">ia</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="ia_short_desc">IA parameter (GLASSO)</span></li>
            <li>Long
                Description: <span id="ia_long_desc"> Sets the maximum number of
        iterations of the optimization loop.</span></li>
            <li>Default Value:
                <span id="ia_default_value">true</span></li>
            <li>Lower Bound: <span
                    id="ia_lower_bound"></span></li>
            <li>Upper Bound: <span
                    id="ia_upper_bound"></span></li>
            <li>Value Type: <span
                    id="ia_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description"
            id="includeNegativeCoefs">includeNegativeCoefs</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="includeNegativeCoefs_short_desc">Yes if negative coefficients
        should be included in the model</span></li>
            <li>Long Description:
                <span id="includeNegativeCoefs_long_desc"> One may include positive
        coefficients, negative coefficients, or both, in the model. To
        include negative coefficients, set this parameter to “Yes”.</span>
            </li>
            <li>Default Value: <span
                    id="includeNegativeCoefs_default_value">true</span></li>
            <li>Lower
                Bound: <span id="includeNegativeCoefs_lower_bound"></span></li>
            <li>Upper Bound: <span
                    id="includeNegativeCoefs_upper_bound"></span></li>
            <li>Value Type:
                <span id="includeNegativeCoefs_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description"
            id="includeNegativeSkewsForBeta">includeNegativeSkewsForBeta</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="includeNegativeSkewsForBeta_short_desc"> Yes if negative skew
        values should be included in the model, if Beta errors are
        chosen</span></li>
            <li>Long Description: <span
                    id="includeNegativeSkewsForBeta_long_desc"> Yes if negative skew
        values should be included in the model, if Beta errors are
        chosen.</span></li>
            <li>Default Value: <span
                    id="includeNegativeSkewsForBeta_default_value">true</span></li>
            <li>Lower Bound: <span
                    id="includeNegativeSkewsForBeta_lower_bound"></span></li>
            <li>Upper
                Bound: <span
                        id="includeNegativeSkewsForBeta_upper_bound"></span></li>
            <li>Value
                Type: <span
                        id="includeNegativeSkewsForBeta_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description"
            id="includePositiveCoefs">includePositiveCoefs</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="includePositiveCoefs_short_desc"> Yes if positive coefficients
        should be included in the model</span></li>
            <li>Long Description:
                <span id="includePositiveCoefs_long_desc">Yes if We may include
        positive coefficients, should be included in the model, no if
        not.</span></li>
            <li>Default Value: <span
                    id="includePositiveCoefs_default_value">true</span></li>
            <li>Lower
                Bound: <span id="includePositiveCoefs_lower_bound"></span></li>
            <li>Upper Bound: <span
                    id="includePositiveCoefs_upper_bound"></span></li>
            <li>Value Type:
                <span id="includePositiveCoefs_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description"
            id="includePositiveSkewsForBeta">includePositiveSkewsForBeta</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="includePositiveSkewsForBeta_short_desc"> Yes if positive skew
        values should be included in the model, if Beta errors are
        chosen</span></li>
            <li>Long Description: <span
                    id="includePositiveSkewsForBeta_long_desc"> Yes if positive skew
        values should be included in the model, if Beta errors are
        chosen.</span></li>
            <li>Default Value: <span
                    id="includePositiveSkewsForBeta_default_value">true</span></li>
            <li>Lower Bound: <span
                    id="includePositiveSkewsForBeta_lower_bound"></span></li>
            <li>Upper
                Bound: <span
                        id="includePositiveSkewsForBeta_upper_bound"></span></li>
            <li>Value
                Type: <span
                        id="includePositiveSkewsForBeta_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description"
            id="usePseudoinverse">usePseudoinverse</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="usePseudoinverse_short_desc">
                    Yes if the pseudoinverse should be used to avoid exceptions
        </span></li>
            <li>Long Description: <span
                    id="usePseudoinverse_long_desc">
                     Yes if the pseudoinverse should be used in place of the regular
                     inverse in calculating residual variances to avoid singularity
                     exceptions
        </span></li>
            <li>Default Value: <span
                    id="usePseudoinverse_default_value">false</span></li>
            <li>Lower Bound: <span
                    id="usePseudoinverse_lower_bound"></span></li>
            <li>Upper
                Bound: <span
                        id="usePseudoinverse_upper_bound"></span></li>
            <li>Value
                Type: <span
                        id="usePseudoinverse_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description"
            id="intervalBetweenRecordings">intervalBetweenRecordings</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="intervalBetweenRecordings_short_desc"> Interval between data
        recordings for the linear Fisher model (min = 1)</span></li>
            <li>Long Description: <span
                    id="intervalBetweenRecordings_long_desc"></span></li>
            <li>Default
                Value: <span
                        id="intervalBetweenRecordings_default_value">10</span></li>
            <li>Lower
                Bound: <span id="intervalBetweenRecordings_lower_bound">1</span></li>
            <li>Upper Bound: <span
                    id="intervalBetweenRecordings_upper_bound">2147483647</span></li>
            <li>Value Type: <span
                    id="intervalBetweenRecordings_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description"
            id="intervalBetweenShocks">intervalBetweenShocks</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="intervalBetweenShocks_short_desc"> Interval between shocks (R. A.
        Fisher simulation model) (min = 1)</span></li>
            <li>Long Description:
                <span id="intervalBetweenShocks_long_desc"> This is a parameter for
        the linear Fisher option. This sets the number of step between
        shocks.</span></li>
            <li>Default Value: <span
                    id="intervalBetweenShocks_default_value">10</span></li>
            <li>Lower
                Bound: <span id="intervalBetweenShocks_lower_bound">1</span></li>
            <li>Upper Bound: <span
                    id="intervalBetweenShocks_upper_bound">2147483647</span></li>
            <li>Value Type: <span
                    id="intervalBetweenShocks_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description" id="ipen">ipen</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="ipen_short_desc">IPEN parameter (GLASSO)</span></li>
            <li>Long
                Description: <span id="ipen_long_desc"> This sets the maximum number
        of iterations of the optimization loop.</span></li>
            <li>Default
                Value: <span id="ipen_default_value">false</span></li>
            <li>Lower
                Bound: <span id="ipen_lower_bound"></span></li>
            <li>Upper Bound:
                <span id="ipen_upper_bound"></span></li>
            <li>Value Type: <span
                    id="ipen_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description" id="is">is</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="is_short_desc">IS parameter (GLASSO)</span></li>
            <li>Long
                Description: <span id="is_long_desc"> Sets the maximum number of
        iterations of the optimization loop.</span></li>
            <li>Default Value:
                <span id="is_default_value">false</span></li>
            <li>Lower Bound: <span
                    id="is_lower_bound"></span></li>
            <li>Upper Bound: <span
                    id="is_upper_bound"></span></li>
            <li>Value Type: <span
                    id="is_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description" id="itr">itr</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="itr_short_desc">ITR parameter (GLASSO)</span></li>
            <li>Long
                Description: <span id="itr_long_desc"> Sets the maximum number of
        iterations of the optimization loop.</span></li>
            <li>Default Value:
                <span id="itr_default_value">false</span></li>
            <li>Lower Bound: <span
                    id="itr_lower_bound"></span></li>
            <li>Upper Bound: <span
                    id="itr_upper_bound"></span></li>
            <li>Value Type: <span
                    id="itr_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description" id="kciAlpha">kciAlpha</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="kciAlpha_short_desc">Cutoff for p values (alpha) (min =
        0.0)</span></li>
            <li>Long Description: <span
                    id="kciAlpha_long_desc">Alpha level (0 to 1)</span></li>
            <li>Default
                Value: <span id="kciAlpha_default_value">0.05</span></li>
            <li>Lower
                Bound: <span id="kciAlpha_lower_bound">0.0</span></li>
            <li>Upper
                Bound: <span id="kciAlpha_upper_bound">1.0</span></li>
            <li>Value
                Type: <span id="kciAlpha_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description" id="kciCutoff">kciCutoff</h3>
        <ul class="parameter_description_list">
            <li>Short Description: <span
                    id="kciCutoff_short_desc">Cutoff</span></li>
            <li>Long Description:
                <span id="kciCutoff_long_desc">Cutoff for p-values.</span></li>
            <li>Default Value: <span id="kciCutoff_default_value">6</span></li>
            <li>Lower Bound: <span id="kciCutoff_lower_bound">1</span></li>
            <li>Upper Bound: <span
                    id="kciCutoff_upper_bound">2147483647</span></li>
            <li>Value Type:
                <span id="kciCutoff_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description" id="kciEpsilon">kciEpsilon</h3>
        <ul class="parameter_description_list">
            <li>Short Description: <span
                    id="kciEpsilon_short_desc">Epsilon for Proposition 5, a small
        positive number</span></li>
            <li>Long Description: <span
                    id="kciEpsilon_long_desc"> See Zhang, K., Peters, J., Janzing, D., &
        Schölkopf, B. (2012). Kernel-based conditional independence test and
        application in causal discovery.. This parameter is the  epsilon for
        Proposition 5, a small positive number.</span></li>
            <li>Default
                Value: <span id="kciEpsilon_default_value">0.001</span></li>
            <li>Lower Bound: <span id="kciEpsilon_lower_bound">0.0</span></li>
            <li>Upper Bound: <span
                    id="kciEpsilon_upper_bound">Infinity</span></li>
            <li>Value Type:
                <span id="kciEpsilon_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description"
            id="kciNumBootstraps">kciNumBootstraps</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="kciNumBootstraps_short_desc">Number of bootstraps for Theorems 4
        and Proposition 5 for KCI</span></li>
            <li>Long Description: <span
                    id="kciNumBootstraps_long_desc"> This parameter is the number of
        bootstraps for Theorems 4 from Zhang, K., Peters, J., Janzing, D., &
        Schölkopf, B. (2012) and Proposition 5, a positive integer.</span>
            </li>
            <li>Default Value: <span
                    id="kciNumBootstraps_default_value">5000</span></li>
            <li>Lower Bound:
                <span id="kciNumBootstraps_lower_bound">1</span></li>
            <li>Upper
                Bound: <span id="kciNumBootstraps_upper_bound">2147483647</span></li>
            <li>Value Type: <span
                    id="kciNumBootstraps_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description"
            id="kciUseApproximation">kciUseApproximation</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="kciUseApproximation_short_desc">Use the approximate Gamma
        approximation algorithm</span></li>
            <li>Long Description: <span
                    id="kciUseApproximation_long_desc"> Referring to Zhang, K., Peters, J.,
        Janzing, D., & Schölkopf, B. (2012), if this parameter is set to
        ‘Yes’, the Gamma approximation algorithm is used; if no, the exact
        procedure is used.</span></li>
            <li>Default Value: <span
                    id="kciUseApproximation_default_value">true</span></li>
            <li>Lower
                Bound: <span id="kciUseApproximation_lower_bound"></span></li>
            <li>Upper Bound: <span
                    id="kciUseApproximation_upper_bound"></span></li>
            <li>Value Type: <span
                    id="kciUseApproximation_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description"
            id="kernelMultiplier">kernelMultiplier</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="kernelMultiplier_short_desc">Bowman and Azzalini (1997) default
        kernel bandwidths should be multiplied by...</span></li>
            <li>Long
                Description: <span id="kernelMultiplier_long_desc"> For the
        conditional correlation algorithm. Bowman, A. W., & Azzalini, A.
        (1997), give a formula for default optimal kernel widths. We allow
        these defaults to be multiplied by this factor, to capture more or
        less than this optimal signal.</span></li>
            <li>Default Value: <span
                    id="kernelMultiplier_default_value">1.0</span></li>
            <li>Lower Bound:
                <span id="kernelMultiplier_lower_bound">4.9E-324</span></li>
            <li>Upper Bound: <span
                    id="kernelMultiplier_upper_bound">Infinity</span></li>
            <li>Value
                Type: <span id="kernelMultiplier_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description"
            id="kernelRegressionSampleSize">kernelRegressionSampleSize</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="kernelRegressionSampleSize_short_desc">Minimum sample size to use
        per conditioning for kernel regression</span></li>
            <li>Long
                Description: <span id="kernelRegressionSampleSize_long_desc"> The
        smallest set of nearest data points on which to allow a judgment to
        be based for a nonlinear regression.</span></li>
            <li>Default Value:
                <span id="kernelRegressionSampleSize_default_value">100</span></li>
            <li>Lower Bound: <span
                    id="kernelRegressionSampleSize_lower_bound">-2147483648</span></li>
            <li>Upper Bound: <span
                    id="kernelRegressionSampleSize_upper_bound">2147483647</span></li>
            <li>Value Type: <span
                    id="kernelRegressionSampleSize_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description"
            id="minCountPerCell">minCountPerCell</h3>
        <ul
                class="minCountPerCell_list">
            <li>Short Description: <span id="minCountPerCell_short_desc">
            		Minimum expected count per cell for nonempty Chi-Square tables.
            </span></li>
            <li>Long Description: <span id="minCountPerCell_long_desc">
                   The minimum count per cell in any nonempty conditional Chi-Square table
                   This is real-valued and must be > 0.0; the default is 1.0. No matter
                    what this value is, if a row is empty, it will be removed from the
                    table.</span></li>
            <li>Default Value: <span
                    id="minCountPerCell_default_value">1.0</span></li>
            <li>Lower
                Bound: <span id="minCountPerCell_lower_bound">0.0</span></li>
            <li>Upper Bound: <span
                    id="minCountPerCell_upper_bound">Infinity</span></li>
            <li>Value Type:
                <span id="minCountPerCell_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description" id="kernelType">kernelType</h3>
        <ul class="parameter_description_list">
            <li>Short Description: <span
                    id="kernelType_short_desc">Kernel type (1 = Gaussian, 2 =
        Epinechnikov)</span></li>
            <li>Long Description: <span
                    id="kernelType_long_desc"> For CCI, this determines which kernel type
        will be used (1 = Gaussian, 2 = Epinechnikov).</span></li>
            <li>Default Value: <span id="kernelType_default_value">2</span></li>
            <li>Lower Bound: <span id="kernelType_lower_bound">1</span></li>
            <li>Upper Bound: <span id="kernelType_upper_bound">2</span></li>
            <li>Value Type: <span id="kernelType_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description"
            id="kernelWidth">kernelWidth</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="kernelWidth_short_desc">Kernel width</span></li>
            <li>Long
                Description: <span id="kernelWidth_long_desc"> A larger kernel width
        means that more information will be taken into account but possibly
        less focused information.</span></li>
            <li>Default Value: <span
                    id="kernelWidth_default_value">1.0</span></li>
            <li>Lower Bound: <span
                    id="kernelWidth_lower_bound">4.9E-324</span></li>
            <li>Upper Bound:
                <span id="kernelWidth_upper_bound">Infinity</span></li>
            <li>Value
                Type: <span id="kernelWidth_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description"
            id="latentMeasuredImpureParents">latentMeasuredImpureParents</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="latentMeasuredImpureParents_short_desc">Number of Latent -->
        Measured impure edges</span></li>
            <li>Long Description: <span
                    id="latentMeasuredImpureParents_long_desc"> It is possible for
        structural nodes to have as children measured variables that are
        children of other structural nodes. These edges in the graph will be
        considered impure.</span></li>
            <li>Default Value: <span
                    id="latentMeasuredImpureParents_default_value">0</span></li>
            <li>Lower Bound: <span
                    id="latentMeasuredImpureParents_lower_bound">-2147483648</span></li>
            <li>Upper Bound: <span
                    id="latentMeasuredImpureParents_upper_bound">2147483647</span></li>
            <li>Value Type: <span
                    id="latentMeasuredImpureParents_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description" id="lowerBound">lowerBound</h3>
        <ul class="parameter_description_list">
            <li>Short Description: <span
                    id="lowerBound_short_desc">Lower bound cutoff threshold</span></li>
            <li>Long Description: <span
                    id="lowerBound_long_desc">null</span></li>
            <li>Default Value: <span
                    id="lowerBound_default_value">0.3</span></li>
            <li>Lower Bound: <span
                    id="lowerBound_lower_bound">0.0</span></li>
            <li>Upper Bound: <span
                    id="lowerBound_upper_bound">1.0</span></li>
            <li>Value Type: <span
                    id="lowerBound_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description"
            id="maxCategories">maxCategories</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="maxCategories_short_desc">Maximum number of categories (min =
        2)</span></li>
            <li>Long Description: <span
                    id="maxCategories_long_desc"> The maximum number of categories to be
        used for randomly generated discrete variables. The default is 2.
        This needs to be greater or equal to than the minimum number of
        categories.</span></li>
            <li>Default Value: <span
                    id="maxCategories_default_value">3</span></li>
            <li>Lower Bound: <span
                    id="maxCategories_lower_bound">2</span></li>
            <li>Upper Bound: <span
                    id="maxCategories_upper_bound">2147483647</span></li>
            <li>Value Type:
                <span id="maxCategories_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description"
            id="maxCorrelation">maxCorrelation</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="maxCorrelation_short_desc">Maximum absolute correlation
        considered</span></li>
            <li>Long Description: <span
                    id="maxCorrelation_long_desc">For the Nandy rule, the absolute max
        correlation r. For the standard BIC or high-dimensional rule, the
        maximum absolute residual correlation.</span></li>
            <li>Default Value:
                <span id="maxCorrelation_default_value">1.0</span></li>
            <li>Lower
                Bound: <span id="maxCorrelation_lower_bound">0.0</span></li>
            <li>Upper Bound: <span
                    id="maxCorrelation_upper_bound">1.0</span></li>
            <li>Value Type: <span
                    id="maxCorrelation_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description" id="maxDegree">maxDegree</h3>
        <ul class="parameter_description_list">
            <li>Short Description: <span
                    id="maxDegree_short_desc">The maximum degree of the graph (min =
        -1)</span></li>
            <li>Long Description: <span
                    id="maxDegree_long_desc"> An upper bound on the maximum degree of any
        node in the graph. If no limit is to be placed on the maximum degree,
        use the value -1.</span></li>
            <li>Default Value: <span
                    id="maxDegree_default_value">1000</span></li>
            <li>Lower Bound: <span
                    id="maxDegree_lower_bound">1</span></li>
            <li>Upper Bound: <span
                    id="maxDegree_upper_bound">2147483647</span></li>
            <li>Value Type:
                <span id="maxDegree_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description"
            id="maxDistinctValuesDiscrete">maxDistinctValuesDiscrete</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="maxDistinctValuesDiscrete_short_desc"> The maximum number of
        distinct values in a column for discrete variables (min = 0)</span>
            </li>
            <li>Long Description: <span
                    id="maxDistinctValuesDiscrete_long_desc"> Discrete variables will be
        simulated using any number of categories from 2 up to this maximum.
        If set to 0 or 1, discrete variables will not be generated.</span>
            </li>
            <li>Default Value: <span
                    id="maxDistinctValuesDiscrete_default_value">0</span></li>
            <li>Lower
                Bound: <span id="maxDistinctValuesDiscrete_lower_bound">0</span></li>
            <li>Upper Bound: <span
                    id="maxDistinctValuesDiscrete_upper_bound">2147483647</span></li>
            <li>Value Type: <span
                    id="maxDistinctValuesDiscrete_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description"
            id="maxIndegree">maxIndegree</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="maxIndegree_short_desc">Maximum indegree of graph (min =
        1)</span></li>
            <li>Long Description: <span
                    id="maxIndegree_long_desc"> An upper bound on the maximum indegree of
        any node in the graph. If no limit is to be placed on the maximum
        degree, use the value -1.</span></li>
            <li>Default Value: <span
                    id="maxIndegree_default_value">1000</span></li>
            <li>Lower Bound: <span
                    id="maxIndegree_lower_bound">1</span></li>
            <li>Upper Bound: <span
                    id="maxIndegree_upper_bound">2147483647</span></li>
            <li>Value Type:
                <span id="maxIndegree_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description" id="zsMaxIndegree">zsMaxIndegree</h3>
        <ul class="parameter_description_list">
            <li>Short Description: <span
                    id="zsMaxIndegree_short_desc">Maximum indegree of true graph (min = 0)</span>
            </li>
            <li>Long Description: <span id="zsMaxIndegree_long_desc">This is the maximum number of parents one expects any node to have in the true model.</span>
            </li>
            <li>Default Value: <span id="zsMaxIndegree_default_value">4</span></li>
            <li>Lower Bound: <span id="zsMaxIndegree_lower_bound">0</span></li>
            <li>Upper Bound: <span id="zsMaxIndegree_upper_bound">2147483647</span></li>
            <li>Value Type: <span id="zsMaxIndegree_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description"
            id="maxIterations">maxIterations</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="maxIterations_short_desc"> The maximum number of iterations the
        algorithm should go through orienting edges</span></li>
            <li>Long
                Description: <span id="maxIterations_long_desc"> In orienting, this
        algorithm may go through a number of iterations, conditioning on more
        and more variables until orientations are set. This sets that
        number.</span></li>
            <li>Default Value: <span
                    id="maxIterations_default_value">15</span></li>
            <li>Lower Bound:
                <span id="maxIterations_lower_bound">0</span></li>
            <li>Upper Bound:
                <span id="maxIterations_upper_bound">2147483647</span></li>
            <li>Value
                Type: <span id="maxIterations_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description"
            id="maxOutdegree">maxOutdegree</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="maxOutdegree_short_desc">Maximum outdegree of graph (min =
        1)</span></li>
            <li>Long Description: <span
                    id="maxOutdegree_long_desc"> An upper bound on the maximum outdegree
        of any node in the graph. If no limit is to be placed on the maximum
        degree, use the value -1.</span></li>
            <li>Default Value: <span
                    id="maxOutdegree_default_value">1000</span></li>
            <li>Lower Bound:
                <span id="maxOutdegree_lower_bound">1</span></li>
            <li>Upper Bound:
                <span id="maxOutdegree_upper_bound">2147483647</span></li>
            <li>Value
                Type: <span id="maxOutdegree_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description"
            id="maxPOrientationMaxPathLength">maxPOrientationMaxPathLength</h3>
        <ul class="parameter_description_list">
            <li>Short Description: <span
                    id="maxPOrientationMaxPathLength_short_desc">Maximum path length for
        the unshielded collider heuristic for max P (min = 0)</span></li>
            <li>Long Description: <span
                    id="maxPOrientationMaxPathLength_long_desc"> For the Max P
        “heuristic” to work, it must be the case that X and Z are only weakly
        associated—that is, that paths between them are not too short. This
        bounds the length of paths for this purpose.</span></li>
            <li>Default
                Value: <span
                        id="maxPOrientationMaxPathLength_default_value">3</span></li>
            <li>Lower Bound: <span
                    id="maxPOrientationMaxPathLength_lower_bound">0</span></li>
            <li>Upper
                Bound: <span
                        id="maxPOrientationMaxPathLength_upper_bound">2147483647</span></li>
            <li>Value Type: <span
                    id="maxPOrientationMaxPathLength_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description"
            id="maxPathLength">maxPathLength</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="maxPathLength_short_desc">The maximum length for any
        discriminating path. -1 if unlimited (min = -1)</span></li>
            <li>Long
                Description: <span id="maxPathLength_long_desc"> See Spirtes,
        Glymour, and Scheines (2000) for the definition of discrimination
        path. Finding discriminating paths can be expensive. This sets the
        maximum length of such paths that the algorithm tries to find.</span>
            </li>
            <li>Default Value: <span
                    id="maxPathLength_default_value">-1</span></li>
            <li>Lower Bound:
                <span id="maxPathLength_lower_bound">-1</span></li>
            <li>Upper Bound:
                <span id="maxPathLength_upper_bound">2147483647</span></li>
            <li>Value
                Type: <span id="maxPathLength_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description" id="maxit">maxit</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="maxit_short_desc">MAXIT parameter (GLASSO) (min = 1)</span></li>
            <li>Long Description: <span id="maxit_long_desc"> Sets the maximum
        number of iterations of the optimization loop.</span></li>
            <li>Default Value: <span id="maxit_default_value">10000</span></li>
            <li>Lower Bound: <span id="maxit_lower_bound">1</span></li>
            <li>Upper
                Bound: <span id="maxit_upper_bound">2147483647</span></li>
            <li>Value
                Type: <span id="maxit_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description" id="meanHigh">meanHigh</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="meanHigh_short_desc">High end of mean range (min =
        0.0)</span></li>
            <li>Long Description: <span id="meanHigh_long_desc">
        The default is for there to be no shift in mean, but shifts from a
        minimum value to a maximum value may be specified. The minimum must
        be less than or equal to this maximum.</span></li>
            <li>Default
                Value: <span id="meanHigh_default_value">1.0</span></li>
            <li>Lower
                Bound: <span id="meanHigh_lower_bound">0.0</span></li>
            <li>Upper
                Bound: <span
                        id="meanHigh_upper_bound">1.7976931348623157E308</span></li>
            <li>Value Type: <span id="meanHigh_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description" id="meanLow">meanLow</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="meanLow_short_desc">Low end of mean range (min = 0.0)</span></li>
            <li>Long Description: <span id="meanLow_long_desc"> The default is
        for there to be no shift in mean, but shifts from a minimum value to
        a maximum value may be specified. The minimum must be greater than or
        equal to this minimum.</span></li>
            <li>Default Value: <span
                    id="meanLow_default_value">0.5</span></li>
            <li>Lower Bound: <span
                    id="meanLow_lower_bound">0.0</span></li>
            <li>Upper Bound: <span
                    id="meanLow_upper_bound">1.7976931348623157E308</span></li>
            <li>Value
                Type: <span id="meanLow_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description"
            id="measuredMeasuredImpureAssociations">
            measuredMeasuredImpureAssociations</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="measuredMeasuredImpureAssociations_short_desc"> Number of
        Measured <-> Measured impure edges</span></li>
            <li>Long Description:
                <span id="measuredMeasuredImpureAssociations_long_desc"> It is
        possible for measures from two different structural nodes to be
        confounded. These confounding (bidirected) edges will be considered
        to be impure.</span></li>
            <li>Default Value: <span
                    id="measuredMeasuredImpureAssociations_default_value">0</span></li>
            <li>Lower Bound: <span
                    id="measuredMeasuredImpureAssociations_lower_bound">-2147483648</span
            ></li>
            <li>Upper Bound: <span
                    id="measuredMeasuredImpureAssociations_upper_bound">2147483647</span>
            </li>
            <li>Value Type: <span
                    id="measuredMeasuredImpureAssociations_value_type">Integer</span></li
            >
        </ul>

        <h3 class="parameter_description"
            id="measuredMeasuredImpureParents">measuredMeasuredImpureParents</h3>
        <ul class="parameter_description_list">
            <li>Short Description: <span
                    id="measuredMeasuredImpureParents_short_desc"> Number of Measured -->
        Measured impure edges</span></li>
            <li>Long Description: <span
                    id="measuredMeasuredImpureParents_long_desc"> It is possible for
        measures from two different structural nodes to have directed edges
        between them. These edges will be considered to be impure.</span>
            </li>
            <li>Default Value: <span
                    id="measuredMeasuredImpureParents_default_value">0</span></li>
            <li>Lower Bound: <span
                    id="measuredMeasuredImpureParents_lower_bound">-2147483648</span></li
            >
            <li>Upper Bound: <span
                    id="measuredMeasuredImpureParents_upper_bound">2147483647</span></li>
            <li>Value Type: <span
                    id="measuredMeasuredImpureParents_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description"
            id="measurementModelDegree">measurementModelDegree</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="measurementModelDegree_short_desc">Number of measurements per
        Latent</span></li>
            <li>Long Description: <span
                    id="measurementModelDegree_long_desc"> Each structural node in the
        MIM will be created to have this many measured children.</span></li>
            <li>Default Value: <span
                    id="measurementModelDegree_default_value">5</span></li>
            <li>Lower
                Bound: <span
                        id="measurementModelDegree_lower_bound">-2147483648</span></li>
            <li>Upper Bound: <span
                    id="measurementModelDegree_upper_bound">2147483647</span></li>
            <li>Value Type: <span
                    id="measurementModelDegree_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description"
            id="measurementVariance">measurementVariance</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="measurementVariance_short_desc"> Additive measurement noise
        variance (min = 0.0)</span></li>
            <li>Long Description: <span
                    id="measurementVariance_long_desc"> If the value is greater than
        zero, independent Gaussian noise will be added with mean zero and the
        given variance to each variable in the simulated output.</span>
            </li>
            <li>Default Value: <span
                    id="measurementVariance_default_value">0.0</span></li>
            <li>Lower
                Bound: <span id="measurementVariance_lower_bound">0.0</span></li>
            <li>Upper Bound: <span
                    id="measurementVariance_upper_bound">1.7976931348623157E308</span>
            </li>
            <li>Value Type: <span
                    id="measurementVariance_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description" id="mgmParam1">mgmParam1</h3>
        <ul class="parameter_description_list">
            <li>Short Description: <span
                    id="mgmParam1_short_desc">MGM tuning parameter #1 (min =
        0.0)</span></li>
            <li>Long Description: <span
                    id="mgmParam1_long_desc"> The MGM algorithm has three internal tuning
        parameters, of which this is one.</span></li>
            <li>Default Value:
                <span id="mgmParam1_default_value">0.1</span></li>
            <li>Lower Bound:
                <span id="mgmParam1_lower_bound">0.0</span></li>
            <li>Upper Bound:
                <span id="mgmParam1_upper_bound">1.7976931348623157E308</span></li>
            <li>Value Type: <span id="mgmParam1_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description" id="mgmParam2">mgmParam2</h3>
        <ul class="parameter_description_list">
            <li>Short Description: <span
                    id="mgmParam2_short_desc">MGM tuning parameter #2 (min =
        0.0)</span></li>
            <li>Long Description: <span
                    id="mgmParam2_long_desc"> The MGM algorithm has three internal tuning
        parameters, of which this is one.</span></li>
            <li>Default Value:
                <span id="mgmParam2_default_value">0.1</span></li>
            <li>Lower Bound:
                <span id="mgmParam2_lower_bound">0.0</span></li>
            <li>Upper Bound:
                <span id="mgmParam2_upper_bound">1.7976931348623157E308</span></li>
            <li>Value Type: <span id="mgmParam2_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description" id="mgmParam3">mgmParam3</h3>
        <ul class="parameter_description_list">
            <li>Short Description: <span
                    id="mgmParam3_short_desc">MGM tuning parameter #3 (min =
        0.0)</span></li>
            <li>Long Description: <span
                    id="mgmParam3_long_desc">The MGM algorithm has three internal tuning
        parameters, of which this is one.</span></li>
            <li>Default Value:
                <span id="mgmParam3_default_value">0.1</span></li>
            <li>Lower Bound:
                <span id="mgmParam3_lower_bound">0.0</span></li>
            <li>Upper Bound:
                <span id="mgmParam3_upper_bound">1.7976931348623157E308</span></li>
            <li>Value Type: <span id="mgmParam3_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description"
            id="minCategories">minCategories</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="minCategories_short_desc">Minimum number of categories (min =
        2)</span></li>
            <li>Long Description: <span
                    id="minCategories_long_desc"> The minimum number of categories to be
        used for randomly generated discrete variables. The default is
        2.</span></li>
            <li>Default Value: <span
                    id="minCategories_default_value">3</span></li>
            <li>Lower Bound: <span
                    id="minCategories_lower_bound">2</span></li>
            <li>Upper Bound: <span
                    id="minCategories_upper_bound">2147483647</span></li>
            <li>Value Type:
                <span id="minCategories_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description"
            id="noRandomlyDeterminedIndependence">
            noRandomlyDeterminedIndependence</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="noRandomlyDeterminedIndependence_short_desc"> Yes, if using the
        cutoff threshold for the independence test.</span></li>
            <li>Long
                Description: <span
                        id="noRandomlyDeterminedIndependence_long_desc">null</span></li>
            <li>Default Value: <span
                    id="noRandomlyDeterminedIndependence_default_value">false</span></li>
            <li>Lower Bound: <span
                    id="noRandomlyDeterminedIndependence_lower_bound"></span></li>
            <li>Upper Bound: <span
                    id="noRandomlyDeterminedIndependence_upper_bound"></span></li>
            <li>Value Type: <span
                    id="noRandomlyDeterminedIndependence_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description"
            id="numBasisFunctions">numBasisFunctions</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="numBasisFunctions_short_desc"> Number of functions to use in
        (truncated) basis</span></li>
            <li>Long Description: <span
                    id="numBasisFunctions_long_desc"> This parameter specifies how many
        of the most significant basis functions to use as a basis.</span>
            </li>
            <li>Default Value: <span
                    id="numBasisFunctions_default_value">30</span></li>
            <li>Lower Bound:
                <span id="numBasisFunctions_lower_bound">1</span></li>
            <li>Upper
                Bound: <span
                        id="numBasisFunctions_upper_bound">2147483647</span></li>
            <li>Value
                Type: <span id="numBasisFunctions_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description"
            id="numBscBootstrapSamples">numBscBootstrapSamples</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="numBscBootstrapSamples_short_desc"> The number of bootstrappings
        drawing from posterior dist. (min = 1)</span></li>
            <li>Long
                Description: <span id="numBscBootstrapSamples_long_desc"> The number
        of bootstrappings drawing from posterior dist. (min = 1)</span></li>
            <li>Default Value: <span
                    id="numBscBootstrapSamples_default_value">50</span></li>
            <li>Lower
                Bound: <span id="numBscBootstrapSamples_lower_bound">1</span></li>
            <li>Upper Bound: <span
                    id="numBscBootstrapSamples_upper_bound">2147483647</span></li>
            <li>Value Type: <span
                    id="numBscBootstrapSamples_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description"
            id="numCategories">numCategories</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="numCategories_short_desc">Number of categories for discrete
        variables (min = 2)</span></li>
            <li>Long Description: <span
                    id="numCategories_long_desc"> The number of categories to be used for
        randomly generated discrete variables. The default is 4; the minimum
        is 2.</span></li>
            <li>Default Value: <span
                    id="numCategories_default_value">4</span></li>
            <li>Lower Bound: <span
                    id="numCategories_lower_bound">2</span></li>
            <li>Upper Bound: <span
                    id="numCategories_upper_bound">2147483647</span></li>
            <li>Value Type:
                <span id="numCategories_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description"
            id="numCategoriesToDiscretize">numCategoriesToDiscretize</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="numCategoriesToDiscretize_short_desc"> The number of categories
        used to discretize continuous variables, if necessary (min =
        2)</span></li>
            <li>Long Description: <span
                    id="numCategoriesToDiscretize_long_desc"> In case the exact algorithm
        is not used for discrete children and continuous parents is not used,
        this parameter gives the number of categories to use for this
        second (discretize) backup copy of the continuous variables. </span>
            </li>
            <li>Default Value: <span
                    id="numCategoriesToDiscretize_default_value">3</span></li>
            <li>Lower
                Bound: <span id="numCategoriesToDiscretize_lower_bound">2</span></li>
            <li>Upper Bound: <span
                    id="numCategoriesToDiscretize_upper_bound">2147483647</span></li>
            <li>Value Type: <span
                    id="numCategoriesToDiscretize_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description" id="numLags">numLags</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="numLags_short_desc">The number of lags in the time lag
        model</span></li>
            <li>Long Description: <span id="numLags_long_desc">
        A time lag model may take variables from previous time steps into
        account. This determines how many steps back these relevant variables
        might go.</span></li>
            <li>Default Value: <span
                    id="numLags_default_value">1</span></li>
            <li>Lower Bound: <span
                    id="numLags_lower_bound">-2147483648</span></li>
            <li>Upper Bound:
                <span id="numLags_upper_bound">2147483647</span></li>
            <li>Value Type:
                <span id="numLags_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description" id="numLatents">numLatents</h3>
        <ul class="parameter_description_list">
            <li>Short Description: <span
                    id="numLatents_short_desc">Number of additional latent variables (min
        = 0)</span></li>
            <li>Long Description: <span
                    id="numLatents_long_desc"> The number of additional latent
        variables to include in the datasets</span></li>
            <li>Default Value:
                <span id="numLatents_default_value">0</span></li>
            <li>Lower Bound:
                <span id="numLatents_lower_bound">0</span></li>
            <li>Upper Bound:
                <span id="numLatents_upper_bound">2147483647</span></li>
            <li>Value
                Type: <span id="numLatents_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description"
            id="numMeasures">numMeasures</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="numMeasures_short_desc">Number of measured variables (min =
        1)</span></li>
            <li>Long Description: <span
                    id="numMeasures_long_desc"> The number of measured (recorded in data)
        variables to include in the dataset. </span></li>
            <li>Default Value:
                <span id="numMeasures_default_value">10</span></li>
            <li>Lower Bound:
                <span id="numMeasures_lower_bound">1</span></li>
            <li>Upper Bound:
                <span id="numMeasures_upper_bound">2147483647</span></li>
            <li>Value
                Type: <span id="numMeasures_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description"
            id="numRandomizedSearchModels">numRandomizedSearchModels</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="numRandomizedSearchModels_short_desc">The number of search
        probabilistic model (min = 1)</span></li>
            <li>Long Description:
                <span id="numRandomizedSearchModels_long_desc"> The number of search
        probabilistic model (min = 1)</span></li>
            <li>Default Value: <span
                    id="numRandomizedSearchModels_default_value">10</span></li>
            <li>Lower
                Bound: <span id="numRandomizedSearchModels_lower_bound">1</span></li>
            <li>Upper Bound: <span
                    id="numRandomizedSearchModels_upper_bound">2147483647</span></li>
            <li>Value Type: <span
                    id="numRandomizedSearchModels_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description" id="numRuns">numRuns</h3>
        <ul class="parameter_description_list">
            <li>Short Description: <span
                    id="numRuns_short_desc">Number of runs (min = 1)</span></li>
            <li>Long
                Description: <span id="numRuns_long_desc"> An analysis(randomly pick
        graph, randomly simulate a dataset, run an algorithm on it, look at
        the result) may be run over and over again this many times.</span>
            </li>
            <li>Default Value: <span
                    id="numRuns_default_value">1</span></li>
            <li>Lower Bound: <span
                    id="numRuns_lower_bound">1</span></li>
            <li>Upper Bound: <span
                    id="numRuns_upper_bound">2147483647</span></li>
            <li>Value Type: <span
                    id="numRuns_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description" id="probRemoveColumn">probRemoveColumn</h3>
        <ul class="parameter_description_list">
            <li>Short Description: <span
                    id="probRemoveColumn_short_desc">Probability of randomly removing a column from a dataset</span>
            </li>
            <li>Long
                Description: <span id="probRemoveColumn_long_desc">
                	For testing algorithms with overlapping variables, columns may be removed
                	from datasets with this probability.
        		</span>
            </li>
            <li>Default Value: <span
                    id="probRemoveColumn_default_value">0.0</span></li>
            <li>Lower Bound: <span
                    id="probRemoveColumn_lower_bound">0.0</span></li>
            <li>Upper Bound: <span
                    id="probRemoveColumn_upper_bound">1.0</span></li>
            <li>Value Type: <span
                    id="probRemoveColumn_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description"
            id="numStructuralEdges">numStructuralEdges</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="numStructuralEdges_short_desc">Number of structural
        edges</span></li>
            <li>Long Description: <span
                    id="numStructuralEdges_long_desc"> This is a parameter for generating
        random multiple indicator models (MIMs). A structural edge is an edge
        connecting two structural nodes.</span></li>
            <li>Default Value:
                <span id="numStructuralEdges_default_value">3</span></li>
            <li>Lower
                Bound: <span
                        id="numStructuralEdges_lower_bound">-2147483648</span></li>
            <li>Upper
                Bound: <span
                        id="numStructuralEdges_upper_bound">2147483647</span></li>
            <li>Value
                Type: <span id="numStructuralEdges_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description"
            id="numStructuralNodes">numStructuralNodes</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="numStructuralNodes_short_desc">Number of structural
        nodes</span></li>
            <li>Long Description: <span
                    id="numStructuralNodes_long_desc"> This is a parameter for generating
        random multiple indicator models (MIMs). A structural node is one of
        the latent variables in the model; each structural node has a number
        of child measured variables.</span></li>
            <li>Default Value: <span
                    id="numStructuralNodes_default_value">3</span></li>
            <li>Lower Bound:
                <span id="numStructuralNodes_lower_bound">-2147483648</span></li>
            <li>Upper Bound: <span
                    id="numStructuralNodes_upper_bound">2147483647</span></li>
            <li>Value
                Type: <span id="numStructuralNodes_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description"
            id="numberResampling">numberResampling</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="numberResampling_short_desc">The number of bootstraps/resampling
        iterations (min = 0)</span></li>
            <li>Long Description: <span
                    id="numberResampling_long_desc"> For bootstrapping, the number of
        bootstrap iterations that should be done by the algorithm, with
        results summarized.</span></li>
            <li>Default Value: <span
                    id="numberResampling_default_value">0</span></li>
            <li>Lower Bound:
                <span id="numberResampling_lower_bound">0</span></li>
            <li>Upper
                Bound: <span id="numberResampling_upper_bound">2147483647</span></li>
            <li>Value Type: <span
                    id="numberResampling_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description" id="numStarts">numStarts</h3>
        <ul class="parameter_description_list">
            <li>Short Description: <span
                    id="numStarts_short_desc">The number of restarts, random after the
        first (default 1)</span></li>
            <li>Long Description: <span
                    id="numStarts_long_desc"> The number of times the algorithm should
        be started from different initializations. By default, the algorithm
        will be run through at least once using the initialized parameters
        (zero random restarts).</span></li>
            <li>Default Value: <span
                    id="numStarts_default_value">1</span></li>
            <li>Lower Bound: <span
                    id="numStarts_lower_bound">1</span></li>
            <li>Upper Bound: <span
                    id="numStarts_upper_bound">2147483647</span></li>
            <li>Value Type:
                <span id="numStarts_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description" id="useBes">useBes</h3>
        <ul class="parameter_description_list">
            <li>Short Description: <span
                    id="useBes_short_desc">True if the optional BES step should be used</span></li>
            <li>Long Description: <span
                    id="useBes_long_desc">This algorithm can use the backward equivalence search
                    from the GES algorithm as one of its steps.</span></li>
            <li>Default Value: <span
                    id="useBes_default_value">False</span></li>
            <li>Lower Bound: <span
                    id="useBes_lower_bound"></span></li>
            <li>Upper Bound: <span
                    id="useBes_upper_bound"></span></li>
            <li>Value Type:
                <span id="useBes_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description"
            id="otherPermMethod">otherPermMethod</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="otherPermMethod_short_desc"> 1 = RCG, 2 = GSP, 3 = ESP, 4 =
        SP</span></li>
            <li>Long Description: <span
                    id="otherPermMethod_long_desc"> RCG (Random Carnival Game); GSP
        ("Greedy SP") GSP using tucking ESP ("Edge SP") is from Solus et al.
        SP ("Sparsest Permutation") Raskutti and Uhler </span></li>
            <li>Default Value: <span
                    id="otherPermMethod_default_value">1</span></li>
            <li>Lower Bound:
                <span id="otherPermMethod_lower_bound">1</span></li>
            <li>Upper Bound:
                <span id="otherPermMethod_upper_bound">5</span></li>
            <li>Value Type:
                <span id="otherPermMethod_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description"
            id="bossAlg">bossAlg</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="bossAlg_short_desc">Picks the BOSS algorithm type, BOSS1 or BOSS2</span></li>
            <li>Long
                Description: <span id="bossAlg_long_desc">1 = BOSS1, 2 = BOSS2, 3 = BOSS3
        </span></li>
            <li>Default Value: <span
                    id="bossAlg_default_value">1</span></li>
            <li>Lower Bound:
                <span id="bossAlg_lower_bound">1</span></li>
            <li>Upper Bound:
                <span id="bossAlg_upper_bound">3</span></li>
            <li>Value Type:
                <span id="bossAlg_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description"
            id="graspCheckCovering">graspCheckCovering</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="graspCheckCovering_short_desc"> Yes if covering of edges should
        be checked (GASP), no if not (GRASP) </span></li>
            <li>Long
                Description: <span id="graspCheckCovering_long_desc"> An edge X is
        covered if Parents(X) = Parents(Y) \ {X}. Not checking covering
        expands the search space. </span></li>
            <li>Default Value: <span
                    id="graspCheckCovering_default_value">false</span></li>
            <li>Lower
                Bound: <span id="graspCheckCovering_lower_bound"></span></li>
            <li>Upper Bound: <span
                    id="graspCheckCovering_upper_bound"></span></li>
            <li>Value Type:
                <span id="graspCheckCovering_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description"
            id="graspForwardTuckOnly">graspForwardTuckOnly</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="graspForwardTuckOnly_short_desc"> Yes if only forward tucks
        should be checked, no if also reverse tucks should be checked.</span>
            </li>
            <li>Long Description: <span
                    id="graspForwardTuckOnly_long_desc"> A forward tuck for X->Y moves Y
        to the before position of X in the permutation. A reverse tuck moves
        Y to after the position of X in the permutation. Including reverse
        tucks expands the search space. </span></li>
            <li>Default Value:
                <span id="graspForwardTuckOnly_default_value">false</span></li>
            <li>Lower Bound: <span
                    id="graspForwardTuckOnly_lower_bound"></span></li>
            <li>Upper Bound:
                <span id="graspForwardTuckOnly_upper_bound"></span></li>
            <li>Value
                Type: <span id="graspForwardTuckOnly_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description"
            id="graspBreakAfterImprovement">graspBreakAfterImprovement</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="graspBreakAfterImprovement_short_desc"> Yes if depth first search
        returns after first improvement, No for depth first traversal.
        </span></li>
            <li>Long Description: <span
                    id="graspBreakAfterImprovement_long_desc"> Exploring the full list in
        every DFS call is equivalent to what we've been calling the Random
        Carnival Game procedure (RCG). </span></li>
            <li>Default Value: <span
                    id="graspBreakAfterImprovement_default_value">true</span></li>
            <li>Lower Bound: <span
                    id="graspBreakAfterImprovement_lower_bound"></span></li>
            <li>Upper
                Bound: <span id="graspBreakAfterImprovement_upper_bound"></span></li>
            <li>Value Type: <span
                    id="graspBreakAfterImprovement_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description"
            id="graspOrderedAlg">graspOrderedAlg</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="graspOrderedAlg_short_desc"> Yes if earlier GRaSP stages should
        be performed before later stages </span></li>
            <li>Long Description:
                <span id="graspOrderedAlg_long_desc"> GRaSP has three stages; these
        can be performed separately or in order; by default Yes. </span>
            </li>
            <li>Default Value: <span
                    id="graspOrderedAlg_default_value">true</span></li>
            <li>Lower Bound:
                <span id="graspOrderedAlg_lower_bound"></span></li>
            <li>Upper Bound:
                <span id="graspOrderedAlg_upper_bound"></span></li>
            <li>Value Type:
                <span id="graspOrderedAlg_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description"
            id="graspUseScore">graspUseScore</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="graspUseScore_short_desc"> Yes if the score should be used for MB
        calculations, no if the test should be used instead. </span></li>
            <li>Long Description: <span id="graspUseScore_long_desc"> In either
        case, compositional graphoid axioms are assumed by the Grow-Shrink
        algorithm. </span></li>
            <li>Default Value: <span
                    id="graspUseScore_default_value">true</span></li>
            <li>Lower Bound:
                <span id="graspUseScore_lower_bound"></span></li>
            <li>Upper Bound:
                <span id="graspUseScore_upper_bound"></span></li>
            <li>Value Type:
                <span id="graspUseScore_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description"
            id="graspUseRaskuttiUhler">graspUseRaskuttiUhler</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="graspUseRaskuttiUhler_short_desc"> Yes to use Raskutti and Uhler's
        DAG-building method (test), No to use Grow-Shrink (score).</span>
            </li>
            <li>Long Description: <span id="graspUseRaskuttiUhler_long_desc">
        Raskutti and Uhler's method adds and edge X->Y if Y ~_||_ X |
        Prefix(Y, pi) \ {X}. Grow-Shrink adds an edge X->Y if X is in the
        Markov blanket of Y where the variable set is restricted to Prefix(Y,
        pi). </span></li>
            <li>Default Value: <span
                    id="graspUseRaskuttiUhler_default_value">false</span></li>
            <li>Lower
                Bound: <span id="graspUseRaskuttiUhler_lower_bound"></span></li>
            <li>Upper Bound: <span
                    id="graspUseRaskuttiUhler_upper_bound"></span></li>
            <li>Value Type:
                <span id="graspUseRaskuttiUhler_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description"
            id="useDataOrder">useDataOrder</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="useDataOrder_short_desc"> Yes just in case data variable
        order should be used for the first initial permutation. </span></li>
            <li>Long Description: <span id="useDataOrder_long_desc"> In
        either case, if multiple starting points are used, taking the best
        scoring model from among these, subsequent starting points will all
        be random shuffles. </span></li>
            <li>Default Value: <span
                    id="useDataOrder_default_value">true</span></li>
            <li>Lower
                Bound: <span id="useDataOrder_lower_bound"></span></li>
            <li>Upper Bound: <span
                    id="useDataOrder_upper_bound"></span></li>
            <li>Value Type: <span
                    id="useDataOrder_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description"
            id="allowInternalRandomness">
            allowInternalRandomness</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="allowInternalRandomness_short_desc">Allow randomness
        inside algorithm</span></li>
            <li>Long Description: <span
                    id="allowInternalRandomness_long_desc">This allows
        variables orders to be shuffled in certain sports to avoid local optima</span></li>
            <li>Default Value: <span
                    id="allowInternalRandomness_default_value">true</span>
            </li>
            <li>Lower Bound: <span
                    id="allowInternalRandomness_lower_bound"></span></li>
            <li>Upper Bound: <span
                    id="allowInternalRandomness_upper_bound"></span></li>
            <li>Value Type: <span
                    id="allowInternalRandomness_value_type">Boolean</span>
            </li>
        </ul>

        <h3 class="parameter_description"
            id="graspUseVpScoring">graspUseVpScoring</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="graspUseVpScoring_short_desc"> No sure </span></li>
            <li>Long
                Description: <span id="graspUseVpScoring_long_desc"> Not sure </span>
            </li>
            <li>Default Value: <span
                    id="graspUseVpScoring_default_value">false</span></li>
            <li>Lower
                Bound: <span id="graspUseVpScoring_lower_bound"></span></li>
            <li>Upper Bound: <span
                    id="graspUseVpScoring_upper_bound"></span></li>
            <li>Value Type: <span
                    id="graspUseVpScoring_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description" id="graspAlg">graspAlg</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="graspAlg_short_desc"> 1 = GRaSP1, 2 = GRaSP2, 3 = esp, 4 =
        GRaSP4, 5 = GRaSP4 </span></li>
            <li>Long Description: <span
                    id="graspAlg_long_desc"> Which version of GRaSP (temp parameter)
        </span></li>
            <li>Default Value: <span
                    id="graspAlg_default_value">1</span></li>
            <li>Lower Bound: <span
                    id="graspAlg_lower_bound">1</span></li>
            <li>Upper Bound: <span
                    id="graspAlg_upper_bound">5</span></li>
            <li>Value Type: <span
                    id="graspAlg_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description" id="graspDepth">graspDepth</h3>
        <ul class="parameter_description_list">
            <li>Short Description: <span
                    id="graspDepth_short_desc">Recursion depth</span></li>
            <li>Long
                Description: <span id="graspDepth_long_desc"> This is the depth of
        recursion for the depth first search. </span></li>
            <li>Default
                Value: <span id="graspDepth_default_value">3</span></li>
            <li>Lower
                Bound: <span id="graspDepth_lower_bound">0</span></li>
            <li>Upper
                Bound: <span id="graspDepth_upper_bound">2147483647</span></li>
            <li>Value Type: <span id="graspDepth_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description"
            id="graspSingularDepth">graspSingularDepth</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="graspSingularDepth_short_desc">Recursion depth for singular
        tucks</span></li>
            <li>Long Description: <span
                    id="graspSingularDepth_long_desc"> This is the depth of recursion
        for the singular tucks. </span></li>
            <li>Default
                Value: <span id="graspSingularDepth_default_value">1</span></li>
            <li>Lower Bound: <span
                    id="graspSingularDepth_lower_bound">0</span></li>
            <li>Upper Bound:
                <span id="graspSingularDepth_upper_bound">2147483647</span></li>
            <li>Value Type: <span
                    id="graspSingularDepth_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description"
            id="graspNonSingularDepth">graspNonSingularDepth</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="graspNonSingularDepth_short_desc">Recursion depth for nonsingular
        tucks</span></li>
            <li>Long Description: <span
                    id="graspNonSingularDepth_long_desc"> This is the depth of recursion
        at which multiple tucks may be considered per score improvement
        </span></li>
            <li>Default Value: <span
                    id="graspNonSingularDepth_default_value">1</span></li>
            <li>Lower
                Bound: <span id="graspNonSingularDepth_lower_bound">0</span></li>
            <li>Upper Bound: <span
                    id="graspNonSingularDepth_upper_bound">2147483647</span></li>
            <li>Value Type: <span
                    id="graspNonSingularDepth_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description"
            id="graspToleranceDepth">graspToleranceDepth</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="graspToleranceDepth_short_desc">Recursion depth for tolerance
        tucks</span></li>
            <li>Long Description: <span
                    id="graspToleranceDepth_long_desc"> This is the maximum number of
        non-greedy tucks in depth first order --that is, tucks where the
        score is allowed to decrease rather than increase. </span></li>
            <li>Default Value: <span
                    id="graspToleranceDepth_default_value">0</span></li>
            <li>Lower Bound:
                <span id="graspToleranceDepth_lower_bound">0</span></li>
            <li>Upper
                Bound: <span
                        id="graspToleranceDepth_upper_bound">2147483647</span></li>
            <li>Value
                Type: <span id="graspToleranceDepth_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description" id="timeout">timeout</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="timeout_short_desc">Timeout (best graph returned, -1 = no
        timeout)</span></li>
            <li>Long Description: <span
                    id="timeout_long_desc"> The algorithm will time out at approximately
        this number of seconds from when it started and return the final
        graph found at that point. </span></li>
            <li>Default Value: <span
                    id="timeout_default_value">-1</span></li>
            <li>Lower Bound: <span
                    id="timeout_lower_bound">-1</span></li>
            <li>Upper Bound: <span
                    id="timeout_upper_bound">2147483647</span></li>
            <li>Value Type: <span
                    id="timeout_value_type">Integer</span></li>
        </ul>

        <ul class="parameter_description_list">
            <li>Short Description:
                <span id="breakTies_short_desc">Yes if the algorithm should try
        moving variables pairwise</span></li>
            <li>Long Description: <span
                    id="breakTies_long_desc"> In some cases, two moves are required
        simultaneously to get an orientation right in the final step. This is
        not generally needed when optimizing using BIC or for large
        models.</span></li>
            <li>Default Value: <span
                    id="breakTies_default_value">true</span></li>
            <li>Lower Bound: <span
                    id="breakTies_lower_bound"></span></li>
            <li>Upper Bound: <span
                    id="breakTies_upper_bound"></span></li>
            <li>Value Type: <span
                    id="breakTies_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description" id="recursive">recursive</h3>
        <ul class="parameter_description_list">
            <li>Short Description: <span
                    id="recursive_short_desc">Yes if the algorithm should proceed
        recursively, no if not</span></li>
            <li>Long Description: <span
                    id="recursive_long_desc"> Where recursive or nonrecursive variants of
        an algorithm are available, this selects which one to use.</span>
            </li>
            <li>Default Value: <span
                    id="recursive_default_value">false</span></li>
            <li>Lower Bound: <span
                    id="recursive_lower_bound"></span></li>
            <li>Upper Bound: <span
                    id="recursive_upper_bound"></span></li>
            <li>Value Type: <span
                    id="recursive_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description"
            id="orientTowardMConnections">orientTowardMConnections</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="orientTowardMConnections_short_desc">Yes if Richardson's step C
        (orient toward d-connection) should be used</span></li>
            <li>Long
                Description: <span id="orientTowardMConnections_long_desc"> Please
        see the description of this algorithm in Thomas Richardson and Peter
        Spirtes in Chapter 7 of Computation, Causation, & Discovery by
        Glymour and Cooper eds.</span></li>
            <li>Default Value: <span
                    id="orientTowardMConnections_default_value">true</span></li>
            <li>Lower Bound: <span
                    id="orientTowardMConnections_lower_bound"></span></li>
            <li>Upper
                Bound: <span id="orientTowardMConnections_upper_bound"></span></li>
            <li>Value Type: <span
                    id="orientTowardMConnections_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description"
            id="orientVisibleFeedbackLoops">orientVisibleFeedbackLoops</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="orientVisibleFeedbackLoops_short_desc">Yes if visible feedback
        loops should be oriented</span></li>
            <li>Long Description: <span
                    id="orientVisibleFeedbackLoops_long_desc"> Please see the description
        of this algorithm in Thomas Richardson and Peter Spirtes in Chapter 7
        of Computation, Causation, & Discovery by Glymour and Cooper
        eds.</span></li>
            <li>Default Value: <span
                    id="orientVisibleFeedbackLoops_default_value">true</span></li>
            <li>Lower Bound: <span
                    id="orientVisibleFeedbackLoops_lower_bound"></span></li>
            <li>Upper
                Bound: <span id="orientVisibleFeedbackLoops_upper_bound"></span></li>
            <li>Value Type: <span
                    id="orientVisibleFeedbackLoops_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description" id="outputRBD">outputRBD</h3>
        <ul class="parameter_description_list">
            <li>Short Description: <span
                    id="outputRBD_short_desc"> Constraint Scoring: Yes: Dependent
        Scoring, No: Independent Scoring.</span></li>
            <li>Long Description:
                <span id="outputRBD_long_desc"> Constraint Scoring: Yes: Dependent
        Scoring, No: Independent Scoring.</span></li>
            <li>Default Value:
                <span id="outputRBD_default_value">true</span></li>
            <li>Lower Bound:
                <span id="outputRBD_lower_bound"></span></li>
            <li>Upper Bound: <span
                    id="outputRBD_upper_bound"></span></li>
            <li>Value Type: <span
                    id="outputRBD_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description" id="precomputeCovariances">precomputeCovariances</h3>
        <ul class="parameter_description_list">
            <li>Short Description: <span
                    id="precomputeCovariances_short_desc">True if covariance matrix should
                	be precomputed for tabular continuous data</span></li>
            <li>Long Description:
                <span id="precomputeCovariances_long_desc">
                For more than 5000 variables or so, set this to false in order to calculate covariances
                on the fly from data.
        </span></li>
            <li>Default Value:
                <span id="precomputeCovariances_default_value">true</span></li>
            <li>Lower Bound:
                <span id="precomputeCovariances_lower_bound"></span></li>
            <li>Upper Bound: <span
                    id="precomputeCovariances_upper_bound"></span></li>
            <li>Value Type: <span
                    id="precomputeCovariances_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description"
            id="penaltyDiscount">penaltyDiscount</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="penaltyDiscount_short_desc">Penalty discount (min =
        0.0)</span></li>
            <li>Long Description: <span
                    id="penaltyDiscount_long_desc"> The parameter c added to a modified
        BIC score of the form 2L – c k ln N, where L is the likelihood, k the
        number of degrees of freedom, and N the sample size. Higher c yield
        sparser graphs. </span></li>
            <li>Default Value: <span
                    id="penaltyDiscount_default_value">2.0</span></li>
            <li>Lower Bound:
                <span id="penaltyDiscount_lower_bound">0.0</span></li>
            <li>Upper
                Bound: <span
                        id="penaltyDiscount_upper_bound">1.7976931348623157E308</span></li>
            <li>Value Type: <span
                    id="penaltyDiscount_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description"
            id="penaltyDiscountZs">penaltyDiscountZs</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="penaltyDiscountZs_short_desc">Penalty discount (min =
        0.0)</span></li>
            <li>Long Description: <span
                    id="penaltyDiscountZs_long_desc"> The parameter c added to a modified
        BIC score of the form 2L – c k lambda, where L is the likelihood, k the
        number of degrees of freedom, and lambda the choice of GIC lambda. Higher c yield
        sparser graphs. </span></li>
            <li>Default Value: <span
                    id="penaltyDiscountZs_default_value">1.0</span></li>
            <li>Lower Bound:
                <span id="penaltyDiscountZs_lower_bound">0.0</span></li>
            <li>Upper
                Bound: <span
                        id="penaltyDiscountZs_upper_bound">1.7976931348623157E308</span></li>
            <li>Value Type: <span
                    id="penaltyDiscountZs_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description" id="zSRiskBound">zSRiskBound</h3>
        <ul class="parameter_description_list">
            <li>Short Description: <span id="zSRiskBound_short_desc">Risk bound</span></li>
            <li>Long Description: <span id="zSRiskBound_long_desc">
                This is the probability of getting the true model if a correct model is discovered. Could underfit.</span>
            </li>
            <li>Default Value: <span id="zSRiskBound_default_value">0.1</span></li>
            <li>Lower Bound: <span id="zSRiskBound_lower_bound">0</span></li>
            <li>Upper Bound: <span id="zSRiskBound_upper_bound">1</span></li>
            <li>Value Type: <span id="zSRiskBound_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description" id="ebicGamma">ebicGamma</h3>
        <ul class="parameter_description_list">
            <li>Short Description: <span
                    id="ebicGamma_short_desc">EBIC Gamma (0-1)</span></li>
            <li>Long
                Description: <span id="ebicGamma_long_desc">The gamma parameter for
        Extended BIC (Chen and Chen). In [0, 1].</span></li>
            <li>Default
                Value: <span id="ebicGamma_default_value">0.8</span></li>
            <li>Lower
                Bound: <span id="ebicGamma_lower_bound">0.0</span></li>
            <li>Upper
                Bound: <span id="ebicGamma_upper_bound">1.0</span></li>
            <li>Value
                Type: <span id="ebicGamma_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description"
            id="trueErrorVariance">trueErrorVariance</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="trueErrorVariance_short_desc">True error variance</span></li>
            <li>Long Description: <span id="trueErrorVariance_long_desc"> The
        true error variance of the model, assuming this is the same for all
        variables.</span></li>
            <li>Default Value: <span
                    id="trueErrorVariance_default_value">1.0</span></li>
            <li>Lower Bound:
                <span id="trueErrorVariance_lower_bound">0.0</span></li>
            <li>Upper
                Bound: <span
                        id="trueErrorVariance_upper_bound">1.7976931348623157E308</span></li>
            <li>Value Type: <span
                    id="trueErrorVariance_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description"
            id="correlationThreshold">correlationThreshold</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="correlationThreshold_short_desc">Correlation
        Threshold</span></li>
            <li>Long Description: <span
                    id="correlationThreshold_long_desc"> The algorithm will complain if
        correlations are found that are greater than this in absolute
        value.</span></li>
            <li>Default Value: <span
                    id="correlationThreshold_default_value">1</span></li>
            <li>Lower
                Bound: <span id="correlationThreshold_lower_bound">0</span></li>
            <li>Upper Bound: <span
                    id="correlationThreshold_upper_bound">1</span></li>
            <li>Value Type:
                <span id="correlationThreshold_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description"
            id="manualLambda">manualLambda</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="manualLambda_short_desc">Lambda (manually set)</span></li>
            <li>Long Description: <span id="manualLambda_long_desc"> The manually
        set lambda for GIC--the default is 10, though this should be set by
        the user to a good value. </span></li>
            <li>Default Value: <span
                    id="manualLambda_default_value">10.0</span></li>
            <li>Lower Bound:
                <span id="manualLambda_lower_bound">0.0</span></li>
            <li>Upper Bound:
                <span
                        id="manualLambda_upper_bound">1.7976931348623157E308</span></li>
            <li>Value Type: <span id="manualLambda_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description"
            id="thresholdAlpha">errorThreshold</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="thresholdAlpha_short_desc">Error Threshold</span></li>
            <li>Long
                Description: <span id="thresholdAlpha_long_desc"> Adjusts the
        threshold for judging conditional dependence.</span></li>
            <li>Default Value: <span
                    id="thresholdAlpha_default_value">0.5</span></li>
            <li>Lower Bound:
                <span id="thresholdAlpha_lower_bound">0.0</span></li>
            <li>Upper
                Bound: <span id="thresholdAlpha_upper_bound">1</span></li>
            <li>Value
                Type: <span id="thresholdAlpha_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description"
            id="parallelized">parallelized</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="parallelized_short_desc">
                    Yes if the search should be parallelized</span></li>
            <li>Long Description: <span
                    id="parallelized_long_desc">This search is capable of being
                    parallelized; select yes if the search should be parallelized,
                    not if it should be run in a single thread</span></li>
            <li>Default Value:
                <span id="parallelized_default_value">false</span></li>
            <li>Lower Bound:
                <span id="parallelized_lower_bound"></span></li>
            <li>Upper Bound:
                <span id="parallelized_upper_bound"></span></li>
            <li>Value
                Type: <span id="parallelized_value_type">Boolean</span></li>
        </ul>


        <h3 class="parameter_description"
            id="percentDiscrete">percentDiscrete</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="percentDiscrete_short_desc">Percentage of discrete variables (0 -
        100) for mixed data</span></li>
            <li>Long Description: <span
                    id="percentDiscrete_long_desc"> For a mixed data type simulation,
        specifies the percentage of variables that should be simulated
        (randomly) as discrete. The rest will be taken to be continuous. The
        default is 0—i.e. no discrete variables.</span></li>
            <li>Default
                Value: <span id="percentDiscrete_default_value">50.0</span></li>
            <li>Lower Bound: <span
                    id="percentDiscrete_lower_bound">0.0</span></li>
            <li>Upper Bound:
                <span id="percentDiscrete_upper_bound">100.0</span></li>
            <li>Value
                Type: <span id="percentDiscrete_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description"
            id="percentResampleSize">percentResampleSize</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="percentResampleSize_short_desc">The percentage of resample size
        (min = 10%)</span></li>
            <li>Long Description: <span
                    id="percentResampleSize_long_desc"> This parameter specifies the
        percentage of records in the bootstrap (as a percentage of the total
        original sample size of the data being bootstrapped).</span></li>
            <li>Default Value: <span
                    id="percentResampleSize_default_value">100</span></li>
            <li>Lower
                Bound: <span
                        id="percentResampleSize_lower_bound">10</span></li>
            <li>Upper Bound: <span
                    id="percentResampleSize_upper_bound">100</span></li>
            <li>Value
                Type: <span id="percentResampleSize_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description"
            id="possibleMsepDone">possibleMsepDone</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="possibleMsepDone_short_desc">Yes if the possible msep search
        should be done</span></li>
            <li>Long Description: <span
                    id="possibleMsepDone_long_desc"> This algorithm has a possible m-sep
        path search, which can be time-consuming. See Spirtes, Glymour, and
        Scheines (2000) for details.</span></li>
            <li>Default Value: <span
                    id="possibleMsepDone_default_value">true</span></li>
            <li>Lower Bound:
                <span id="possibleMsepDone_lower_bound"></span></li>
            <li>Upper Bound:
                <span id="possibleMsepDone_upper_bound"></span></li>
            <li>Value Type:
                <span id="possibleMsepDone_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description" id="probCycle">probCycle</h3>
        <ul class="parameter_description_list">
            <li>Short Description: <span
                    id="probCycle_short_desc">The probability of adding a cycle to the
        graph</span></li>
            <li>Long Description: <span
                    id="probCycle_long_desc"> Sets the probability that any particular
        set of 3, 4, or 5 of nodes will be used to form a cycle in the
        graph.</span></li>
            <li>Default Value: <span
                    id="probCycle_default_value">1.0</span></li>
            <li>Lower Bound: <span
                    id="probCycle_lower_bound">0.0</span></li>
            <li>Upper Bound: <span
                    id="probCycle_upper_bound">1.0</span></li>
            <li>Value Type: <span
                    id="probCycle_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description"
            id="probTwoCycle">probTwoCycle</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="probTwoCycle_short_desc">The probability of creating a 2-cycles
        in the graph (0 - 1)</span></li>
            <li>Long Description: <span
                    id="probTwoCycle_long_desc"> Any edge X*-*Y may be replaced with a
        2-cycle (feedback loop) between X and Y with this probability.</span>
            </li>
            <li>Default Value: <span
                    id="probTwoCycle_default_value">0.0</span></li>
            <li>Lower Bound:
                <span id="probTwoCycle_lower_bound">0.0</span></li>
            <li>Upper Bound:
                <span id="probTwoCycle_upper_bound">1.0</span></li>
            <li>Value Type:
                <span id="probTwoCycle_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description"
            id="randomSelectionSize">randomSelectionSize</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="randomSelectionSize_short_desc">The number of datasets that
        should be taken in each random sample</span></li>
            <li>Long
                Description: <span id="randomSelectionSize_long_desc"> The number of
        dataset that should be taken in each random sample of
        datasets.</span></li>
            <li>Default Value: <span
                    id="randomSelectionSize_default_value">1</span></li>
            <li>Lower Bound:
                <span id="randomSelectionSize_lower_bound">-2147483648</span></li>
            <li>Upper Bound: <span
                    id="randomSelectionSize_upper_bound">2147483647</span></li>
            <li>Value
                Type: <span id="randomSelectionSize_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description"
            id="randomizeColumns">randomizeColumns</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="randomizeColumns_short_desc">Yes if the order of the columns in
        each dataset should be randomized</span></li>
            <li>Long Description:
                <span id="randomizeColumns_long_desc"> In the real world where
        unfaithfulness is an issue the order of variables in the data may for
        some algorithms affect the output. For testing purposes, if Yes, the
        data columns are randomly re-ordered.</span></li>
            <li>Default Value:
                <span id="randomizeColumns_default_value">true</span></li>
            <li>Lower
                Bound: <span id="randomizeColumns_lower_bound"></span></li>
            <li>Upper
                Bound: <span id="randomizeColumns_upper_bound"></span></li>
            <li>Value
                Type: <span id="randomizeColumns_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description"
            id="guaranteeIid">guaranteeIid</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="guaranteeIid_short_desc">Recursive simulation is used for acyclic models; if not should i.i.d. be assumed?</span>
            </li>
            <li>Long Description:
                <span id="guaranteeIid_long_desc">For cyclic models, the Fisher simulation model is used, which is a time series. Selecting 'Yes' here
        guarantees that a new data point starts from a new shock without influence from the previous time step.</span>
            </li>
            <li>Default Value:
                <span id="guaranteeIid_default_value">true</span></li>
            <li>Lower
                Bound: <span id="guaranteeIid_lower_bound"></span></li>
            <li>Upper
                Bound: <span id="guaranteeIid_upper_bound"></span></li>
            <li>Value
                Type: <span id="guaranteeIid_value_type">Boolean</span></li>
        </ul>
        <h3 class="parameter_description"
            id="rcitNumFeatures">rcitNumFeatures</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="rcitNumFeatures_short_desc">The number of random features to
        use</span></li>
            <li>Long Description: <span
                    id="rcitNumFeatures_long_desc"></span></li>
            <li>Default Value: <span
                    id="rcitNumFeatures_default_value">10</span></li>
            <li>Lower Bound:
                <span id="rcitNumFeatures_lower_bound">1</span></li>
            <li>Upper Bound:
                <span id="rcitNumFeatures_upper_bound">2147483647</span></li>
            <li>Value Type: <span
                    id="rcitNumFeatures_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description"
            id="resamplingEnsemble">resamplingEnsemble</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="resamplingEnsemble_short_desc">Ensemble method: Preserved (1),
        Highest (2), Majority (3)</span></li>
            <li>Long Description: <span
                    id="resamplingEnsemble_long_desc"> Preserved = keep the highest frequency
        edges; Highest = keep the highest frequency edges but ignore the no edge
        case if maximal; Majority = keep edges only if their frequency is
        greater than 0.5. </span></li>
            <li>Default Value: <span
                    id="resamplingEnsemble_default_value">1</span></li>
            <li>Lower Bound:
                <span id="resamplingEnsemble_lower_bound">1</span></li>
            <li>Upper
                Bound: <span id="resamplingEnsemble_upper_bound">3</span></li>
            <li>Value Type: <span
                    id="resamplingEnsemble_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description"
            id="resamplingWithReplacement">resamplingWithReplacement</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="resamplingWithReplacement_short_desc">Yes, if sampling with
        replacement (bootstrapping)</span></li>
            <li>Long Description: <span
                    id="resamplingWithReplacement_long_desc"> Yes if resampling can be
        done with replacement, No if not. or without replacement. If with
        replacement, it is possible to have more than one copy of some of the
        records in the original dataset being included in the
        bootstrap.</span></li>
            <li>Default Value: <span
                    id="resamplingWithReplacement_default_value">true</span></li>
            <li>Lower Bound: <span
                    id="resamplingWithReplacement_lower_bound"></span></li>
            <li>Upper
                Bound: <span id="resamplingWithReplacement_upper_bound"></span></li>
            <li>Value Type: <span
                    id="resamplingWithReplacement_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description"
            id="priorEquivalentSampleSize">priorEquivalentSampleSize</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="priorEquivalentSampleSize_short_desc">Prior equivalent sample
        size (min = 1.0)</span></li>
            <li>Long Description: <span
                    id="priorEquivalentSampleSize_long_desc"> This sets the prior
        equivalent sample size. This number is added to the sample size for
        each conditional probability table in the model and is divided
        equally among the cells in the table. </span></li>
            <li>Default
                Value: <span id="priorEquivalentSampleSize_default_value">10.0</span></li>
            <li>Lower Bound: <span id="priorEquivalentSampleSize_lower_bound">1.0</span>
            </li>
            <li>Upper Bound:
                <span id="priorEquivalentSampleSize_upper_bound">1.7976931348623157E308</span>
            </li>
            <li>Value Type:
                <span id="priorEquivalentSampleSize_value_type">Double</span>
            </li>
        </ul>

        <h3 class="parameter_description" id="sampleSize">sampleSize</h3>
        <ul class="parameter_description_list">
            <li>Short Description: <span
                    id="sampleSize_short_desc">Sample size (min = 1)</span></li>
            <li>Long
                Description: <span id="sampleSize_long_desc"> Determines now many
        records should be generated for the data. The minimum number of
        records is 1; the default is set to 1000.</span></li>
            <li>Default
                Value: <span id="sampleSize_default_value">1000</span></li>
            <li>Lower
                Bound: <span id="sampleSize_lower_bound">1</span></li>
            <li>Upper
                Bound: <span id="sampleSize_upper_bound">2147483647</span></li>
            <li>Value Type: <span id="sampleSize_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description"
            id="saveLatentVars">saveLatentVars</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="saveLatentVars_short_desc">Save latent variables.</span></li>
            <li>Long Description: <span id="saveLatentVars_long_desc"> Yes if one
        wishes to have values for latent variables saved out with the rest of
        the data; No if only data for the measured variables should be
        saved.</span></li>
            <li>Default Value: <span
                    id="saveLatentVars_default_value">false</span></li>
            <li>Lower Bound:
                <span id="saveLatentVars_lower_bound"></span></li>
            <li>Upper Bound:
                <span id="saveLatentVars_upper_bound"></span></li>
            <li>Value Type:
                <span id="saveLatentVars_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description"
            id="scaleFreeAlpha">scaleFreeAlpha</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="scaleFreeAlpha_short_desc">For scale-free graphs, the parameter
        alpha (min = 0.0)</span></li>
            <li>Long Description: <span
                    id="scaleFreeAlpha_long_desc"> We use the algorithm for generating
        scale free graphs described in B. Bollobas,C. Borgs, J. Chayes, and
        O. Riordan (2003). Please see this article for a description of the
        parameters.</span></li>
            <li>Default Value: <span
                    id="scaleFreeAlpha_default_value">0.05</span></li>
            <li>Lower Bound:
                <span id="scaleFreeAlpha_lower_bound">0.0</span></li>
            <li>Upper
                Bound: <span id="scaleFreeAlpha_upper_bound">1.0</span></li>
            <li>Value Type: <span
                    id="scaleFreeAlpha_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description"
            id="scaleFreeBeta">scaleFreeBeta</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="scaleFreeBeta_short_desc">For scale-free graphs, the parameter
        beta (min = 0.0)</span></li>
            <li>Long Description: <span
                    id="scaleFreeBeta_long_desc"> We use the algorithm for generating
        scale free graphs described in B. Bollobas,C. Borgs, J. Chayes, and
        O. Riordan (2003). Please see this article for a description of the
        parameters.</span></li>
            <li>Default Value: <span
                    id="scaleFreeBeta_default_value">0.9</span></li>
            <li>Lower Bound:
                <span id="scaleFreeBeta_lower_bound">0.0</span></li>
            <li>Upper Bound:
                <span id="scaleFreeBeta_upper_bound">1.0</span></li>
            <li>Value Type:
                <span id="scaleFreeBeta_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description"
            id="scaleFreeDeltaIn">scaleFreeDeltaIn</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="scaleFreeDeltaIn_short_desc">For scale-free graphs, the parameter
        delta_in (min = 0.0)</span></li>
            <li>Long Description: <span
                    id="scaleFreeDeltaIn_long_desc"> We use the algorithm for generating
        scale free graphs described in B. Bollobas,C. Borgs, J. Chayes, and
        O. Riordan (2003). Please see this article for a description of the
        parameters.</span></li>
            <li>Default Value: <span
                    id="scaleFreeDeltaIn_default_value">3</span></li>
            <li>Lower Bound:
                <span id="scaleFreeDeltaIn_lower_bound">-2147483648</span></li>
            <li>Upper Bound: <span
                    id="scaleFreeDeltaIn_upper_bound">2147483647</span></li>
            <li>Value
                Type: <span id="scaleFreeDeltaIn_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description"
            id="scaleFreeDeltaOut">scaleFreeDeltaOut</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="scaleFreeDeltaOut_short_desc">For scale-free graphs, the
        parameter delta_out (min = 0.0)</span></li>
            <li>Long Description:
                <span id="scaleFreeDeltaOut_long_desc"> We use the algorithm for
        generating scale free graphs described in B. Bollobas,C. Borgs, J.
        Chayes, and O. Riordan (2003). Please see this article for a
        description of the parameters.</span></li>
            <li>Default Value: <span
                    id="scaleFreeDeltaOut_default_value">3</span></li>
            <li>Lower Bound:
                <span id="scaleFreeDeltaOut_lower_bound">-2147483648</span></li>
            <li>Upper Bound: <span
                    id="scaleFreeDeltaOut_upper_bound">2147483647</span></li>
            <li>Value
                Type: <span id="scaleFreeDeltaOut_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description"
            id="seed">seed</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="seed_short_desc">Seed for pseudorandom number generator (-1 = off)</span></li>
            <li>Long Description: <span
                    id="seed_long_desc">The seed is the initial value of the
                    internal state of the pseudorandom number generator. A value of -1
                skips setting a new seed.</span></li>
            <li>Default Value: <span
                    id="seed_default_value">-1</span></li>
            <li>Lower Bound:
                <span id="seed_lower_bound">-1</span></li>
            <li>Upper
                Bound: <span id="seed_upper_bound">9223372036854775807</span></li>
            <li>Value Type: <span
                    id="seed_value_type">Long</span></li>
        </ul>

        <h3 class="parameter_description"
            id="selfLoopCoef">selfLoopCoef</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="selfLoopCoef_short_desc">The coefficient for the self-loop
        (default 0.0)</span></li>
            <li>Long Description: <span
                    id="selfLoopCoef_long_desc"> For simulating time series data, each
        variable depends on itself one time-step back with a linear edge that
        has this coefficient.</span></li>
            <li>Default Value: <span
                    id="selfLoopCoef_default_value">0.0</span></li>
            <li>Lower Bound:
                <span id="selfLoopCoef_lower_bound">0.0</span></li>
            <li>Upper Bound:
                <span id="selfLoopCoef_upper_bound">Infinity</span></li>
            <li>Value
                Type: <span id="selfLoopCoef_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description" id="semBicRule">semBicRule</h3>
        <ul class="parameter_description_list">
            <li>Short Description: <span
                    id="semBicRule_short_desc"> Lambda: 1 = Chickering, 2 = Nandy</span>
            </li>
            <li>Long Description: <span id="semBicRule_long_desc">The
        Chickering Rule uses the difference of BIC scores to add or remove
        edges. The Nandy et al. rule uses a single calculation of a partial
        correlation in place of the likelihood difference. </span></li>
            <li>Default Value: <span id="semBicRule_default_value">1</span></li>
            <li>Lower Bound: <span id="semBicRule_lower_bound">1</span></li>
            <li>Upper Bound: <span id="semBicRule_upper_bound">2</span></li>
            <li>Value Type: <span id="semBicRule_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description" id="semGicRule">semGicRule</h3>
        <ul class="parameter_description_list">
            <li>Short Description: <span
                    id="semGicRule_short_desc"> Lambda: 1 = ln n, 2 = pn^1/3, 3 = 2 ln
        pn, 4 = 2(ln pn + ln ln pn), 5 = ln ln n ln pn, 6 = ln n ln pn, 7 =
        Manual</span></li>
            <li>Long Description: <span
                    id="semGicRule_long_desc">The rule used for calculating the lambda
        term of the score. We follow Kim, Y., Kwon, S., & Choi, H. (2012) and
        articles referenced therein. For high-dimensional data. </span></li>
            <li>Default Value: <span id="semGicRule_default_value">4</span></li>
            <li>Lower Bound: <span id="semGicRule_lower_bound">1</span></li>
            <li>Upper Bound: <span id="semGicRule_upper_bound">7</span></li>
            <li>Value Type: <span id="semGicRule_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description"
            id="semBicStructurePrior">semBicStructurePrior</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="semBicStructurePrior_short_desc">Structure Prior for SEM BIC
        (default 0)</span></li>
            <li>Long Description: <span
                    id="semBicStructurePrior_long_desc"> Structure prior; default is 0
        (turned off); may be any positive number otherwise</span></li>
            <li>Default Value: <span
                    id="semBicStructurePrior_default_value">0</span></li>
            <li>Lower
                Bound: <span id="semBicStructurePrior_lower_bound">0</span></li>
            <li>Upper Bound: <span
                    id="semBicStructurePrior_upper_bound">Infinity</span></li>
            <li>Value
                Type: <span id="semBicStructurePrior_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description"
            id="poissonLambda">poissonLambda</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="poissonLambda_short_desc">Lambda parameter for the Poisson distribution
        (> 0)</span></li>
            <li>Long Description: <span
                    id="poissonLambda_long_desc"> Lambda parameter for the Poisson distribution</span></li>
            <li>Default Value: <span
                    id="poissonLambda_default_value">1</span></li>
            <li>Lower
                Bound: <span id="poissonLambda_lower_bound">1e-10</span></li>
            <li>Upper Bound: <span
                    id="poissonLambda_upper_bound">Infinity</span></li>
            <li>Value
                Type: <span id="poissonLambda_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description"
            id="skipNumRecords">skipNumRecords</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="skipNumRecords_short_desc">Number of records that should be
        skipped between recordings (min = 0)</span></li>
            <li>Long
                Description: <span id="skipNumRecords_long_desc"> Data recordings are
        made every this many steps.</span></li>
            <li>Default Value: <span
                    id="skipNumRecords_default_value">0</span></li>
            <li>Lower Bound:
                <span id="skipNumRecords_lower_bound">0</span></li>
            <li>Upper Bound:
                <span id="skipNumRecords_upper_bound">2147483647</span></li>
            <li>Value Type: <span
                    id="skipNumRecords_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description" id="stableFAS">stableFAS</h3>
        <ul class="parameter_description_list">
            <li>Short Description: <span
                    id="stableFAS_short_desc">
                Yes if the Colombo et al. 'stable' FAS should be done, to
                avoid skeleton order dependency
            </span></li>
            <li>Long Description: <span
                    id="stableFAS_long_desc"> If Yes, the "stable" version of the PC
        adjacency search is used, which for k > 0 fixes the graph for depth k
        + 1 to that of the previous depth k. </span></li>
            <li>Default Value:
                <span id="stableFAS_default_value">true</span></li>
            <li>Lower Bound:
                <span id="stableFAS_lower_bound"></span></li>
            <li>Upper Bound: <span
                    id="stableFAS_upper_bound"></span></li>
            <li>Value Type: <span
                    id="stableFAS_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description"
            id="standardize">standardize</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="standardize_short_desc">Yes if the data should be
        standardized</span></li>
            <li>Long Description: <span
                    id="standardize_long_desc"> Yes if each variable in the data should
        be standardized to have mean zero and variance 1. </span></li>
            <li>Default Value: <span
                    id="standardize_default_value">false</span></li>
            <li>Lower Bound:
                <span id="standardize_lower_bound"></span></li>
            <li>Upper Bound:
                <span id="standardize_upper_bound"></span></li>
            <li>Value Type: <span
                    id="standardize_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description"
            id="structurePrior">structurePrior</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="structurePrior_short_desc">Structure prior coefficient (min =
        0.0)</span></li>
            <li>Long Description: <span
                    id="structurePrior_long_desc"> The default number of parents for any
        conditional probability table. Higher weight is accorded to tables
        with about that number of parents. The prior structure weights are
        distributed according to a binomial distribution.</span></li>
            <li>Default Value: <span
                    id="structurePrior_default_value">0.0</span></li>
            <li>Lower Bound:
                <span id="structurePrior_lower_bound">0.0</span></li>
            <li>Upper Bound:
                <span
                        id="structurePrior_upper_bound">1.7976931348623157E308</span></li>
            <li>Value Type: <span
                    id="structurePrior_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description"
            id="symmetricFirstStep">symmetricFirstStep</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="symmetricFirstStep_short_desc"> Yes if the first step for
        FGES should do scoring for both X->Y and Y->X</span></li>
            <li>Long
                Description: <span id="symmetricFirstStep_long_desc"> If Yes, scores
        for both X->Y and X<-Y will be calculated and the higher score
        used.</span></li>
            <li>Default Value: <span
                    id="symmetricFirstStep_default_value">false</span></li>
            <li>Lower
                Bound: <span id="symmetricFirstStep_lower_bound"></span></li>
            <li>Upper Bound: <span
                    id="symmetricFirstStep_upper_bound"></span></li>
            <li>Value Type:
                <span id="symmetricFirstStep_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description" id="targetName">targetName</h3>
        <ul class="parameter_description_list">
            <li>Short Description: <span
                    id="targetName_short_desc">Target variable name</span></li>
            <li>Long
                Description: <span id="targetName_long_desc"> The name of the target
        variables--for Markov blanket searches, this is the name of the
        variable for which one wants the Markov blanket or Markov blanket
        graph. </span></li>
            <li>Default Value: <span
                    id="targetName_default_value"></span></li>
            <li>Lower Bound: <span
                    id="targetName_lower_bound"></span></li>
            <li>Upper Bound: <span
                    id="targetName_upper_bound"></span></li>
            <li>Value Type: <span
                    id="targetName_value_type">String</span></li>
        </ul>

        <h3 class="parameter_description" id="thr">thr</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="thr_short_desc">THR parameter (GLASSO) (min = 0.0)</span></li>
            <li>Long Description: <span id="thr_long_desc"> Sets the maximum
        number of iterations of the optimization loop.</span></li>
            <li>Default Value: <span id="thr_default_value">1.0E-4</span></li>
            <li>Lower Bound: <span id="thr_lower_bound">0.0</span></li>
            <li>Upper
                Bound: <span id="thr_upper_bound">1.7976931348623157E308</span></li>
            <li>Value Type: <span id="thr_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description"
            id="thresholdForNumEigenvalues">thresholdForNumEigenvalues</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="thresholdForNumEigenvalues_short_desc"> Threshold to determine
        how many eigenvalues to use--the lower the more (0 to 1)</span></li>
            <li>Long Description: <span
                    id="thresholdForNumEigenvalues_long_desc"> Referring to Zhang, K.,
        Peters, J., Janzing, D., & Schölkopf, B. (2012), this parameter is
        the threshold to determine how many eigenvalues to use--the lower the
        more (0 to 1).</span></li>
            <li>Default Value: <span
                    id="thresholdForNumEigenvalues_default_value">0.001</span></li>
            <li>Lower Bound: <span
                    id="thresholdForNumEigenvalues_lower_bound">0.0</span></li>
            <li>Upper
                Bound: <span
                        id="thresholdForNumEigenvalues_upper_bound">Infinity</span></li>
            <li>Value Type: <span
                    id="thresholdForNumEigenvalues_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description"
            id="thresholdNoRandomConstrainSearch">
            thresholdNoRandomConstrainSearch</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="thresholdNoRandomConstrainSearch_short_desc"> Yes, if using the
        cutoff threshold for the meta-constraints independence test (stage
        2).</span></li>
            <li>Long Description: <span
                    id="thresholdNoRandomConstrainSearch_long_desc"> Yes, if using the
        cutoff threshold for the meta-constraints independence test (stage
        2).</span></li>
            <li>Default Value: <span
                    id="thresholdNoRandomConstrainSearch_default_value">true</span></li>
            <li>Lower Bound: <span
                    id="thresholdNoRandomConstrainSearch_lower_bound"></span></li>
            <li>Upper Bound: <span
                    id="thresholdNoRandomConstrainSearch_upper_bound"></span></li>
            <li>Value Type: <span
                    id="thresholdNoRandomConstrainSearch_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description"
            id="thresholdNoRandomDataSearch">thresholdNoRandomDataSearch</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="thresholdNoRandomDataSearch_short_desc"> Yes, if using the cutoff
        threshold for the constraints independence test (stage 1).</span>
            </li>
            <li>Long Description: <span
                    id="thresholdNoRandomDataSearch_long_desc">null</span></li>
            <li>Default Value: <span
                    id="thresholdNoRandomDataSearch_default_value">false</span></li>
            <li>Lower Bound: <span
                    id="thresholdNoRandomDataSearch_lower_bound"></span></li>
            <li>Upper
                Bound: <span
                        id="thresholdNoRandomDataSearch_upper_bound"></span></li>
            <li>Value
                Type: <span
                        id="thresholdNoRandomDataSearch_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description"
            id="twoCycleAlpha">twoCycleAlpha</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="twoCycleAlpha_short_desc">Alpha orienting 2-cycles (min =
        0.0)</span></li>
            <li>Long Description: <span
                    id="twoCycleAlpha_long_desc"> The alpha level of a T-test used to
        determine where 2-cycles exist in the graph. A value of zero turns
        off 2-cycle detection. </span></li>
            <li>Default Value: <span
                    id="twoCycleAlpha_default_value">0.0</span></li>
            <li>Lower Bound:
                <span id="twoCycleAlpha_lower_bound">0.0</span></li>
            <li>Upper Bound:
                <span id="twoCycleAlpha_upper_bound">1.0</span></li>
            <li>Value Type:
                <span id="twoCycleAlpha_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description" id="timeLimit">timeLimit</h3>
        <ul class="parameter_description_list">
            <li>Short Description: <span
                    id="timeLimit_short_desc">Time limit</span></li>
            <li>Long
                Description: <span id="timeLimit_long_desc">T-Separation requires a
        time limit. Default 1000.</span></li>
            <li>Default Value: <span
                    id="timeLimit_default_value">1000.0</span></li>
            <li>Lower Bound:
                <span id="timeLimit_lower_bound">0.0</span></li>
            <li>Upper Bound:
                <span id="timeLimit_upper_bound">1.7976931348623157E308</span></li>
            <li>Value Type: <span id="timeLimit_value_type">Double</span></li>
        </ul>


        <h3 class="parameter_description"
            id="adjustOrientations">adjustOrientations</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="adjustOrientations_short_desc">Yes, if the orientation adjustment
        step should be included</span></li>
            <li>Long Description: <span
                    id="adjustOrientations_long_desc"> Yes, if the orientation adjustment
        step should be included</span></li>
            <li>Default Value: <span
                    id="adjustOrientations_default_value">false</span></li>
            <li>Lower
                Bound: <span id="adjustOrientations_lower_bound"></span></li>
            g
            <li>Upper Bound: <span
                    id="adjustOrientations_upper_bound"></span></li>
            <li>Value Type:
                <span id="adjustOrientations_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description" id="upperBound">upperBound</h3>
        <ul class="parameter_description_list">
            <li>Short Description: <span
                    id="upperBound_short_desc">Upper bound cutoff threshold</span></li>
            <li>Long Description: <span
                    id="upperBound_long_desc">null</span></li>
            <li>Default Value: <span
                    id="upperBound_default_value">0.7</span></li>
            <li>Lower Bound: <span
                    id="upperBound_lower_bound">0.0</span></li>
            <li>Upper Bound: <span
                    id="upperBound_upper_bound">1.0</span></li>
            <li>Value Type: <span
                    id="upperBound_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description"
            id="useCorrDiffAdjacencies">useCorrDiffAdjacencies</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="useCorrDiffAdjacencies_short_desc">Yes if adjacencies from
        conditional correlation differences should be used</span></li>
            <li>Long Description: <span id="useCorrDiffAdjacencies_long_desc">
        FASK can use adjacencies X—Y where |corr(X,Y|X>0) – corr(X,Y|Y>0)| >
        threshold. This expression will be nonzero only if there is a path
        between X and Y; heuristically, if the difference is greater than,
        say, 0.3, we infer an adjacency.</span></li>
            <li>Default Value:
                <span id="useCorrDiffAdjacencies_default_value">true</span></li>
            <li>Lower Bound: <span
                    id="useCorrDiffAdjacencies_lower_bound"></span></li>
            <li>Upper Bound:
                <span id="useCorrDiffAdjacencies_upper_bound"></span></li>
            <li>Value
                Type: <span
                        id="useCorrDiffAdjacencies_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description"
            id="useFasAdjacencies">useFasAdjacencies</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="useFasAdjacencies_short_desc">Yes if adjacencies from the FAS
        search (correlation) should be used</span></li>
            <li>Long
                Description: <span id="useFasAdjacencies_long_desc"> Determines
        whether adjacencies found by conditional correlation should be
        included in the final model.</span></li>
            <li>Default Value: <span
                    id="useFasAdjacencies_default_value">true</span></li>
            <li>Lower
                Bound: <span id="useFasAdjacencies_lower_bound"></span></li>
            <li>Upper Bound: <span
                    id="useFasAdjacencies_upper_bound"></span></li>
            <li>Value Type: <span
                    id="useFasAdjacencies_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description"
            id="semImSimulationType">semImSimulationType</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="semImSimulationType_short_desc">Yes if recursive simulation, No
        if reduced form simulation</span></li>
            <li>Long Description: <span
                    id="semImSimulationType_long_desc"> Determines the type of simulation
        done. If recursive, the graph must be a DAG in causal order. "Reduced
        form" means X = (I - B)^-1 e, which requires a possibly large matrix
        inversion.</span></li>
            <li>Default Value: <span
                    id="semImSimulationType_default_value">true</span></li>
            <li>Lower
                Bound: <span id="semImSimulationType_lower_bound"></span></li>
            <li>Upper Bound: <span
                    id="semImSimulationType_upper_bound"></span></li>
            <li>Value Type:
                <span id="semImSimulationType_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description"
            id="simulationErrorType">simulationErrorType</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="simulationErrorType_short_desc"> 1 = Usual LG SEM, 2 =
        U(lb, ub), 3 = Exp(lambda), 4 = Gumbel(mu,
        beta), 5 = Gamma(shape, scale)</span></li>
            <li>Long Description: <span
                    id="simulationErrorType_long_desc">Exogenous error type</span></li>
            <li>Default Value: <span
                    id="simulationErrorType_default_value">1</span></li>
            <li>Lower Bound:
                <span id="simulationErrorType_lower_bound">1</span></li>
            <li>Upper
                Bound: <span id="simulationErrorType_upper_bound">5</span></li>
            <li>Value Type: <span
                    id="simulationErrorType_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description"
            id="simulationParam1">simulationParam1</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="simulationParam1_short_desc"> Indep error parameter
        #1</span></li>
            <li>Long Description: <span
                    id="simulationParam1_long_desc">Exogenous error parameter
        #1</span></li>
            <li>Default Value: <span
                    id="simulationParam1_default_value">0.0</span></li>
            <li>Lower Bound:
                <span id="simulationParam1_lower_bound">-1000</span></li>
            <li>Upper
                Bound: <span id="simulationParam1_upper_bound">1000</span></li>
            <li>Value Type: <span
                    id="simulationParam1_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description"
            id="simulationParam2">simulationParam2</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="simulationParam2_short_desc"> Indep error parameter #2, if
        used</span></li>
            <li>Long Description: <span
                    id="simulationParam2_long_desc">Exogenous error parameter
        #2</span></li>
            <li>Default Value: <span
                    id="simulationParam2_default_value">1.0</span></li>
            <li>Lower Bound:
                <span id="simulationParam2_lower_bound">-1000</span></li>
            <li>Upper
                Bound: <span id="simulationParam2_upper_bound">1000</span></li>
            <li>Value Type: <span
                    id="simulationParam2_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description" id="ess">ess</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="ess_short_desc">Yes if the equivalent sample size should be used
        in place of N</span></li>
            <li>Long Description: <span
                    id="ess_long_desc"> We calculate the equivalent sample size by
        assuming that all record are equally correlated</span></li>
            <li>Default Value: <span id="ess_default_value">false</span></li>
            <li>Lower Bound: <span id="ess_lower_bound"></span></li>
            <li>Upper
                Bound: <span id="ess_upper_bound"></span></li>
            <li>Value Type: <span
                    id="ess_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description" id="timeLag">timeLag</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="timeLag_short_desc">A time lag for time series data,
                    automatically applied (zero if none)</span></li>
            <li>Long Description: <span
                    id="timeLag_long_desc">Automatically applies the time lag
                    transform to the data, creating additional lagged variables. If
                    zero, no time lag is applied. A positive integer</span></li>
            <li>Default Value: <span id="timeLag_default_value">0</span></li>
            <li>Lower Bound: <span id="timeLag_lower_bound">0</span></li>
            <li>Upper
                Bound: <span id="timeLag_upper_bound">2147483647</span></li>
            <li>Value Type: <span
                    id="timeLag_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description" id="useGap">useGap</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="useGap_short_desc">Yes if the GAP algorithms should be used. Not
        if the SAG algorithm should be used</span></li>
            <li>Long
                Description: <span id="useGap_long_desc"> True if one should first
        find all possible initial sets, grows these out, and then picks a
        non-overlapping such largest sets from these. Not if one should grow
        pure clusters one at a time, excluding variables found in earlier
        clusters.</span></li>
            <li>Default Value: <span
                    id="useGap_default_value">false</span></li>
            <li>Lower Bound: <span
                    id="useGap_lower_bound"></span></li>
            <li>Upper Bound: <span
                    id="useGap_upper_bound"></span></li>
            <li>Value Type: <span
                    id="useGap_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description"
            id="useMaxPHeuristic">useMaxPHeuristic</h3>
        <ul class="parameter_description_list">
            <li>Short Description: <span
                    id="useMaxPHeuristic_short_desc">Yes if the max P
                    heuristic should be used to orient unshielded colliders</span></li>
            <li>Long Description: <span
                    id="useMaxPHeuristic_long_desc">The max P heuristic orients
                    X*-*Y*-*Z by considering whether Y is in the subset S of variables
                    adjacent to X or Z that maximizes the p-value of X _||_ Y | S.</span></li>
            <li>Default Value: <span
                    id="useMaxPHeuristic_default_value">false</span></li>
            <li>Lower Bound: <span
                    id="useMaxPHeuristic_lower_bound"></span></li>
            <li>Upper
                Bound: <span
                        id="useMaxPHeuristic_upper_bound"></span></li>
            <li>Value
                Type: <span
                        id="useMaxPHeuristic_value_type">Boolean</span></li>
        </ul>


        <h3 class="parameter_description"
            id="useMaxPOrientationHeuristic">useMaxPOrientationHeuristic</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="useMaxPOrientationHeuristic_short_desc">Yes if the heuristic for
        orienting unshielded colliders for max P should be used</span></li>
            <li>Long Description: <span
                    id="useMaxPOrientationHeuristic_long_desc"> Another way to do the
        orientation if X and Z are only weakly dependent, is to simply see
        whether the p-value for X _||_ Z | Y is greater than the p-value for
        X _||_ Z. The purpose is to speed up the search. </span></li>
            <li>Default Value: <span
                    id="useMaxPOrientationHeuristic_default_value">false</span></li>
            <li>Lower Bound: <span
                    id="useMaxPOrientationHeuristic_lower_bound"></span></li>
            <li>Upper
                Bound: <span
                        id="useMaxPOrientationHeuristic_upper_bound"></span></li>
            <li>Value
                Type: <span
                        id="useMaxPOrientationHeuristic_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description"
            id="useSkewAdjacencies">useSkewAdjacencies</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="useSkewAdjacencies_short_desc">Yes if adjacencies based on
        skewness should be used</span></li>
            <li>Long Description: <span
                    id="useSkewAdjacencies_long_desc"> FASK can use adjacencies X—Y where
        |corr(X,Y|X>0) – corr(X,Y|Y>0)| > threshold. This expression will be
        nonzero only if there is a path between X and Y; heuristically, if
        the difference is greater than, say, 0.3, we infer an adjacency. To
        see adjacencies included for this reason, set this parameter to
        “Yes”. Sanchez-Romero, Ramsey et al., (2018) Network
        Neuroscience.</span></li>
            <li>Default Value: <span
                    id="useSkewAdjacencies_default_value">true</span></li>
            <li>Lower
                Bound: <span id="useSkewAdjacencies_lower_bound"></span></li>
            <li>Upper Bound: <span
                    id="useSkewAdjacencies_upper_bound"></span></li>
            <li>Value Type:
                <span id="useSkewAdjacencies_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description" id="useWishart">useWishart</h3>
        <ul class="parameter_description_list">
            <li>Short Description: <span
                    id="useWishart_short_desc">Yes if the Wishart test should be used. Not
        if the Delta test should be used</span></li>
            <li>Long Description:
                <span id="useWishart_long_desc"> This is a parameter for the FOFC
        (Find One Factor Clusters) algorithm. There are two tests implemented
        there for testing for tetrads being zero, Wishart and Delta. This
        parameter picks which of these tests should be used: ‘Yes’ for Wishart
        and ‘No’ for Delta.</span></li>
            <li>Default Value: <span
                    id="useWishart_default_value">false</span></li>
            <li>Lower Bound:
                <span id="useWishart_lower_bound"></span></li>
            <li>Upper Bound: <span
                    id="useWishart_upper_bound"></span></li>
            <li>Value Type: <span
                    id="useWishart_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description" id="checkType">checkType</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="checkType_short_desc">
                    Model significance check type: 1 = Significance, 2 = Clique, 3 = None
            </span></li>
            <li>Long Description: <span id="checkType_long_desc">
        		Model significance check type: 1 = Significance, 2 = Clique, 3 = None
                </span></li>
            <li>Default Value: <span
                    id="checkType_default_value">1</span></li>
            <li>Lower Bound: <span
                    id="checkType_lower_bound">1</span></li>
            <li>Upper Bound: <span
                    id="checkType_upper_bound">3</span></li>
            <li>Value
                Type: <span id="checkType_value_type">Integer</span></li>
        </ul>

        <h3 class="parameter_description" id="varHigh">varHigh</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="varHigh_short_desc">High end of variance range (min =
        0.0)</span></li>
            <li>Long Description: <span id="varHigh_long_desc">
        The parameter 'b' for drawing independent variance values, from +U(a,
        b). </span></li>
            <li>Default Value: <span
                    id="varHigh_default_value">3.0</span></li>
            <li>Lower Bound: <span
                    id="varHigh_lower_bound">0.0</span></li>
            <li>Upper Bound: <span
                    id="varHigh_upper_bound">1.7976931348623157E308</span></li>
            <li>Value
                Type: <span id="varHigh_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description" id="significanceChecked">significanceChecked</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="significanceChecked_short_desc">
                    True if the significance of the cluster should be checked.
                    </span></li>
            <li>Long Description: <span id="significanceChecked_long_desc">
            True if the significance of clusters should be checked, false if not.
            </span></li>
            <li>Default Value: <span
                    id="significanceChecked_default_value">false</span></li>
            <li>Lower Bound: <span
                    id="significanceChecked_lower_bound"></span></li>
            <li>Upper Bound: <span
                    id="significanceChecked_upper_bound"></span></li>
            <li>Value
                Type: <span id="significanceChecked_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description" id="varLow">varLow</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="varLow_short_desc">Low end of variance range (min =
        0.0)</span></li>
            <li>Long Description: <span id="varLow_long_desc">
        The parameter 'a' for drawing independent variance values, from +U(a,
        b). </span></li>
            <li>Default Value: <span
                    id="varLow_default_value">1.0</span></li>
            <li>Lower Bound: <span
                    id="varLow_lower_bound">0.0</span></li>
            <li>Upper Bound: <span
                    id="varLow_upper_bound">1.7976931348623157E308</span></li>
            <li>Value
                Type: <span id="varLow_value_type">Double</span></li>
        </ul>

        <h3 class="parameter_description" id="verbose">verbose</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="verbose_short_desc">Yes if verbose output should be printed or
        logged</span></li>
            <li>Long Description: <span
                    id="verbose_long_desc"> If this parameter is set to ‘Yes’, extra
        (“verbose”) output will be printed if available giving some details
        about the step-by-step operation of the algorithm.</span></li>
            <li>Default Value: <span id="verbose_default_value">false</span></li>
            <li>Lower Bound: <span id="verbose_lower_bound"></span></li>
            <li>Upper Bound: <span id="verbose_upper_bound"></span></li>
            <li>Value Type: <span id="verbose_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description"
            id="meekVerbose">meekVerbose</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="meekVerbose_short_desc">Yes if verbose output for Meek rule
        applications should be printed or logged</span></li>
            <li>Long
                Description: <span id="meekVerbose_long_desc"> If this parameter is
        set to ‘Yes’, Meek rule applications will be printed out to the
        log.</span></li>
            <li>Default Value: <span
                    id="meekVerbose_default_value">false</span></li>
            <li>Lower Bound:
                <span id="meekVerbose_lower_bound"></span></li>
            <li>Upper Bound:
                <span id="meekVerbose_upper_bound"></span></li>
            <li>Value Type: <span
                    id="meekVerbose_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description" id="useScore">useScore</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="useScore_short_desc">Yes if the score should be used; no if the
        test should be used</span></li>
            <li>Long Description: <span
                    id="useScore_long_desc"> BOSS can run either from a score or a test;
        this lets you choose which.</span></li>
            <li>Default Value: <span
                    id="useScore_default_value">true</span></li>
            <li>Lower Bound: <span
                    id="useScore_lower_bound"></span></li>
            <li>Upper Bound: <span
                    id="useScore_upper_bound"></span></li>
            <li>Value Type: <span
                    id="useScore_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description"
            id="outputCpdag">outputCpdag</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="outputCpdag_short_desc">Yes if CPDAG should be output, no if a
        DAG.</span></li>
            <li>Long Description: <span
                    id="outputCpdag_long_desc">BOSS can output a DAG or the CPDAG of the
        DAG.</span></li>
            <li>Default Value: <span
                    id="outputCpdag_default_value">true</span></li>
            <li>Lower Bound:
                <span id="outputCpdag_lower_bound"></span></li>
            <li>Upper Bound:
                <span id="outputCpdag_upper_bound"></span></li>
            <li>Value Type: <span
                    id="outputCpdag_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description"
            id="cacheScores">cacheScores</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="cacheScores_short_desc">Yes score results should be cached, no if
        not</span></li>
            <li>Long Description: <span
                    id="cacheScores_long_desc">Caching scores can use a lot of
        memory.</span></li>
            <li>Default Value: <span
                    id="cacheScores_default_value">true</span></li>
            <li>Lower Bound:
                <span id="cacheScores_lower_bound"></span></li>
            <li>Upper Bound:
                <span id="cacheScores_upper_bound"></span></li>
            <li>Value Type: <span
                    id="cacheScores_value_type">Boolean</span></li>
        </ul>

        <h3 class="parameter_description"
            id="include_structure_model">verbose</h3>
        <ul
                class="parameter_description_list">
            <li>Short Description: <span
                    id="include_structure_model_short_desc">Yes if the (MimBuild)
        structure model should be included in the output graph</span></li>
            <li>Long Description: <span id="include_structure_model_long_desc">
        FOFC proper yields a measurement model--that is, a set of pure
        children for each of the discovered latents. One can estimate the
        structure over the latents (the structure model) using Mimbuild. This
        structure model is included in the output if this parameter is set to
        Yes.</span></li>
            <li>Default Value: <span
                    id="include_structure_model_default_value">true</span></li>
            <li>Lower
                Bound: <span id="include_structure_model_lower_bound"></span></li>
            <li>Upper Bound: <span
                    id="include_structure_model_upper_bound"></span></li>
            <li>Value Type:
                <span id="include_structure_model_value_type">Boolean</span></li>
        </ul>

    </div> <!-- End of search parameters -->


    <h1 id="regression_box"><span class="section_heading">Regression
    Box</span></h1>

    <p>The regression box performs regression on variables in a data set,
        in an attempt to discover causal correlations between them. Both linear
        and regression are available.</p>

    <h2>Possible Parent Boxes of the Regression Box</h2>

    <ul class="ul">
        <li>A data box</li>
        <li>A simulation box</li>
    </ul>

    <h2>Possible Child Boxes of the Instantiated Model Box:</h2>

    <ul class="ul">
        <li>A graph box</li>
        <li>A compare box</li>
        <li>A
            parametric model box
        </li>
        <li>A data box</li>
        <li>A simulation box</li>
        <li>A search box</li>
    </ul>

    <h2>Multiple Linear Regression</h2>

    <p>Linear regression is performed upon continuous data sets. If you
        have a categorical data set upon which you would like to perform linear
        regression, you can make it continuous using the data manipulation
        box.</p>

    <p>Take, for example, a data set with the following underlying causal
        structure:</p>

    <img alt="" src="images/regression_box_1.png" width="360">

    <p>When used as input to the linear regression box, the following
        window results: </p>

    <img alt="" src="images/regression_box_2.png" width="650">

    <p>To select a variable as the response variable, click on it in the
        leftmost box, and then click on the top right-pointing arrow. If you
        change your mind about which variable should be the response variable,
        simply click on another variable and click on the arrow again. </p>

    <p>To select a variable as a predictor variable, click on it in the
        leftmost box, and then click on the second right-pointing arrow. To
        remove a predictor variable, click on it in the predictor box and then
        click on the left-pointing arrow.</p>

    <p>Clicking “Sort Variables” rearranges the variables in the
        predictor box so that they follow the same order they did in the leftmost
        box. The alpha value in the lower left corner is a threshold for
        independence; the higher it is set, the less discerning Tetrad is when
        determining the independence of two variables.</p>

    <p>When we click “Execute,” the results of the regression appear in
        the box to the right. For each predictor variable, Tetrad lists the
        standard error, t value, and p value, and whether its correlation with
        the response variable is significant. </p>

    <p>The Output Graph tab contains a graphical model of the information
        contained in the Model tab. For the case in which X4 is the response
        variable and X1, X2, and X3 are the predictors, Tetrad finds that only X1
        is significant, and the output graph looks like this:</p>

    <img alt="" src="images/regression_box_3.png" width="70">

    <p>Comparison to the true causal model shows that this correlation
        does exist, but that it runs in the opposite direction.</p>

    <h2>Logistic Regression</h2>

    <p>Logistic regression may be run on discrete, continuous, or mixed
        data sets; however, the response variable must be binary. In all other
        ways, the logistic regression box functions like the linear regression
        box. </p>

    <h1 id="appendix"><span
            class="section_heading">Appendices</span></h1>
    <h2>An Introduction to
        PAGs</h2>
    <p>Peter Spirtes</p>

    <p>The output of the FCI algorithm [Spirtes, 2001] is a partial
        ancestral graph (PAG), which is a graphical object that represents a set
        of causal Bayesian networks (CBNs) that cannot be distinguished by the
        algorithm. Suppose we have a set of cases that were generated by random
        sampling from some CBN. Under the assumptions that FCI makes, in the
        large sample limit of the number of cases, the PAG returned by FCI is
        guaranteed to include the CBN that generated the data.</p>

    <p>An example of a PAG is shown in Figure 2. This PAG represents the
        pair of CBNs in Figure 1a and 1b (where measured variables are in boxes
        and unmeasured variables are in ovals), as well as an infinite number of
        other CBNs that may have an arbitrarily large set of unmeasured
        confounders. Despite the fact that there are important differences
        between the CBNs in Figure 1a and 1b (e.g., there is an unmeasured
        confounder of X1 and X2 in Figure 1 b but not in Figure 1a), they share a
        number of important features in common (e.g., in both CBNs, X2 is a
        direct cause of X6, there is no unmeasured confounder of X2 and X6, and
        X6 is not a cause of X2). It can be shown that every CBN that a PAG
        represents shares certain features in common. The features that all CBNs
        represented by a PAG share in common can be read off of the output PAG
        according to the rules described next.</p>

    <p>There are 4 kinds of edges that occur in a PAG: A -> B, A o-> B, A
        o–o B, and A <-> B. The edges indicate what the CBNs represented by the
        PAG have in common. A description of the meaning of each edge in a PAG is
        given in Table A1. </p>


    <p>Table A1: Types of edges in a PAG.</p>

    <table class="table">
        <thead>
        <tr>
            <th>Edge type</th>
            <th>Relationships that are present</th>
            <th>Relationships that are
                absent
            </th>
        </tr>
        </thead>

        <tbody>

        <tr>
            <td>A --> B</td>
            <td>A is a cause of B. It may
                be a direct or indirect because that may include other measured
                variables. Also, there may be an unmeasured confounder of A and B.
            </td>
            <td>B is not a cause of A.</td>
        </tr>
        <tr>
            <td>A <-> B</td>
            <td>There is an unmeasured variable (call it L) that is a cause of A
                and B. There may be measured variables along the causal pathway from
                L to A or from L to B.
            </td>
            <td>A is not a cause of B. B is not a
                cause of A.
            </td>
        </tr>
        <tr>
            <td>A o-> B</td>
            <td>Either A is a cause
                of B, or there is an unmeasured variable that is a cause of A and B,
                or both.
            </td>
            <td>B is not a cause of A.</td>
        </tr>
        <tr>
            <td>A o–o
                B
            </td>
            <td>Exactly one of the following holds: (a) A is a cause of B,
                or (b) B is a cause of A, or (c) there is an unmeasured variable that
                is a cause of A and B, or (d) both a and c, or (e) both b and c.
            </td>
            <td></td>
        </tr>

        </tbody>
    </table>


    <p>Table A1 is sufficient to understand the basic meaning of edge
        types in PAGs. Nonetheless, it can be helpful to know the following
        additional perspective on the information encoded by PAGs. Each edge has
        two endpoints, one on the A side, and one on the B side. For example A
        --> B has a tail at the A end, and an arrowhead at the B end. Altogether,
        there are three kinds of edge endpoints: a tail "–", an arrowhead ">",
        and a "o." Note that some kinds of combinations of endpoints never occur;
        for example, A o– B never occurs. As a mnemonic device, the basic meaning
        of each kind of edge can be derived from three simple rules that explain
        what the meaning of each kind of endpoint is. A tail "–" at the A end of
        an edge between A and B means "A is a cause of B"; an arrowhead ">" at
        the A end of an edge between A and B means "A is not a cause of B"; and a
        circle "o" at the A end of an edge between A and B means "can't tell
        whether A is a cause of B". For example A --> B means that A is a
        cause of B, and that B is not a cause of A in all the CBNs represented
        by the PAG. </p>
    <p>The PAG in Figure 2 shows examples of each type of
        edge, and the CBNs. Figure 1. show some examples of what kinds of CBNs
        can be represented by that PAG. </p>

    <img alt="" src="images/appendix_figure_1a.png" width="360"> <img
        alt="" src="images/appendix_figure_1b.png" width="360">
    <p>Figure 1. Two
        CBNs that FCI (as well as FCI+, GFCI, and RFCI) cannot distinguish.</p>

    <img alt="" src="images/appendix_figure_2.png" width="360">
    <p>Figure
        2. The PAG that represents the CBN s in both Figures 1a and 1b.</p>


    <h2>Arc Specializations in PAGs</h2>

    <p>This section describes two types of arc specializations that
        provide additional information about the nature of an arc in a PAG.</p>

    <p>One arc specialization is colored <span
            style="color:green">green</span> and is called <span style="font-style:
    italic; ">definitely visible</span>. In a PAG P without selection bias, a
        green (definitely visible) arc from A to B denotes that A and B do not
        have a latent confounder. If an arc is not definitely visible
        (represented as black) then A and B may have a latent confounder.</p>

    <p>Another arc specialization is shown as <span style="font-weight:
    bold; ">bold</span> and is called <span style="font-style: italic;
    ">definitely direct</span>. In a PAG P without selection bias, a bold
        (definitely direct) arc from A to B denotes that A is a direct cause of
        B, relative to the other measured variables. If an arc is not definitely
        direct (represented as not bolded) then A may not be a direct cause of B,
        in which case there may be one or more measured variables on every causal
        path from A to B.</p>


    <p>In the following examples, the DAG representing a causal process
        is on the left, and the corresponding PAG is on the right. All variables
        are observed except for latent variable L.</p>

    <p>Example of an edge C <span style="color:green; font-weight:
    bold;">➔</span> D that is definitely visible (green) and definitely
        direct (bold):</p>

    <img alt="" src="images/arc_specialization_1.png" width="360">

    <p>Example of an edge (C <span style="color:green; ">➔</span> E) that
        is definitely visible (green) and not definitely direct (not bold):</p>

    <img alt="" src="images/arc_specialization_2.png" width="360">

    <p>Example of an edge (F ➔ E) that is not definitely visible (black)
        and not definitely direct (not bold):</p>

    <img alt="" src="images/arc_specialization_3.png" width="360">

    <p>It is conjectured that it is not possible for an edge to be
        definitely direct (bold) and not definitely visible (black).</p>


    <h2>Solving Out of Memory Errors</h2>
    <p>By default, Java will
        allocate the smaller option of 1/4 system memory or 1GB to the Java virtual
        machine (JVM). If you run out of memory (heap memory space) running your
        analyses you should increase the memory allocated to the JVM with the
        following switch '-XmxXXG' where XX is the number of gigabytes of ram you
        allow the JVM to utilize. To run Tetrad with more memory you need to
        start it from the command line or terminal. For example to allocate 8
        gigabytes of ram you would add -Xmx8G immediately after the java command
        e.g., java -Xmx8G -jar tetrad-gui.jar.</p>

    <h2>Glossary of Terms</h2>

    <h5>Adjacent</h5>
    <p>Two vertices in a graph are adjacent if there is
        a directed, or undirected, or double-headed edge between them.</p>

    <h5>Degree</h5>
    <p>The total number of edges directed both into and
        out of a vertex.</p>

    <h5>Indegree</h5>
    <p>The number of edges directed into a vertex.</p>

    <h5>Markov Blanket</h5>
    <p>In a variable set V, with joint
        probability Pr, the Markov Blanket of a variable X in V is the smallest
        subset M of V \ {X} such that X II V \ M | M. In a DAG model, the Markov
        Blanket of X is the union of the set of direct causes (parents) of X, the
        set of direct effects (children) of X, and the set of direct causes of
        direct effects of X.</p>

    <h5>Markov Equivalent Graphs</h5>
    <p>Two directed acyclic graphs
        (DAGS) are Markov Equivalent if they have the same adjacencies and for
        every triple X – Y – Z of adjacent vertices, if X and Z are not adjacent,
        X -> Y &lt;- Z in both graphs or in neither graph.</p>

    <h5>Meek Orientation Rules</h5>
    <p>Rules for finding all directions
        of edges implied by a CPDAG, consistent with any specified “knowledge”
        constraints on directions. See <a
                href="https://arxiv.org/pdf/1302.4972.pdf">https://arxiv.org/pdf/1302.
            4972.pdf</a></p>

    <h5>Mixed Ancestral Graph (MAG)</h5>
    <p>An acyclic graph with
        directed and undirected edges. Directed edges have the same
        interpretation as in DAGs. Undirected edges represent common causes. See
        Richardson, T. (2003). Markov properties for acyclic directed mixed
        graphs. <em>Scandinavian Journal of Statistics</em>, 30(1), 145-157.</p>

    <h5>Multiple Indicator Model</h5>
    <p>A graphical model in which
        unmeasured variables each have multiple measured effects. There may be
        directed edges between unmeasured variables, but no directed edges from
        measured variables to unmeasured variables are allowed.</p>

    <h5>Outdegree</h5>
    <p>The number of edges directed out of a
        vertex.</p>

    <h5>Partial Ancestral Graph (PAG)</h5>
    <p>See PAG description in this
        manual.</p>

    <h5>CPDAG</h5>
    <p>A graphical representation of a Markov Equivalence
        Class or Classes, having both directed and undirected edges, with an
        undirected edge indicating that for each possible direction of the edge,
        there is a graph in the class or classes having that edge direction.</p>

    <h5>Scale Free Graph</h5>
    <p>A network in which the frequency of
        nodes with degree k obeys a power law--the relation between log of degree
        and log of frequency is roughly linear. See <a
                href="https://cs.brynmawr.edu/Courses/cs380/spring2013/section02/slides/
    10_ScaleFreeNetworks.pdf">https://cs.brynmawr.edu/Courses/cs380/
            spring2013/section02/slides/10_ScaleFreeNetworks.pdf</a>. </p>

    <h5>Trek</h5>
    <p>A trek between X and Y is a directed path from X to
        Y or from Y to X, or two directed paths from a third variable Z into X
        and Y that do not intersect except at Z.</p>

</div>
</body>
</html>
